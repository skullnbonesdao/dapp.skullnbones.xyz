import{Q as Cr,a as vr,b as Oo}from"./QInput.cfcfe41b.js";import{Q as Ho}from"./QPage.57cdb4a4.js";import{a as ge,Q as Wr}from"./QCard.467f42dd.js";import{Q as Wo}from"./QSpace.93fafbd1.js";import{e9 as js,di as V,dj as Bt,dk as M,dl as D,dm as Nt,dn as rt,dp as Kt,dq as De,dG as jt,dI as gt,de as Tt,cX as Kr,e6 as Vo,e7 as jo,e8 as Go,dM as Zo,dN as Yo,P as Xt,dT as Qo,ea as Xo,cn as Et,cq as zn,eb as Jo,d3 as ti,au as Rn,b1 as kt,ai as se,bx as St,as as tt,al as b,V as st,ck as ye,ak as pe,bz as ys,a6 as Gs,b7 as Zs,a1 as Ct,aj as An,cs as bs,J as Ys,aX as Qs,bs as ei,cl as ni}from"./index.a7087e37.js";import{c as ws,d as xs}from"./use-key-composition.4a3c6082.js";import{Q as ri}from"./QList.07fc55b3.js";import{b as a,a as P,c as si,d as oi}from"./Amount.1355d7c2.js";import{f as ln,g as Ge}from"./assert.cc5be821.js";import{d as Zt}from"./index.56b70e30.js";import{h as ii}from"./handle_confirmation.13e36ee7.js";import{t as ci}from"./token.ef269610.js";import{T as ai}from"./constants.5727eee4.js";import{Q as ui}from"./QImg.71ac785d.js";import{Q as dn}from"./QSeparator.86315e67.js";import{_ as li}from"./plugin-vue_export-helper.21dcd24c.js";import"./sha256.9a6363b4.js";import"./defineProperty.034d6b40.js";function Ss(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function di(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function Mn(n,...t){if(!di(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${n.length}`)}function fi(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Ss(n.outputLen),Ss(n.blockLen)}function In(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function hi(n,t){Mn(n);const e=t.outputLen;if(n.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Er=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Tr=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),Yt=(n,t)=>n<<32-t|n>>>t;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function gi(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function Vr(n){return typeof n=="string"&&(n=gi(n)),Mn(n),n}function pi(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];Mn(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const o=n[r];e.set(o,s),s+=o.length}return e}class Xs{clone(){return this._cloneInto()}}function Js(n){const t=r=>n().update(Vr(r)).digest(),e=n();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>n(),t}function to(n=32){if(Er&&typeof Er.getRandomValues=="function")return Er.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function mi(n,t,e,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,e,r);const s=BigInt(32),o=BigInt(4294967295),i=Number(e>>s&o),u=Number(e&o),c=r?4:0,l=r?0:4;n.setUint32(t+c,i,r),n.setUint32(t+l,u,r)}const yi=(n,t,e)=>n&t^~n&e,bi=(n,t,e)=>n&t^n&e^t&e;class eo extends Xs{constructor(t,e,r,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Tr(this.buffer)}update(t){In(this);const{view:e,buffer:r,blockLen:s}=this;t=Vr(t);const o=t.length;for(let i=0;i<o;){const u=Math.min(s-this.pos,o-i);if(u===s){const c=Tr(t);for(;s<=o-i;i+=s)this.process(c,i);continue}r.set(t.subarray(i,i+u),this.pos),this.pos+=u,i+=u,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){In(this),hi(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:o}=this;let{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(r,0),i=0);for(let f=i;f<s;f++)e[f]=0;mi(r,s-8,BigInt(this.length*8),o),this.process(r,0);const u=Tr(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,d=this.get();if(l>d.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<l;f++)u.setUint32(4*f,d[f],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:o,destroyed:i,pos:u}=this;return t.length=s,t.pos=u,t.finished=o,t.destroyed=i,s%e&&t.buffer.set(r),t}}const fn=BigInt(2**32-1),Pr=BigInt(32);function no(n,t=!1){return t?{h:Number(n&fn),l:Number(n>>Pr&fn)}:{h:Number(n>>Pr&fn)|0,l:Number(n&fn)|0}}function wi(n,t=!1){let e=new Uint32Array(n.length),r=new Uint32Array(n.length);for(let s=0;s<n.length;s++){const{h:o,l:i}=no(n[s],t);[e[s],r[s]]=[o,i]}return[e,r]}const xi=(n,t)=>BigInt(n>>>0)<<Pr|BigInt(t>>>0),Si=(n,t,e)=>n>>>e,Ai=(n,t,e)=>n<<32-e|t>>>e,ki=(n,t,e)=>n>>>e|t<<32-e,Ii=(n,t,e)=>n<<32-e|t>>>e,Bi=(n,t,e)=>n<<64-e|t>>>e-32,vi=(n,t,e)=>n>>>e-32|t<<64-e,Ei=(n,t)=>t,Ti=(n,t)=>n,_i=(n,t,e)=>n<<e|t>>>32-e,Li=(n,t,e)=>t<<e|n>>>32-e,zi=(n,t,e)=>t<<e-32|n>>>64-e,Ri=(n,t,e)=>n<<e-32|t>>>64-e;function Mi(n,t,e,r){const s=(t>>>0)+(r>>>0);return{h:n+e+(s/2**32|0)|0,l:s|0}}const Ci=(n,t,e)=>(n>>>0)+(t>>>0)+(e>>>0),Ki=(n,t,e,r)=>t+e+r+(n/2**32|0)|0,Pi=(n,t,e,r)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0),Fi=(n,t,e,r,s)=>t+e+r+s+(n/2**32|0)|0,Di=(n,t,e,r,s)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0)+(s>>>0),Ni=(n,t,e,r,s,o)=>t+e+r+s+o+(n/2**32|0)|0,qi={fromBig:no,split:wi,toBig:xi,shrSH:Si,shrSL:Ai,rotrSH:ki,rotrSL:Ii,rotrBH:Bi,rotrBL:vi,rotr32H:Ei,rotr32L:Ti,rotlSH:_i,rotlSL:Li,rotlBH:zi,rotlBL:Ri,add:Mi,add3L:Ci,add3H:Ki,add4L:Pi,add4H:Fi,add5H:Ni,add5L:Di};var G=qi;const[$i,Ui]=(()=>G.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))))(),ce=new Uint32Array(80),ae=new Uint32Array(80);class Oi extends eo{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:r,Bl:s,Ch:o,Cl:i,Dh:u,Dl:c,Eh:l,El:d,Fh:f,Fl:S,Gh:I,Gl:w,Hh:h,Hl:p}=this;return[t,e,r,s,o,i,u,c,l,d,f,S,I,w,h,p]}set(t,e,r,s,o,i,u,c,l,d,f,S,I,w,h,p){this.Ah=t|0,this.Al=e|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=u|0,this.Dl=c|0,this.Eh=l|0,this.El=d|0,this.Fh=f|0,this.Fl=S|0,this.Gh=I|0,this.Gl=w|0,this.Hh=h|0,this.Hl=p|0}process(t,e){for(let A=0;A<16;A++,e+=4)ce[A]=t.getUint32(e),ae[A]=t.getUint32(e+=4);for(let A=16;A<80;A++){const H=ce[A-15]|0,C=ae[A-15]|0,K=G.rotrSH(H,C,1)^G.rotrSH(H,C,8)^G.shrSH(H,C,7),U=G.rotrSL(H,C,1)^G.rotrSL(H,C,8)^G.shrSL(H,C,7),F=ce[A-2]|0,ct=ae[A-2]|0,X=G.rotrSH(F,ct,19)^G.rotrBH(F,ct,61)^G.shrSH(F,ct,6),J=G.rotrSL(F,ct,19)^G.rotrBL(F,ct,61)^G.shrSL(F,ct,6),pt=G.add4L(U,J,ae[A-7],ae[A-16]),mt=G.add4H(pt,K,X,ce[A-7],ce[A-16]);ce[A]=mt|0,ae[A]=pt|0}let{Ah:r,Al:s,Bh:o,Bl:i,Ch:u,Cl:c,Dh:l,Dl:d,Eh:f,El:S,Fh:I,Fl:w,Gh:h,Gl:p,Hh:k,Hl:B}=this;for(let A=0;A<80;A++){const H=G.rotrSH(f,S,14)^G.rotrSH(f,S,18)^G.rotrBH(f,S,41),C=G.rotrSL(f,S,14)^G.rotrSL(f,S,18)^G.rotrBL(f,S,41),K=f&I^~f&h,U=S&w^~S&p,F=G.add5L(B,C,U,Ui[A],ae[A]),ct=G.add5H(F,k,H,K,$i[A],ce[A]),X=F|0,J=G.rotrSH(r,s,28)^G.rotrBH(r,s,34)^G.rotrBH(r,s,39),pt=G.rotrSL(r,s,28)^G.rotrBL(r,s,34)^G.rotrBL(r,s,39),mt=r&o^r&u^o&u,z=s&i^s&c^i&c;k=h|0,B=p|0,h=I|0,p=w|0,I=f|0,w=S|0,{h:f,l:S}=G.add(l|0,d|0,ct|0,X|0),l=u|0,d=c|0,u=o|0,c=i|0,o=r|0,i=s|0;const y=G.add3L(X,pt,z);r=G.add3H(y,ct,J,mt),s=y|0}({h:r,l:s}=G.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:i}=G.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:u,l:c}=G.add(this.Ch|0,this.Cl|0,u|0,c|0),{h:l,l:d}=G.add(this.Dh|0,this.Dl|0,l|0,d|0),{h:f,l:S}=G.add(this.Eh|0,this.El|0,f|0,S|0),{h:I,l:w}=G.add(this.Fh|0,this.Fl|0,I|0,w|0),{h,l:p}=G.add(this.Gh|0,this.Gl|0,h|0,p|0),{h:k,l:B}=G.add(this.Hh|0,this.Hl|0,k|0,B|0),this.set(r,s,o,i,u,c,l,d,f,S,I,w,h,p,k,B)}roundClean(){ce.fill(0),ae.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Hi=Js(()=>new Oi);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jr=BigInt(0),Cn=BigInt(1),Wi=BigInt(2);function _e(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function nn(n){if(!_e(n))throw new Error("Uint8Array expected")}function oe(n,t){if(typeof t!="boolean")throw new Error(`${n} must be valid boolean, got "${t}".`)}const Vi=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function Le(n){nn(n);let t="";for(let e=0;e<n.length;e++)t+=Vi[n[e]];return t}function ro(n){const t=n.toString(16);return t.length&1?`0${t}`:t}function Gr(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}const ne={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function As(n){if(n>=ne._0&&n<=ne._9)return n-ne._0;if(n>=ne._A&&n<=ne._F)return n-(ne._A-10);if(n>=ne._a&&n<=ne._f)return n-(ne._a-10)}function $e(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const t=n.length,e=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){const i=As(n.charCodeAt(o)),u=As(n.charCodeAt(o+1));if(i===void 0||u===void 0){const c=n[o]+n[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}r[s]=i*16+u}return r}function Ee(n){return Gr(Le(n))}function Ne(n){return nn(n),Gr(Le(Uint8Array.from(n).reverse()))}function Ue(n,t){return $e(n.toString(16).padStart(t*2,"0"))}function Ye(n,t){return Ue(n,t).reverse()}function ji(n){return $e(ro(n))}function bt(n,t,e){let r;if(typeof t=="string")try{r=$e(t)}catch(o){throw new Error(`${n} must be valid hex string, got "${t}". Cause: ${o}`)}else if(_e(t))r=Uint8Array.from(t);else throw new Error(`${n} must be hex string or Uint8Array`);const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(`${n} expected ${e} bytes, got ${s}`);return r}function ze(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];nn(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const o=n[r];e.set(o,s),s+=o.length}return e}function Gi(n,t){if(n.length!==t.length)return!1;let e=0;for(let r=0;r<n.length;r++)e|=n[r]^t[r];return e===0}function Zi(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}const _r=n=>typeof n=="bigint"&&jr<=n;function Kn(n,t,e){return _r(n)&&_r(t)&&_r(e)&&t<=n&&n<e}function Ot(n,t,e,r){if(!Kn(t,e,r))throw new Error(`expected valid ${n}: ${e} <= n < ${r}, got ${typeof t} ${t}`)}function Yi(n){let t;for(t=0;n>jr;n>>=Cn,t+=1);return t}function Qi(n,t){return n>>BigInt(t)&Cn}function Xi(n,t,e){return n|(e?Cn:jr)<<BigInt(t)}const Zr=n=>(Wi<<BigInt(n-1))-Cn,Lr=n=>new Uint8Array(n),ks=n=>Uint8Array.from(n);function so(n,t,e){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Lr(n),s=Lr(n),o=0;const i=()=>{r.fill(1),s.fill(0),o=0},u=(...f)=>e(s,r,...f),c=(f=Lr())=>{s=u(ks([0]),f),r=u(),f.length!==0&&(s=u(ks([1]),f),r=u())},l=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const S=[];for(;f<t;){r=u();const I=r.slice();S.push(I),f+=r.length}return ze(...S)};return(f,S)=>{i(),c(f);let I;for(;!(I=S(l()));)c();return i(),I}}const Ji={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||_e(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,t)=>t.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function He(n,t,e={}){const r=(s,o,i)=>{const u=Ji[o];if(typeof u!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=n[s];if(!(i&&c===void 0)&&!u(c,n))throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${o}`)};for(const[s,o]of Object.entries(t))r(s,o,!1);for(const[s,o]of Object.entries(e))r(s,o,!0);return n}const tc=()=>{throw new Error("not implemented")};function Qe(n){const t=new WeakMap;return(e,...r)=>{const s=t.get(e);if(s!==void 0)return s;const o=n(e,...r);return t.set(e,o),o}}var ec=Object.freeze(Object.defineProperty({__proto__:null,isBytes:_e,abytes:nn,abool:oe,bytesToHex:Le,numberToHexUnpadded:ro,hexToNumber:Gr,hexToBytes:$e,bytesToNumberBE:Ee,bytesToNumberLE:Ne,numberToBytesBE:Ue,numberToBytesLE:Ye,numberToVarBytesBE:ji,ensureBytes:bt,concatBytes:ze,equalBytes:Gi,utf8ToBytes:Zi,inRange:Kn,aInRange:Ot,bitLen:Yi,bitGet:Qi,bitSet:Xi,bitMask:Zr,createHmacDrbg:so,validateObject:He,notImplemented:tc,memoized:Qe},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const At=BigInt(0),dt=BigInt(1),be=BigInt(2),nc=BigInt(3),Fr=BigInt(4),Is=BigInt(5),Bs=BigInt(8);BigInt(9);BigInt(16);function it(n,t){const e=n%t;return e>=At?e:t+e}function rc(n,t,e){if(e<=At||t<At)throw new Error("Expected power/modulo > 0");if(e===dt)return At;let r=dt;for(;t>At;)t&dt&&(r=r*n%e),n=n*n%e,t>>=dt;return r}function ft(n,t,e){let r=n;for(;t-- >At;)r*=r,r%=e;return r}function Dr(n,t){if(n===At||t<=At)throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);let e=it(n,t),r=t,s=At,o=dt;for(;e!==At;){const u=r/e,c=r%e,l=s-o*u;r=e,e=c,s=o,o=l}if(r!==dt)throw new Error("invert: does not exist");return it(s,t)}function sc(n){const t=(n-dt)/be;let e,r,s;for(e=n-dt,r=0;e%be===At;e/=be,r++);for(s=be;s<n&&rc(s,t,n)!==n-dt;s++);if(r===1){const i=(n+dt)/Fr;return function(c,l){const d=c.pow(l,i);if(!c.eql(c.sqr(d),l))throw new Error("Cannot find square root");return d}}const o=(e+dt)/be;return function(u,c){if(u.pow(c,t)===u.neg(u.ONE))throw new Error("Cannot find square root");let l=r,d=u.pow(u.mul(u.ONE,s),e),f=u.pow(c,o),S=u.pow(c,e);for(;!u.eql(S,u.ONE);){if(u.eql(S,u.ZERO))return u.ZERO;let I=1;for(let h=u.sqr(S);I<l&&!u.eql(h,u.ONE);I++)h=u.sqr(h);const w=u.pow(d,dt<<BigInt(l-I-1));d=u.sqr(w),f=u.mul(f,w),S=u.mul(S,d),l=I}return f}}function oc(n){if(n%Fr===nc){const t=(n+dt)/Fr;return function(r,s){const o=r.pow(s,t);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(n%Bs===Is){const t=(n-Is)/Bs;return function(r,s){const o=r.mul(s,be),i=r.pow(o,t),u=r.mul(s,i),c=r.mul(r.mul(u,be),i),l=r.mul(u,r.sub(c,r.ONE));if(!r.eql(r.sqr(l),s))throw new Error("Cannot find square root");return l}}return sc(n)}const ic=(n,t)=>(it(n,t)&dt)===dt,cc=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ac(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=cc.reduce((r,s)=>(r[s]="function",r),t);return He(n,e)}function uc(n,t,e){if(e<At)throw new Error("Expected power > 0");if(e===At)return n.ONE;if(e===dt)return t;let r=n.ONE,s=t;for(;e>At;)e&dt&&(r=n.mul(r,s)),s=n.sqr(s),e>>=dt;return r}function lc(n,t){const e=new Array(t.length),r=t.reduce((o,i,u)=>n.is0(i)?o:(e[u]=o,n.mul(o,i)),n.ONE),s=n.inv(r);return t.reduceRight((o,i,u)=>n.is0(i)?o:(e[u]=n.mul(o,e[u]),n.mul(o,i)),s),e}function oo(n,t){const e=t!==void 0?t:n.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function io(n,t,e=!1,r={}){if(n<=At)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:s,nByteLength:o}=oo(n,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=oc(n),u=Object.freeze({ORDER:n,BITS:s,BYTES:o,MASK:Zr(s),ZERO:At,ONE:dt,create:c=>it(c,n),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return At<=c&&c<n},is0:c=>c===At,isOdd:c=>(c&dt)===dt,neg:c=>it(-c,n),eql:(c,l)=>c===l,sqr:c=>it(c*c,n),add:(c,l)=>it(c+l,n),sub:(c,l)=>it(c-l,n),mul:(c,l)=>it(c*l,n),pow:(c,l)=>uc(u,c,l),div:(c,l)=>it(c*Dr(l,n),n),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>Dr(c,n),sqrt:r.sqrt||(c=>i(u,c)),invertBatch:c=>lc(u,c),cmov:(c,l,d)=>d?l:c,toBytes:c=>e?Ye(c,o):Ue(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return e?Ne(c):Ee(c)}});return Object.freeze(u)}function co(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function ao(n){const t=co(n);return t+Math.ceil(t/2)}function dc(n,t,e=!1){const r=n.length,s=co(t),o=ao(t);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const i=e?Ee(n):Ne(n),u=it(i,t-dt)+dt;return e?Ye(u,s):Ue(u,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const fc=BigInt(0),zr=BigInt(1),Rr=new WeakMap,vs=new WeakMap;function uo(n,t){const e=(o,i)=>{const u=i.negate();return o?u:i},r=o=>{if(!Number.isSafeInteger(o)||o<=0||o>t)throw new Error(`Wrong window size=${o}, should be [1..${t}]`)},s=o=>{r(o);const i=Math.ceil(t/o)+1,u=2**(o-1);return{windows:i,windowSize:u}};return{constTimeNegate:e,unsafeLadder(o,i){let u=n.ZERO,c=o;for(;i>fc;)i&zr&&(u=u.add(c)),c=c.double(),i>>=zr;return u},precomputeWindow(o,i){const{windows:u,windowSize:c}=s(i),l=[];let d=o,f=d;for(let S=0;S<u;S++){f=d,l.push(f);for(let I=1;I<c;I++)f=f.add(d),l.push(f);d=f.double()}return l},wNAF(o,i,u){const{windows:c,windowSize:l}=s(o);let d=n.ZERO,f=n.BASE;const S=BigInt(2**o-1),I=2**o,w=BigInt(o);for(let h=0;h<c;h++){const p=h*l;let k=Number(u&S);u>>=w,k>l&&(k-=I,u+=zr);const B=p,A=p+Math.abs(k)-1,H=h%2!==0,C=k<0;k===0?f=f.add(e(H,i[B])):d=d.add(e(C,i[A]))}return{p:d,f}},wNAFCached(o,i,u){const c=vs.get(o)||1;let l=Rr.get(o);return l||(l=this.precomputeWindow(o,c),c!==1&&Rr.set(o,u(l))),this.wNAF(c,l,i)},setWindowSize(o,i){r(i),vs.set(o,i),Rr.delete(o)}}}function Yr(n){return ac(n.Fp),He(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...oo(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Vt=BigInt(0),Rt=BigInt(1),hn=BigInt(2),hc=BigInt(8),gc={zip215:!0};function pc(n){const t=Yr(n);return He(n,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function mc(n){const t=pc(n),{Fp:e,n:r,prehash:s,hash:o,randomBytes:i,nByteLength:u,h:c}=t,l=hn<<BigInt(u*8)-Rt,d=e.create,f=t.uvRatio||((y,m)=>{try{return{isValid:!0,value:e.sqrt(y*e.inv(m))}}catch{return{isValid:!1,value:Vt}}}),S=t.adjustScalarBytes||(y=>y),I=t.domain||((y,m,E)=>{if(oe("phflag",E),m.length||E)throw new Error("Contexts/pre-hash are not supported");return y});function w(y,m){Ot("coordinate "+y,m,Vt,l)}function h(y){if(!(y instanceof B))throw new Error("ExtendedPoint expected")}const p=Qe((y,m)=>{const{ex:E,ey:L,ez:N}=y,O=y.is0();m==null&&(m=O?hc:e.inv(N));const W=d(E*m),et=d(L*m),Y=d(N*m);if(O)return{x:Vt,y:Rt};if(Y!==Rt)throw new Error("invZ was invalid");return{x:W,y:et}}),k=Qe(y=>{const{a:m,d:E}=t;if(y.is0())throw new Error("bad point: ZERO");const{ex:L,ey:N,ez:O,et:W}=y,et=d(L*L),Y=d(N*N),nt=d(O*O),at=d(nt*nt),ut=d(et*m),Lt=d(nt*d(ut+Y)),wt=d(at+d(E*d(et*Y)));if(Lt!==wt)throw new Error("bad point: equation left != right (1)");const yt=d(L*N),Wt=d(O*W);if(yt!==Wt)throw new Error("bad point: equation left != right (2)");return!0});class B{constructor(m,E,L,N){this.ex=m,this.ey=E,this.ez=L,this.et=N,w("x",m),w("y",E),w("z",L),w("t",N),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(m){if(m instanceof B)throw new Error("extended point not allowed");const{x:E,y:L}=m||{};return w("x",E),w("y",L),new B(E,L,Rt,d(E*L))}static normalizeZ(m){const E=e.invertBatch(m.map(L=>L.ez));return m.map((L,N)=>L.toAffine(E[N])).map(B.fromAffine)}_setWindowSize(m){C.setWindowSize(this,m)}assertValidity(){k(this)}equals(m){h(m);const{ex:E,ey:L,ez:N}=this,{ex:O,ey:W,ez:et}=m,Y=d(E*et),nt=d(O*N),at=d(L*et),ut=d(W*N);return Y===nt&&at===ut}is0(){return this.equals(B.ZERO)}negate(){return new B(d(-this.ex),this.ey,this.ez,d(-this.et))}double(){const{a:m}=t,{ex:E,ey:L,ez:N}=this,O=d(E*E),W=d(L*L),et=d(hn*d(N*N)),Y=d(m*O),nt=E+L,at=d(d(nt*nt)-O-W),ut=Y+W,Lt=ut-et,wt=Y-W,yt=d(at*Lt),Wt=d(ut*wt),zt=d(at*wt),It=d(Lt*ut);return new B(yt,Wt,It,zt)}add(m){h(m);const{a:E,d:L}=t,{ex:N,ey:O,ez:W,et}=this,{ex:Y,ey:nt,ez:at,et:ut}=m;if(E===BigInt(-1)){const ls=d((O-N)*(nt+Y)),ds=d((O+N)*(nt-Y)),Br=d(ds-ls);if(Br===Vt)return this.double();const fs=d(W*hn*ut),hs=d(et*hn*at),gs=hs+fs,ps=ds+ls,ms=hs-fs,No=d(gs*Br),qo=d(ps*ms),$o=d(gs*ms),Uo=d(Br*ps);return new B(No,qo,Uo,$o)}const Lt=d(N*Y),wt=d(O*nt),yt=d(et*L*ut),Wt=d(W*at),zt=d((N+O)*(Y+nt)-Lt-wt),It=Wt-yt,ee=Wt+yt,je=d(wt-E*Lt),un=d(zt*It),Po=d(ee*je),Fo=d(zt*je),Do=d(It*ee);return new B(un,Po,Do,Fo)}subtract(m){return this.add(m.negate())}wNAF(m){return C.wNAFCached(this,m,B.normalizeZ)}multiply(m){const E=m;Ot("scalar",E,Rt,r);const{p:L,f:N}=this.wNAF(E);return B.normalizeZ([L,N])[0]}multiplyUnsafe(m){const E=m;return Ot("scalar",E,Vt,r),E===Vt?H:this.equals(H)||E===Rt?this:this.equals(A)?this.wNAF(E).p:C.unsafeLadder(this,E)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return C.unsafeLadder(this,r).is0()}toAffine(m){return p(this,m)}clearCofactor(){const{h:m}=t;return m===Rt?this:this.multiplyUnsafe(m)}static fromHex(m,E=!1){const{d:L,a:N}=t,O=e.BYTES;m=bt("pointHex",m,O),oe("zip215",E);const W=m.slice(),et=m[O-1];W[O-1]=et&-129;const Y=Ne(W),nt=E?l:e.ORDER;Ot("pointHex.y",Y,Vt,nt);const at=d(Y*Y),ut=d(at-Rt),Lt=d(L*at-N);let{isValid:wt,value:yt}=f(ut,Lt);if(!wt)throw new Error("Point.fromHex: invalid y coordinate");const Wt=(yt&Rt)===Rt,zt=(et&128)!==0;if(!E&&yt===Vt&&zt)throw new Error("Point.fromHex: x=0 and x_0=1");return zt!==Wt&&(yt=d(-yt)),B.fromAffine({x:yt,y:Y})}static fromPrivateKey(m){return F(m).point}toRawBytes(){const{x:m,y:E}=this.toAffine(),L=Ye(E,e.BYTES);return L[L.length-1]|=m&Rt?128:0,L}toHex(){return Le(this.toRawBytes())}}B.BASE=new B(t.Gx,t.Gy,Rt,d(t.Gx*t.Gy)),B.ZERO=new B(Vt,Rt,Rt,Vt);const{BASE:A,ZERO:H}=B,C=uo(B,u*8);function K(y){return it(y,r)}function U(y){return K(Ne(y))}function F(y){const m=u;y=bt("private key",y,m);const E=bt("hashed private key",o(y),2*m),L=S(E.slice(0,m)),N=E.slice(m,2*m),O=U(L),W=A.multiply(O),et=W.toRawBytes();return{head:L,prefix:N,scalar:O,point:W,pointBytes:et}}function ct(y){return F(y).pointBytes}function X(y=new Uint8Array,...m){const E=ze(...m);return U(o(I(E,bt("context",y),!!s)))}function J(y,m,E={}){y=bt("message",y),s&&(y=s(y));const{prefix:L,scalar:N,pointBytes:O}=F(m),W=X(E.context,L,y),et=A.multiply(W).toRawBytes(),Y=X(E.context,et,O,y),nt=K(W+Y*N);Ot("signature.s",nt,Vt,r);const at=ze(et,Ye(nt,e.BYTES));return bt("result",at,u*2)}const pt=gc;function mt(y,m,E,L=pt){const{context:N,zip215:O}=L,W=e.BYTES;y=bt("signature",y,2*W),m=bt("message",m),O!==void 0&&oe("zip215",O),s&&(m=s(m));const et=Ne(y.slice(W,2*W));let Y,nt,at;try{Y=B.fromHex(E,O),nt=B.fromHex(y.slice(0,W),O),at=A.multiplyUnsafe(et)}catch{return!1}if(!O&&Y.isSmallOrder())return!1;const ut=X(N,nt.toRawBytes(),Y.toRawBytes(),m);return nt.add(Y.multiplyUnsafe(ut)).subtract(at).clearCofactor().equals(B.ZERO)}return A._setWindowSize(8),{CURVE:t,getPublicKey:ct,sign:J,verify:mt,ExtendedPoint:B,utils:{getExtendedPublicKey:F,randomPrivateKey:()=>i(e.BYTES),precompute(y=8,m=B.BASE){return m._setWindowSize(y),m.multiply(BigInt(3)),m}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Qr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Es=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const yc=BigInt(1),Ts=BigInt(2);BigInt(3);const bc=BigInt(5),wc=BigInt(8);function xc(n){const t=BigInt(10),e=BigInt(20),r=BigInt(40),s=BigInt(80),o=Qr,u=n*n%o*n%o,c=ft(u,Ts,o)*u%o,l=ft(c,yc,o)*n%o,d=ft(l,bc,o)*l%o,f=ft(d,t,o)*d%o,S=ft(f,e,o)*f%o,I=ft(S,r,o)*S%o,w=ft(I,s,o)*I%o,h=ft(w,s,o)*I%o,p=ft(h,t,o)*d%o;return{pow_p_5_8:ft(p,Ts,o)*n%o,b2:u}}function Sc(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}function Ac(n,t){const e=Qr,r=it(t*t*t,e),s=it(r*r*t,e),o=xc(n*s).pow_p_5_8;let i=it(n*r*o,e);const u=it(t*i*i,e),c=i,l=it(i*Es,e),d=u===n,f=u===it(-n,e),S=u===it(-n*Es,e);return d&&(i=c),(f||S)&&(i=l),ic(i,e)&&(i=it(-i,e)),{isValid:d||f,value:i}}const kc=(()=>io(Qr,void 0,!0))(),Ic=(()=>({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:kc,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:wc,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Hi,randomBytes:to,adjustScalarBytes:Sc,uvRatio:Ac}))(),rn=(()=>mc(Ic))(),Bc=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ue=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),le=new Uint32Array(64);class vc extends eo{constructor(){super(64,32,8,!1),this.A=ue[0]|0,this.B=ue[1]|0,this.C=ue[2]|0,this.D=ue[3]|0,this.E=ue[4]|0,this.F=ue[5]|0,this.G=ue[6]|0,this.H=ue[7]|0}get(){const{A:t,B:e,C:r,D:s,E:o,F:i,G:u,H:c}=this;return[t,e,r,s,o,i,u,c]}set(t,e,r,s,o,i,u,c){this.A=t|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=u|0,this.H=c|0}process(t,e){for(let f=0;f<16;f++,e+=4)le[f]=t.getUint32(e,!1);for(let f=16;f<64;f++){const S=le[f-15],I=le[f-2],w=Yt(S,7)^Yt(S,18)^S>>>3,h=Yt(I,17)^Yt(I,19)^I>>>10;le[f]=h+le[f-7]+w+le[f-16]|0}let{A:r,B:s,C:o,D:i,E:u,F:c,G:l,H:d}=this;for(let f=0;f<64;f++){const S=Yt(u,6)^Yt(u,11)^Yt(u,25),I=d+S+yi(u,c,l)+Bc[f]+le[f]|0,h=(Yt(r,2)^Yt(r,13)^Yt(r,22))+bi(r,s,o)|0;d=l,l=c,c=u,u=i+I|0,i=o,o=s,s=r,r=I+h|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,u=u+this.E|0,c=c+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(r,s,o,i,u,c,l,d)}roundClean(){le.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Nr=Js(()=>new vc);class Ec extends TypeError{constructor(t,e){let r;const{message:s,explanation:o,...i}=t,{path:u}=t,c=u.length===0?s:`At path: ${u.join(".")} -- ${s}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>r??(r=[t,...e()])}}function Tc(n){return sn(n)&&typeof n[Symbol.iterator]=="function"}function sn(n){return typeof n=="object"&&n!=null}function Bn(n){return sn(n)&&!Array.isArray(n)}function Gt(n){return typeof n=="symbol"?n.toString():typeof n=="string"?JSON.stringify(n):`${n}`}function _c(n){const{done:t,value:e}=n.next();return t?void 0:e}function Lc(n,t,e,r){if(n===!0)return;n===!1?n={}:typeof n=="string"&&(n={message:n});const{path:s,branch:o}=t,{type:i}=e,{refinement:u,message:c=`Expected a value of type \`${i}\`${u?` with refinement \`${u}\``:""}, but received: \`${Gt(r)}\``}=n;return{value:r,type:i,refinement:u,key:s[s.length-1],path:s,branch:o,...n,message:c}}function*_s(n,t,e,r){Tc(n)||(n=[n]);for(const s of n){const o=Lc(s,t,e,r);o&&(yield o)}}function*Xr(n,t,e={}){const{path:r=[],branch:s=[n],coerce:o=!1,mask:i=!1}=e,u={path:r,branch:s,mask:i};o&&(n=t.coercer(n,u));let c="valid";for(const l of t.validator(n,u))l.explanation=e.message,c="not_valid",yield[l,void 0];for(let[l,d,f]of t.entries(n,u)){const S=Xr(d,f,{path:l===void 0?r:[...r,l],branch:l===void 0?s:[...s,d],coerce:o,mask:i,message:e.message});for(const I of S)I[0]?(c=I[0].refinement!=null?"not_refined":"not_valid",yield[I[0],void 0]):o&&(d=I[1],l===void 0?n=d:n instanceof Map?n.set(l,d):n instanceof Set?n.add(d):sn(n)&&(d!==void 0||l in n)&&(n[l]=d))}if(c!=="not_valid")for(const l of t.refiner(n,u))l.explanation=e.message,c="not_refined",yield[l,void 0];c==="valid"&&(yield[void 0,n])}class te{constructor(t){const{type:e,schema:r,validator:s,refiner:o,coercer:i=c=>c,entries:u=function*(){}}=t;this.type=e,this.schema=r,this.entries=u,this.coercer=i,s?this.validator=(c,l)=>{const d=s(c,l);return _s(d,l,this,c)}:this.validator=()=>[],o?this.refiner=(c,l)=>{const d=o(c,l);return _s(d,l,this,c)}:this.refiner=()=>[]}assert(t,e){return zc(t,this,e)}create(t,e){return Xe(t,this,e)}is(t){return lo(t,this)}mask(t,e){return Rc(t,this,e)}validate(t,e={}){return on(t,this,e)}}function zc(n,t,e){const r=on(n,t,{message:e});if(r[0])throw r[0]}function Xe(n,t,e){const r=on(n,t,{coerce:!0,message:e});if(r[0])throw r[0];return r[1]}function Rc(n,t,e){const r=on(n,t,{coerce:!0,mask:!0,message:e});if(r[0])throw r[0];return r[1]}function lo(n,t){return!on(n,t)[0]}function on(n,t,e={}){const r=Xr(n,t,e),s=_c(r);if(s[0])return[new Ec(s[0],function*(){for(const i of r)i[0]&&(yield i[0])}),void 0];{const o=s[1];return[void 0,o]}}function Re(n,t){return new te({type:n,schema:null,validator:t})}function Mc(){return Re("any",()=>!0)}function T(n){return new te({type:"array",schema:n,*entries(t){if(n&&Array.isArray(t))for(const[e,r]of t.entries())yield[e,r,n]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||`Expected an array value, but received: ${Gt(t)}`}})}function Jt(){return Re("boolean",n=>typeof n=="boolean")}function Jr(n){return Re("instance",t=>t instanceof n||`Expected a \`${n.name}\` instance, but received: ${Gt(t)}`)}function lt(n){const t=Gt(n),e=typeof n;return new te({type:"literal",schema:e==="string"||e==="number"||e==="boolean"?n:null,validator(r){return r===n||`Expected the literal \`${t}\`, but received: ${Gt(r)}`}})}function Cc(){return Re("never",()=>!1)}function _(n){return new te({...n,validator:(t,e)=>t===null||n.validator(t,e),refiner:(t,e)=>t===null||n.refiner(t,e)})}function g(){return Re("number",n=>typeof n=="number"&&!isNaN(n)||`Expected a number, but received: ${Gt(n)}`)}function q(n){return new te({...n,validator:(t,e)=>t===void 0||n.validator(t,e),refiner:(t,e)=>t===void 0||n.refiner(t,e)})}function fo(n,t){return new te({type:"record",schema:null,*entries(e){if(sn(e))for(const r in e){const s=e[r];yield[r,r,n],yield[r,s,t]}},validator(e){return Bn(e)||`Expected an object, but received: ${Gt(e)}`},coercer(e){return Bn(e)?{...e}:e}})}function v(){return Re("string",n=>typeof n=="string"||`Expected a string, but received: ${Gt(n)}`)}function ts(n){const t=Cc();return new te({type:"tuple",schema:null,*entries(e){if(Array.isArray(e)){const r=Math.max(n.length,e.length);for(let s=0;s<r;s++)yield[s,e[s],n[s]||t]}},validator(e){return Array.isArray(e)||`Expected an array, but received: ${Gt(e)}`},coercer(e){return Array.isArray(e)?e.slice():e}})}function x(n){const t=Object.keys(n);return new te({type:"type",schema:n,*entries(e){if(sn(e))for(const r of t)yield[r,e[r],n[r]]},validator(e){return Bn(e)||`Expected an object, but received: ${Gt(e)}`},coercer(e){return Bn(e)?{...e}:e}})}function _t(n){const t=n.map(e=>e.type).join(" | ");return new te({type:"union",schema:null,coercer(e,r){for(const s of n){const[o,i]=s.validate(e,{coerce:!0,mask:r.mask});if(!o)return i}return e},validator(e,r){const s=[];for(const o of n){const[...i]=Xr(e,o,r),[u]=i;if(u[0])for(const[c]of i)c&&s.push(c);else return[]}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${Gt(e)}`,...s]}})}function We(){return Re("unknown",()=>!0)}function cn(n,t,e){return new te({...n,coercer:(r,s)=>lo(r,t)?n.coercer(e(r,s),s):n.coercer(r,s)})}js.v4;js.v4;var Kc={exports:{}};(function(n){var t=Object.prototype.hasOwnProperty,e="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(e=!1));function s(c,l,d){this.fn=c,this.context=l,this.once=d||!1}function o(c,l,d,f,S){if(typeof d!="function")throw new TypeError("The listener must be a function");var I=new s(d,f||c,S),w=e?e+l:l;return c._events[w]?c._events[w].fn?c._events[w]=[c._events[w],I]:c._events[w].push(I):(c._events[w]=I,c._eventsCount++),c}function i(c,l){--c._eventsCount===0?c._events=new r:delete c._events[l]}function u(){this._events=new r,this._eventsCount=0}u.prototype.eventNames=function(){var l=[],d,f;if(this._eventsCount===0)return l;for(f in d=this._events)t.call(d,f)&&l.push(e?f.slice(1):f);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(d)):l},u.prototype.listeners=function(l){var d=e?e+l:l,f=this._events[d];if(!f)return[];if(f.fn)return[f.fn];for(var S=0,I=f.length,w=new Array(I);S<I;S++)w[S]=f[S].fn;return w},u.prototype.listenerCount=function(l){var d=e?e+l:l,f=this._events[d];return f?f.fn?1:f.length:0},u.prototype.emit=function(l,d,f,S,I,w){var h=e?e+l:l;if(!this._events[h])return!1;var p=this._events[h],k=arguments.length,B,A;if(p.fn){switch(p.once&&this.removeListener(l,p.fn,void 0,!0),k){case 1:return p.fn.call(p.context),!0;case 2:return p.fn.call(p.context,d),!0;case 3:return p.fn.call(p.context,d,f),!0;case 4:return p.fn.call(p.context,d,f,S),!0;case 5:return p.fn.call(p.context,d,f,S,I),!0;case 6:return p.fn.call(p.context,d,f,S,I,w),!0}for(A=1,B=new Array(k-1);A<k;A++)B[A-1]=arguments[A];p.fn.apply(p.context,B)}else{var H=p.length,C;for(A=0;A<H;A++)switch(p[A].once&&this.removeListener(l,p[A].fn,void 0,!0),k){case 1:p[A].fn.call(p[A].context);break;case 2:p[A].fn.call(p[A].context,d);break;case 3:p[A].fn.call(p[A].context,d,f);break;case 4:p[A].fn.call(p[A].context,d,f,S);break;default:if(!B)for(C=1,B=new Array(k-1);C<k;C++)B[C-1]=arguments[C];p[A].fn.apply(p[A].context,B)}}return!0},u.prototype.on=function(l,d,f){return o(this,l,d,f,!1)},u.prototype.once=function(l,d,f){return o(this,l,d,f,!0)},u.prototype.removeListener=function(l,d,f,S){var I=e?e+l:l;if(!this._events[I])return this;if(!d)return i(this,I),this;var w=this._events[I];if(w.fn)w.fn===d&&(!S||w.once)&&(!f||w.context===f)&&i(this,I);else{for(var h=0,p=[],k=w.length;h<k;h++)(w[h].fn!==d||S&&!w[h].once||f&&w[h].context!==f)&&p.push(w[h]);p.length?this._events[I]=p.length===1?p[0]:p:i(this,I)}return this},u.prototype.removeAllListeners=function(l){var d;return l?(d=e?e+l:l,this._events[d]&&i(this,d)):(this._events=new r,this._eventsCount=0),this},u.prototype.off=u.prototype.removeListener,u.prototype.addListener=u.prototype.on,u.prefixed=e,u.EventEmitter=u,n.exports=u})(Kc);class ho extends Xs{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,fi(t);const r=Vr(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?t.create().update(r).digest():r);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=t.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(t){return In(this),this.iHash.update(t),this}digestInto(t){In(this),Mn(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:o,blockLen:i,outputLen:u}=this;return t=t,t.finished=s,t.destroyed=o,t.blockLen=i,t.outputLen=u,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const go=(n,t,e)=>new ho(n,t).update(e).digest();go.create=(n,t)=>new ho(n,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ls(n){n.lowS!==void 0&&oe("lowS",n.lowS),n.prehash!==void 0&&oe("prehash",n.prehash)}function Pc(n){const t=Yr(n);He(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:s}=t;if(e){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:Fc,hexToBytes:Dc}=ec,ve={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(n){const{Err:t}=ve;if(n.length<2||n[0]!==2)throw new t("Invalid signature integer tag");const e=n[1],r=n.subarray(2,e+2);if(!e||r.length!==e)throw new t("Invalid signature integer: wrong length");if(r[0]&128)throw new t("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:Fc(r),l:n.subarray(e+2)}},toSig(n){const{Err:t}=ve,e=typeof n=="string"?Dc(n):n;nn(e);let r=e.length;if(r<2||e[0]!=48)throw new t("Invalid signature tag");if(e[1]!==r-2)throw new t("Invalid signature: incorrect length");const{d:s,l:o}=ve._parseInt(e.subarray(2)),{d:i,l:u}=ve._parseInt(o);if(u.length)throw new t("Invalid signature: left bytes after parsing");return{r:s,s:i}},hexFromSig(n){const t=l=>Number.parseInt(l[0],16)&8?"00"+l:l,e=l=>{const d=l.toString(16);return d.length&1?`0${d}`:d},r=t(e(n.s)),s=t(e(n.r)),o=r.length/2,i=s.length/2,u=e(o),c=e(i);return`30${e(i+o+4)}02${c}${s}02${u}${r}`}},de=BigInt(0),xt=BigInt(1);BigInt(2);const zs=BigInt(3);BigInt(4);function Nc(n){const t=Pc(n),{Fp:e}=t,r=t.toBytes||((w,h,p)=>{const k=h.toAffine();return ze(Uint8Array.from([4]),e.toBytes(k.x),e.toBytes(k.y))}),s=t.fromBytes||(w=>{const h=w.subarray(1),p=e.fromBytes(h.subarray(0,e.BYTES)),k=e.fromBytes(h.subarray(e.BYTES,2*e.BYTES));return{x:p,y:k}});function o(w){const{a:h,b:p}=t,k=e.sqr(w),B=e.mul(k,w);return e.add(e.add(B,e.mul(w,h)),p)}if(!e.eql(e.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function i(w){return Kn(w,xt,t.n)}function u(w){const{allowedPrivateKeyLengths:h,nByteLength:p,wrapPrivateKey:k,n:B}=t;if(h&&typeof w!="bigint"){if(_e(w)&&(w=Le(w)),typeof w!="string"||!h.includes(w.length))throw new Error("Invalid key");w=w.padStart(p*2,"0")}let A;try{A=typeof w=="bigint"?w:Ee(bt("private key",w,p))}catch{throw new Error(`private key must be ${p} bytes, hex or bigint, not ${typeof w}`)}return k&&(A=it(A,B)),Ot("private key",A,xt,B),A}function c(w){if(!(w instanceof f))throw new Error("ProjectivePoint expected")}const l=Qe((w,h)=>{const{px:p,py:k,pz:B}=w;if(e.eql(B,e.ONE))return{x:p,y:k};const A=w.is0();h==null&&(h=A?e.ONE:e.inv(B));const H=e.mul(p,h),C=e.mul(k,h),K=e.mul(B,h);if(A)return{x:e.ZERO,y:e.ZERO};if(!e.eql(K,e.ONE))throw new Error("invZ was invalid");return{x:H,y:C}}),d=Qe(w=>{if(w.is0()){if(t.allowInfinityPoint&&!e.is0(w.py))return;throw new Error("bad point: ZERO")}const{x:h,y:p}=w.toAffine();if(!e.isValid(h)||!e.isValid(p))throw new Error("bad point: x or y not FE");const k=e.sqr(p),B=o(h);if(!e.eql(k,B))throw new Error("bad point: equation left != right");if(!w.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class f{constructor(h,p,k){if(this.px=h,this.py=p,this.pz=k,h==null||!e.isValid(h))throw new Error("x required");if(p==null||!e.isValid(p))throw new Error("y required");if(k==null||!e.isValid(k))throw new Error("z required");Object.freeze(this)}static fromAffine(h){const{x:p,y:k}=h||{};if(!h||!e.isValid(p)||!e.isValid(k))throw new Error("invalid affine point");if(h instanceof f)throw new Error("projective point not allowed");const B=A=>e.eql(A,e.ZERO);return B(p)&&B(k)?f.ZERO:new f(p,k,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const p=e.invertBatch(h.map(k=>k.pz));return h.map((k,B)=>k.toAffine(p[B])).map(f.fromAffine)}static fromHex(h){const p=f.fromAffine(s(bt("pointHex",h)));return p.assertValidity(),p}static fromPrivateKey(h){return f.BASE.multiply(u(h))}_setWindowSize(h){I.setWindowSize(this,h)}assertValidity(){d(this)}hasEvenY(){const{y:h}=this.toAffine();if(e.isOdd)return!e.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){c(h);const{px:p,py:k,pz:B}=this,{px:A,py:H,pz:C}=h,K=e.eql(e.mul(p,C),e.mul(A,B)),U=e.eql(e.mul(k,C),e.mul(H,B));return K&&U}negate(){return new f(this.px,e.neg(this.py),this.pz)}double(){const{a:h,b:p}=t,k=e.mul(p,zs),{px:B,py:A,pz:H}=this;let C=e.ZERO,K=e.ZERO,U=e.ZERO,F=e.mul(B,B),ct=e.mul(A,A),X=e.mul(H,H),J=e.mul(B,A);return J=e.add(J,J),U=e.mul(B,H),U=e.add(U,U),C=e.mul(h,U),K=e.mul(k,X),K=e.add(C,K),C=e.sub(ct,K),K=e.add(ct,K),K=e.mul(C,K),C=e.mul(J,C),U=e.mul(k,U),X=e.mul(h,X),J=e.sub(F,X),J=e.mul(h,J),J=e.add(J,U),U=e.add(F,F),F=e.add(U,F),F=e.add(F,X),F=e.mul(F,J),K=e.add(K,F),X=e.mul(A,H),X=e.add(X,X),F=e.mul(X,J),C=e.sub(C,F),U=e.mul(X,ct),U=e.add(U,U),U=e.add(U,U),new f(C,K,U)}add(h){c(h);const{px:p,py:k,pz:B}=this,{px:A,py:H,pz:C}=h;let K=e.ZERO,U=e.ZERO,F=e.ZERO;const ct=t.a,X=e.mul(t.b,zs);let J=e.mul(p,A),pt=e.mul(k,H),mt=e.mul(B,C),z=e.add(p,k),y=e.add(A,H);z=e.mul(z,y),y=e.add(J,pt),z=e.sub(z,y),y=e.add(p,B);let m=e.add(A,C);return y=e.mul(y,m),m=e.add(J,mt),y=e.sub(y,m),m=e.add(k,B),K=e.add(H,C),m=e.mul(m,K),K=e.add(pt,mt),m=e.sub(m,K),F=e.mul(ct,y),K=e.mul(X,mt),F=e.add(K,F),K=e.sub(pt,F),F=e.add(pt,F),U=e.mul(K,F),pt=e.add(J,J),pt=e.add(pt,J),mt=e.mul(ct,mt),y=e.mul(X,y),pt=e.add(pt,mt),mt=e.sub(J,mt),mt=e.mul(ct,mt),y=e.add(y,mt),J=e.mul(pt,y),U=e.add(U,J),J=e.mul(m,y),K=e.mul(z,K),K=e.sub(K,J),J=e.mul(z,pt),F=e.mul(m,F),F=e.add(F,J),new f(K,U,F)}subtract(h){return this.add(h.negate())}is0(){return this.equals(f.ZERO)}wNAF(h){return I.wNAFCached(this,h,f.normalizeZ)}multiplyUnsafe(h){Ot("scalar",h,de,t.n);const p=f.ZERO;if(h===de)return p;if(h===xt)return this;const{endo:k}=t;if(!k)return I.unsafeLadder(this,h);let{k1neg:B,k1:A,k2neg:H,k2:C}=k.splitScalar(h),K=p,U=p,F=this;for(;A>de||C>de;)A&xt&&(K=K.add(F)),C&xt&&(U=U.add(F)),F=F.double(),A>>=xt,C>>=xt;return B&&(K=K.negate()),H&&(U=U.negate()),U=new f(e.mul(U.px,k.beta),U.py,U.pz),K.add(U)}multiply(h){const{endo:p,n:k}=t;Ot("scalar",h,xt,k);let B,A;if(p){const{k1neg:H,k1:C,k2neg:K,k2:U}=p.splitScalar(h);let{p:F,f:ct}=this.wNAF(C),{p:X,f:J}=this.wNAF(U);F=I.constTimeNegate(H,F),X=I.constTimeNegate(K,X),X=new f(e.mul(X.px,p.beta),X.py,X.pz),B=F.add(X),A=ct.add(J)}else{const{p:H,f:C}=this.wNAF(h);B=H,A=C}return f.normalizeZ([B,A])[0]}multiplyAndAddUnsafe(h,p,k){const B=f.BASE,A=(C,K)=>K===de||K===xt||!C.equals(B)?C.multiplyUnsafe(K):C.multiply(K),H=A(this,p).add(A(h,k));return H.is0()?void 0:H}toAffine(h){return l(this,h)}isTorsionFree(){const{h,isTorsionFree:p}=t;if(h===xt)return!0;if(p)return p(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:p}=t;return h===xt?this:p?p(f,this):this.multiplyUnsafe(t.h)}toRawBytes(h=!0){return oe("isCompressed",h),this.assertValidity(),r(f,this,h)}toHex(h=!0){return oe("isCompressed",h),Le(this.toRawBytes(h))}}f.BASE=new f(t.Gx,t.Gy,e.ONE),f.ZERO=new f(e.ZERO,e.ONE,e.ZERO);const S=t.nBitLength,I=uo(f,t.endo?Math.ceil(S/2):S);return{CURVE:t,ProjectivePoint:f,normPrivateKeyToScalar:u,weierstrassEquation:o,isWithinCurveOrder:i}}function qc(n){const t=Yr(n);return He(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function $c(n){const t=qc(n),{Fp:e,n:r}=t,s=e.BYTES+1,o=2*e.BYTES+1;function i(z){return it(z,r)}function u(z){return Dr(z,r)}const{ProjectivePoint:c,normPrivateKeyToScalar:l,weierstrassEquation:d,isWithinCurveOrder:f}=Nc({...t,toBytes(z,y,m){const E=y.toAffine(),L=e.toBytes(E.x),N=ze;return oe("isCompressed",m),m?N(Uint8Array.from([y.hasEvenY()?2:3]),L):N(Uint8Array.from([4]),L,e.toBytes(E.y))},fromBytes(z){const y=z.length,m=z[0],E=z.subarray(1);if(y===s&&(m===2||m===3)){const L=Ee(E);if(!Kn(L,xt,e.ORDER))throw new Error("Point is not on curve");const N=d(L);let O;try{O=e.sqrt(N)}catch(Y){const nt=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+nt)}const W=(O&xt)===xt;return(m&1)===1!==W&&(O=e.neg(O)),{x:L,y:O}}else if(y===o&&m===4){const L=e.fromBytes(E.subarray(0,e.BYTES)),N=e.fromBytes(E.subarray(e.BYTES,2*e.BYTES));return{x:L,y:N}}else throw new Error(`Point of length ${y} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),S=z=>Le(Ue(z,t.nByteLength));function I(z){const y=r>>xt;return z>y}function w(z){return I(z)?i(-z):z}const h=(z,y,m)=>Ee(z.slice(y,m));class p{constructor(y,m,E){this.r=y,this.s=m,this.recovery=E,this.assertValidity()}static fromCompact(y){const m=t.nByteLength;return y=bt("compactSignature",y,m*2),new p(h(y,0,m),h(y,m,2*m))}static fromDER(y){const{r:m,s:E}=ve.toSig(bt("DER",y));return new p(m,E)}assertValidity(){Ot("r",this.r,xt,r),Ot("s",this.s,xt,r)}addRecoveryBit(y){return new p(this.r,this.s,y)}recoverPublicKey(y){const{r:m,s:E,recovery:L}=this,N=K(bt("msgHash",y));if(L==null||![0,1,2,3].includes(L))throw new Error("recovery id invalid");const O=L===2||L===3?m+t.n:m;if(O>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const W=(L&1)===0?"02":"03",et=c.fromHex(W+S(O)),Y=u(O),nt=i(-N*Y),at=i(E*Y),ut=c.BASE.multiplyAndAddUnsafe(et,nt,at);if(!ut)throw new Error("point at infinify");return ut.assertValidity(),ut}hasHighS(){return I(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return $e(this.toDERHex())}toDERHex(){return ve.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return $e(this.toCompactHex())}toCompactHex(){return S(this.r)+S(this.s)}}const k={isValidPrivateKey(z){try{return l(z),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const z=ao(t.n);return dc(t.randomBytes(z),t.n)},precompute(z=8,y=c.BASE){return y._setWindowSize(z),y.multiply(BigInt(3)),y}};function B(z,y=!0){return c.fromPrivateKey(z).toRawBytes(y)}function A(z){const y=_e(z),m=typeof z=="string",E=(y||m)&&z.length;return y?E===s||E===o:m?E===2*s||E===2*o:z instanceof c}function H(z,y,m=!0){if(A(z))throw new Error("first arg must be private key");if(!A(y))throw new Error("second arg must be public key");return c.fromHex(y).multiply(l(z)).toRawBytes(m)}const C=t.bits2int||function(z){const y=Ee(z),m=z.length*8-t.nBitLength;return m>0?y>>BigInt(m):y},K=t.bits2int_modN||function(z){return i(C(z))},U=Zr(t.nBitLength);function F(z){return Ot(`num < 2^${t.nBitLength}`,z,de,U),Ue(z,t.nByteLength)}function ct(z,y,m=X){if(["recovered","canonical"].some(wt=>wt in m))throw new Error("sign() legacy options not supported");const{hash:E,randomBytes:L}=t;let{lowS:N,prehash:O,extraEntropy:W}=m;N==null&&(N=!0),z=bt("msgHash",z),Ls(m),O&&(z=bt("prehashed msgHash",E(z)));const et=K(z),Y=l(y),nt=[F(Y),F(et)];if(W!=null&&W!==!1){const wt=W===!0?L(e.BYTES):W;nt.push(bt("extraEntropy",wt))}const at=ze(...nt),ut=et;function Lt(wt){const yt=C(wt);if(!f(yt))return;const Wt=u(yt),zt=c.BASE.multiply(yt).toAffine(),It=i(zt.x);if(It===de)return;const ee=i(Wt*i(ut+It*Y));if(ee===de)return;let je=(zt.x===It?0:2)|Number(zt.y&xt),un=ee;return N&&I(ee)&&(un=w(ee),je^=1),new p(It,un,je)}return{seed:at,k2sig:Lt}}const X={lowS:t.lowS,prehash:!1},J={lowS:t.lowS,prehash:!1};function pt(z,y,m=X){const{seed:E,k2sig:L}=ct(z,y,m),N=t;return so(N.hash.outputLen,N.nByteLength,N.hmac)(E,L)}c.BASE._setWindowSize(8);function mt(z,y,m,E=J){var zt;const L=z;if(y=bt("msgHash",y),m=bt("publicKey",m),"strict"in E)throw new Error("options.strict was renamed to lowS");Ls(E);const{lowS:N,prehash:O}=E;let W,et;try{if(typeof L=="string"||_e(L))try{W=p.fromDER(L)}catch(It){if(!(It instanceof ve.Err))throw It;W=p.fromCompact(L)}else if(typeof L=="object"&&typeof L.r=="bigint"&&typeof L.s=="bigint"){const{r:It,s:ee}=L;W=new p(It,ee)}else throw new Error("PARSE");et=c.fromHex(m)}catch(It){if(It.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(N&&W.hasHighS())return!1;O&&(y=t.hash(y));const{r:Y,s:nt}=W,at=K(y),ut=u(nt),Lt=i(at*ut),wt=i(Y*ut),yt=(zt=c.BASE.multiplyAndAddUnsafe(et,Lt,wt))==null?void 0:zt.toAffine();return yt?i(yt.x)===Y:!1}return{CURVE:t,getPublicKey:B,getSharedSecret:H,sign:pt,verify:mt,ProjectivePoint:c,Signature:p,utils:k}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Uc(n){return{hash:n,hmac:(t,...e)=>go(n,t,pi(...e)),randomBytes:to}}function Oc(n,t){const e=r=>$c({...n,...Uc(r)});return Object.freeze({...e(t),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const po=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Rs=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Hc=BigInt(1),qr=BigInt(2),Ms=(n,t)=>(n+t/qr)/t;function Wc(n){const t=po,e=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),u=BigInt(44),c=BigInt(88),l=n*n*n%t,d=l*l*n%t,f=ft(d,e,t)*d%t,S=ft(f,e,t)*d%t,I=ft(S,qr,t)*l%t,w=ft(I,s,t)*I%t,h=ft(w,o,t)*w%t,p=ft(h,u,t)*h%t,k=ft(p,c,t)*p%t,B=ft(k,u,t)*h%t,A=ft(B,e,t)*d%t,H=ft(A,i,t)*w%t,C=ft(H,r,t)*l%t,K=ft(C,qr,t);if(!$r.eql($r.sqr(K),n))throw new Error("Cannot find square root");return K}const $r=io(po,void 0,void 0,{sqrt:Wc}),es=Oc({a:BigInt(0),b:BigInt(7),Fp:$r,n:Rs,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const t=Rs,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Hc*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,i=BigInt("0x100000000000000000000000000000000"),u=Ms(o*n,t),c=Ms(-r*n,t);let l=it(n-u*e-c*s,t),d=it(-u*r-c*o,t);const f=l>i,S=d>i;if(f&&(l=t-l),S&&(d=t-d),l>i||d>i)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:f,k1:l,k2neg:S,k2:d}}}},Nr);BigInt(0);es.ProjectivePoint;rn.utils.randomPrivateKey;rn.getPublicKey;function Cs(n){try{return rn.ExtendedPoint.fromHex(n),!0}catch{return!1}}const Vc=(n,t)=>rn.sign(n,t.slice(0,32)),jc=rn.verify,Mt=n=>V.Buffer.isBuffer(n)?n:n instanceof Uint8Array?V.Buffer.from(n.buffer,n.byteOffset,n.byteLength):V.Buffer.from(n);class Gc{constructor(t){Object.assign(this,t)}encode(){return V.Buffer.from(Vo(kn,this))}static decode(t){return jo(kn,this,t)}static decodeUnchecked(t){return Go(kn,this,t)}}const kn=new Map;var mo;const Zc=32,me=32;function Yc(n){return n._bn!==void 0}let Ks=1;class R extends Gc{constructor(t){if(super({}),this._bn=void 0,Yc(t))this._bn=t._bn;else{if(typeof t=="string"){const e=Tt.decode(t);if(e.length!=me)throw new Error("Invalid public key input");this._bn=new Kr(e)}else this._bn=new Kr(t);if(this._bn.byteLength()>me)throw new Error("Invalid public key input")}}static unique(){const t=new R(Ks);return Ks+=1,new R(t.toBuffer())}equals(t){return this._bn.eq(t._bn)}toBase58(){return Tt.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const t=this.toBuffer();return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}toBuffer(){const t=this._bn.toArrayLike(V.Buffer);if(t.length===me)return t;const e=V.Buffer.alloc(32);return t.copy(e,32-t.length),e}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(t,e,r){const s=V.Buffer.concat([t.toBuffer(),V.Buffer.from(e),r.toBuffer()]),o=Nr(s);return new R(o)}static createProgramAddressSync(t,e){let r=V.Buffer.alloc(0);t.forEach(function(o){if(o.length>Zc)throw new TypeError("Max seed length exceeded");r=V.Buffer.concat([r,Mt(o)])}),r=V.Buffer.concat([r,e.toBuffer(),V.Buffer.from("ProgramDerivedAddress")]);const s=Nr(r);if(Cs(s))throw new Error("Invalid seeds, address must fall off the curve");return new R(s)}static async createProgramAddress(t,e){return this.createProgramAddressSync(t,e)}static findProgramAddressSync(t,e){let r=255,s;for(;r!=0;){try{const o=t.concat(V.Buffer.from([r]));s=this.createProgramAddressSync(o,e)}catch(o){if(o instanceof TypeError)throw o;r--;continue}return[s,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(t,e){return this.findProgramAddressSync(t,e)}static isOnCurve(t){const e=new R(t);return Cs(e.toBytes())}}mo=R;R.default=new mo("11111111111111111111111111111111");kn.set(R,{kind:"struct",fields:[["_bn","u256"]]});new R("BPFLoader1111111111111111111111111111111111");const qe=1280-40-8,yo=127,bo=64;class Je{constructor(t,e){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=t,this.accountKeysFromLookups=e}keySegments(){const t=[this.staticAccountKeys];return this.accountKeysFromLookups&&(t.push(this.accountKeysFromLookups.writable),t.push(this.accountKeysFromLookups.readonly)),t}get(t){for(const e of this.keySegments()){if(t<e.length)return e[t];t-=e.length}}get length(){return this.keySegments().flat().length}compileInstructions(t){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((o,i)=>{r.set(o.toBase58(),i)});const s=o=>{const i=r.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return t.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const Q=(n="publicKey")=>gt(32,n),Fe=(n="string")=>{const t=M([D("length"),D("lengthPadding"),gt(De(D(),-8),"chars")],n),e=t.decode.bind(t),r=t.encode.bind(t),s=t;return s.decode=(o,i)=>e(o,i).chars.toString(),s.encode=(o,i,u)=>{const c={chars:V.Buffer.from(o,"utf8")};return r(c,i,u)},s.alloc=o=>D().span+D().span+V.Buffer.from(o,"utf8").length,s},Qc=(n="authorized")=>M([Q("staker"),Q("withdrawer")],n),Xc=(n="lockup")=>M([Nt("unixTimestamp"),Nt("epoch"),Q("custodian")],n),Jc=(n="voteInit")=>M([Q("nodePubkey"),Q("authorizedVoter"),Q("authorizedWithdrawer"),rt("commission")],n),ta=(n="voteAuthorizeWithSeedArgs")=>M([D("voteAuthorizationType"),Q("currentAuthorityDerivedKeyOwnerPubkey"),Fe("currentAuthorityDerivedKeySeed"),Q("newAuthorized")],n);function wo(n,t){const e=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(t[s.property]);if("count"in s&&"elementLayout"in s){const o=t[s.property];if(Array.isArray(o))return o.length*e(s.elementLayout)}else if("fields"in s)return wo({layout:s},t[s.property]);return 0};let r=0;return n.layout.fields.forEach(s=>{r+=e(s)}),r}function qt(n){let t=0,e=0;for(;;){let r=n.shift();if(t|=(r&127)<<e*7,e+=1,(r&128)===0)break}return t}function $t(n,t){let e=t;for(;;){let r=e&127;if(e>>=7,e==0){n.push(r);break}else r|=128,n.push(r)}}function vt(n,t){if(!n)throw new Error(t||"Assertion failed")}class Pn{constructor(t,e){this.payer=void 0,this.keyMetaMap=void 0,this.payer=t,this.keyMetaMap=e}static compile(t,e){const r=new Map,s=i=>{const u=i.toBase58();let c=r.get(u);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(u,c)),c},o=s(e);o.isSigner=!0,o.isWritable=!0;for(const i of t){s(i.programId).isInvoked=!0;for(const u of i.keys){const c=s(u.pubkey);c.isSigner||=u.isSigner,c.isWritable||=u.isWritable}}return new Pn(e,r)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];vt(t.length<=256,"Max static account keys length exceeded");const e=t.filter(([,c])=>c.isSigner&&c.isWritable),r=t.filter(([,c])=>c.isSigner&&!c.isWritable),s=t.filter(([,c])=>!c.isSigner&&c.isWritable),o=t.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:e.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{vt(e.length>0,"Expected at least one writable signer key");const[c]=e[0];vt(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const u=[...e.map(([c])=>new R(c)),...r.map(([c])=>new R(c)),...s.map(([c])=>new R(c)),...o.map(([c])=>new R(c))];return[i,u]}extractTableLookup(t){const[e,r]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(e.length===0&&s.length===0))return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:s},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(t,e){const r=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(e(i)){const u=new R(o),c=t.findIndex(l=>l.equals(u));c>=0&&(vt(c<256,"Max lookup table index exceeded"),r.push(c),s.push(u),this.keyMetaMap.delete(o))}return[r,s]}}const xo="Reached end of buffer unexpectedly";function re(n){if(n.length===0)throw new Error(xo);return n.shift()}function Ut(n,...t){const[e]=t;if(t.length===2?e+(t[1]??0)>n.length:e>=n.length)throw new Error(xo);return n.splice(...t)}class tn{constructor(t){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=t.header,this.accountKeys=t.accountKeys.map(e=>new R(e)),this.recentBlockhash=t.recentBlockhash,this.instructions=t.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:Tt.decode(t.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Je(this.staticAccountKeys)}static compile(t){const e=Pn.compile(t.instructions,t.payerKey),[r,s]=e.getMessageComponents(),i=new Je(s).compileInstructions(t.instructions).map(u=>({programIdIndex:u.programIdIndex,accounts:u.accountKeyIndexes,data:Tt.encode(u.data)}));return new tn({header:r,accountKeys:s,recentBlockhash:t.recentBlockhash,instructions:i})}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures;if(t>=this.header.numRequiredSignatures){const r=t-e,o=this.accountKeys.length-e-this.header.numReadonlyUnsignedAccounts;return r<o}else{const r=e-this.header.numReadonlySignedAccounts;return t<r}}isProgramId(t){return this.indexToProgramIds.has(t)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((t,e)=>!this.isProgramId(e))}serialize(){const t=this.accountKeys.length;let e=[];$t(e,t);const r=this.instructions.map(f=>{const{accounts:S,programIdIndex:I}=f,w=Array.from(Tt.decode(f.data));let h=[];$t(h,S.length);let p=[];return $t(p,w.length),{programIdIndex:I,keyIndicesCount:V.Buffer.from(h),keyIndices:S,dataLength:V.Buffer.from(p),data:w}});let s=[];$t(s,r.length);let o=V.Buffer.alloc(qe);V.Buffer.from(s).copy(o);let i=s.length;r.forEach(f=>{i+=M([rt("programIdIndex"),gt(f.keyIndicesCount.length,"keyIndicesCount"),Kt(rt("keyIndex"),f.keyIndices.length,"keyIndices"),gt(f.dataLength.length,"dataLength"),Kt(rt("userdatum"),f.data.length,"data")]).encode(f,o,i)}),o=o.slice(0,i);const u=M([gt(1,"numRequiredSignatures"),gt(1,"numReadonlySignedAccounts"),gt(1,"numReadonlyUnsignedAccounts"),gt(e.length,"keyCount"),Kt(Q("key"),t,"keys"),Q("recentBlockhash")]),c={numRequiredSignatures:V.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:V.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:V.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:V.Buffer.from(e),keys:this.accountKeys.map(f=>Mt(f.toBytes())),recentBlockhash:Tt.decode(this.recentBlockhash)};let l=V.Buffer.alloc(2048);const d=u.encode(c,l);return o.copy(l,d),l.slice(0,d+o.length)}static from(t){let e=[...t];const r=re(e);if(r!==(r&yo))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=re(e),o=re(e),i=qt(e);let u=[];for(let S=0;S<i;S++){const I=Ut(e,0,me);u.push(new R(V.Buffer.from(I)))}const c=Ut(e,0,me),l=qt(e);let d=[];for(let S=0;S<l;S++){const I=re(e),w=qt(e),h=Ut(e,0,w),p=qt(e),k=Ut(e,0,p),B=Tt.encode(V.Buffer.from(k));d.push({programIdIndex:I,accounts:h,data:B})}const f={header:{numRequiredSignatures:r,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:Tt.encode(V.Buffer.from(c)),accountKeys:u,instructions:d};return new tn(f)}}class vn{constructor(t){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=t.header,this.staticAccountKeys=t.staticAccountKeys,this.recentBlockhash=t.recentBlockhash,this.compiledInstructions=t.compiledInstructions,this.addressTableLookups=t.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let t=0;for(const e of this.addressTableLookups)t+=e.readonlyIndexes.length+e.writableIndexes.length;return t}getAccountKeys(t){let e;if(t&&"accountKeysFromLookups"in t&&t.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=t.accountKeysFromLookups.writable.length+t.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");e=t.accountKeysFromLookups}else if(t&&"addressLookupTableAccounts"in t&&t.addressLookupTableAccounts)e=this.resolveAddressTableLookups(t.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Je(this.staticAccountKeys,e)}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(t>=r){const s=t-r,o=this.addressTableLookups.reduce((i,u)=>i+u.writableIndexes.length,0);return s<o}else if(t>=this.header.numRequiredSignatures){const s=t-e,i=r-e-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=e-this.header.numReadonlySignedAccounts;return t<s}}resolveAddressTableLookups(t){const e={writable:[],readonly:[]};for(const r of this.addressTableLookups){const s=t.find(o=>o.key.equals(r.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const o of r.writableIndexes)if(o<s.state.addresses.length)e.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`);for(const o of r.readonlyIndexes)if(o<s.state.addresses.length)e.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`)}return e}static compile(t){const e=Pn.compile(t.instructions,t.payerKey),r=new Array,s={writable:new Array,readonly:new Array},o=t.addressLookupTableAccounts||[];for(const d of o){const f=e.extractTableLookup(d);if(f!==void 0){const[S,{writable:I,readonly:w}]=f;r.push(S),s.writable.push(...I),s.readonly.push(...w)}}const[i,u]=e.getMessageComponents(),l=new Je(u,s).compileInstructions(t.instructions);return new vn({header:i,staticAccountKeys:u,recentBlockhash:t.recentBlockhash,compiledInstructions:l,addressTableLookups:r})}serialize(){const t=Array();$t(t,this.staticAccountKeys.length);const e=this.serializeInstructions(),r=Array();$t(r,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();$t(o,this.addressTableLookups.length);const i=M([rt("prefix"),M([rt("numRequiredSignatures"),rt("numReadonlySignedAccounts"),rt("numReadonlyUnsignedAccounts")],"header"),gt(t.length,"staticAccountKeysLength"),Kt(Q(),this.staticAccountKeys.length,"staticAccountKeys"),Q("recentBlockhash"),gt(r.length,"instructionsLength"),gt(e.length,"serializedInstructions"),gt(o.length,"addressTableLookupsLength"),gt(s.length,"serializedAddressTableLookups")]),u=new Uint8Array(qe),c=1<<7,l=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(t),staticAccountKeys:this.staticAccountKeys.map(d=>d.toBytes()),recentBlockhash:Tt.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:e,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},u);return u.slice(0,l)}serializeInstructions(){let t=0;const e=new Uint8Array(qe);for(const r of this.compiledInstructions){const s=Array();$t(s,r.accountKeyIndexes.length);const o=Array();$t(o,r.data.length),t+=M([rt("programIdIndex"),gt(s.length,"encodedAccountKeyIndexesLength"),Kt(rt(),r.accountKeyIndexes.length,"accountKeyIndexes"),gt(o.length,"encodedDataLength"),gt(r.data.length,"data")]).encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:r.data},e,t)}return e.slice(0,t)}serializeAddressTableLookups(){let t=0;const e=new Uint8Array(qe);for(const r of this.addressTableLookups){const s=Array();$t(s,r.writableIndexes.length);const o=Array();$t(o,r.readonlyIndexes.length),t+=M([Q("accountKey"),gt(s.length,"encodedWritableIndexesLength"),Kt(rt(),r.writableIndexes.length,"writableIndexes"),gt(o.length,"encodedReadonlyIndexesLength"),Kt(rt(),r.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:r.readonlyIndexes},e,t)}return e.slice(0,t)}static deserialize(t){let e=[...t];const r=re(e),s=r&yo;vt(r!==s,"Expected versioned message but received legacy message");const o=s;vt(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:re(e),numReadonlySignedAccounts:re(e),numReadonlyUnsignedAccounts:re(e)},u=[],c=qt(e);for(let w=0;w<c;w++)u.push(new R(Ut(e,0,me)));const l=Tt.encode(Ut(e,0,me)),d=qt(e),f=[];for(let w=0;w<d;w++){const h=re(e),p=qt(e),k=Ut(e,0,p),B=qt(e),A=new Uint8Array(Ut(e,0,B));f.push({programIdIndex:h,accountKeyIndexes:k,data:A})}const S=qt(e),I=[];for(let w=0;w<S;w++){const h=new R(Ut(e,0,me)),p=qt(e),k=Ut(e,0,p),B=qt(e),A=Ut(e,0,B);I.push({accountKey:h,writableIndexes:k,readonlyIndexes:A})}return new vn({header:i,staticAccountKeys:u,recentBlockhash:l,compiledInstructions:f,addressTableLookups:I})}}const ea=V.Buffer.alloc(bo).fill(0);class Dt{constructor(t){this.keys=void 0,this.programId=void 0,this.data=V.Buffer.alloc(0),this.programId=t.programId,this.keys=t.keys,t.data&&(this.data=t.data)}toJSON(){return{keys:this.keys.map(({pubkey:t,isSigner:e,isWritable:r})=>({pubkey:t.toJSON(),isSigner:e,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class En{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(t){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!t)if(t.feePayer&&(this.feePayer=t.feePayer),t.signatures&&(this.signatures=t.signatures),Object.prototype.hasOwnProperty.call(t,"nonceInfo")){const{minContextSlot:e,nonceInfo:r}=t;this.minNonceContextSlot=e,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")){const{blockhash:e,lastValidBlockHeight:r}=t;this.recentBlockhash=e,this.lastValidBlockHeight=r}else{const{recentBlockhash:e,nonceInfo:r}=t;r&&(this.nonceInfo=r),this.recentBlockhash=e}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(t=>t.toJSON()),signers:this.signatures.map(({publicKey:t})=>t.toJSON())}}add(...t){if(t.length===0)throw new Error("No instructions");return t.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new Dt(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let t,e;if(this.nonceInfo?(t=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?e=[this.nonceInfo.nonceInstruction,...this.instructions]:e=this.instructions):(t=this.recentBlockhash,e=this.instructions),!t)throw new Error("Transaction recentBlockhash required");e.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let h=0;h<e.length;h++)if(e[h].programId===void 0)throw new Error(`Transaction instruction index ${h} has undefined program id`);const s=[],o=[];e.forEach(h=>{h.keys.forEach(k=>{o.push({...k})});const p=h.programId.toString();s.includes(p)||s.push(p)}),s.forEach(h=>{o.push({pubkey:new R(h),isSigner:!1,isWritable:!1})});const i=[];o.forEach(h=>{const p=h.pubkey.toString(),k=i.findIndex(B=>B.pubkey.toString()===p);k>-1?(i[k].isWritable=i[k].isWritable||h.isWritable,i[k].isSigner=i[k].isSigner||h.isSigner):i.push(h)}),i.sort(function(h,p){if(h.isSigner!==p.isSigner)return h.isSigner?-1:1;if(h.isWritable!==p.isWritable)return h.isWritable?-1:1;const k={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return h.pubkey.toBase58().localeCompare(p.pubkey.toBase58(),"en",k)});const u=i.findIndex(h=>h.pubkey.equals(r));if(u>-1){const[h]=i.splice(u,1);h.isSigner=!0,h.isWritable=!0,i.unshift(h)}else i.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const h of this.signatures){const p=i.findIndex(k=>k.pubkey.equals(h.publicKey));if(p>-1)i[p].isSigner||(i[p].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${h.publicKey.toString()}`)}let c=0,l=0,d=0;const f=[],S=[];i.forEach(({pubkey:h,isSigner:p,isWritable:k})=>{p?(f.push(h.toString()),c+=1,k||(l+=1)):(S.push(h.toString()),k||(d+=1))});const I=f.concat(S),w=e.map(h=>{const{data:p,programId:k}=h;return{programIdIndex:I.indexOf(k.toString()),accounts:h.keys.map(B=>I.indexOf(B.pubkey.toString())),data:Tt.encode(p)}});return w.forEach(h=>{vt(h.programIdIndex>=0),h.accounts.forEach(p=>vt(p>=0))}),new tn({header:{numRequiredSignatures:c,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:d},accountKeys:I,recentBlockhash:t,instructions:w})}_compile(){const t=this.compileMessage(),e=t.accountKeys.slice(0,t.header.numRequiredSignatures);return this.signatures.length===e.length&&this.signatures.every((s,o)=>e[o].equals(s.publicKey))||(this.signatures=e.map(r=>({signature:null,publicKey:r}))),t}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(t){return(await t.getFeeForMessage(this.compileMessage())).value}setSigners(...t){if(t.length===0)throw new Error("No signers");const e=new Set;this.signatures=t.filter(r=>{const s=r.toString();return e.has(s)?!1:(e.add(s),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const o of t){const i=o.publicKey.toString();e.has(i)||(e.add(i),r.push(o))}this.signatures=r.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...r)}partialSign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const o of t){const i=o.publicKey.toString();e.has(i)||(e.add(i),r.push(o))}const s=this._compile();this._partialSign(s,...r)}_partialSign(t,...e){const r=t.serialize();e.forEach(s=>{const o=Vc(r,s.secretKey);this._addSignature(s.publicKey,Mt(o))})}addSignature(t,e){this._compile(),this._addSignature(t,e)}_addSignature(t,e){vt(e.length===64);const r=this.signatures.findIndex(s=>t.equals(s.publicKey));if(r<0)throw new Error(`unknown signer: ${t.toString()}`);this.signatures[r].signature=V.Buffer.from(e)}verifySignatures(t=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),t)}_getMessageSignednessErrors(t,e){const r={};for(const{signature:s,publicKey:o}of this.signatures)s===null?e&&(r.missing||=[]).push(o):jc(s,t,o.toBytes())||(r.invalid||=[]).push(o);return r.invalid||r.missing?r:void 0}serialize(t){const{requireAllSignatures:e,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},t),s=this.serializeMessage();if(r){const o=this._getMessageSignednessErrors(s,e);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(u=>u.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(u=>u.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(s)}_serialize(t){const{signatures:e}=this,r=[];$t(r,e.length);const s=r.length+e.length*64+t.length,o=V.Buffer.alloc(s);return vt(e.length<256),V.Buffer.from(r).copy(o,0),e.forEach(({signature:i},u)=>{i!==null&&(vt(i.length===64,"signature has invalid length"),V.Buffer.from(i).copy(o,r.length+u*64))}),t.copy(o,r.length+e.length*64),vt(o.length<=qe,`Transaction too large: ${o.length} > ${qe}`),o}get keys(){return vt(this.instructions.length===1),this.instructions[0].keys.map(t=>t.pubkey)}get programId(){return vt(this.instructions.length===1),this.instructions[0].programId}get data(){return vt(this.instructions.length===1),this.instructions[0].data}static from(t){let e=[...t];const r=qt(e);let s=[];for(let o=0;o<r;o++){const i=Ut(e,0,bo);s.push(Tt.encode(V.Buffer.from(i)))}return En.populate(tn.from(e),s)}static populate(t,e=[]){const r=new En;return r.recentBlockhash=t.recentBlockhash,t.header.numRequiredSignatures>0&&(r.feePayer=t.accountKeys[0]),e.forEach((s,o)=>{const i={signature:s==Tt.encode(ea)?null:Tt.decode(s),publicKey:t.accountKeys[o]};r.signatures.push(i)}),t.instructions.forEach(s=>{const o=s.accounts.map(i=>{const u=t.accountKeys[i];return{pubkey:u,isSigner:r.signatures.some(c=>c.publicKey.toString()===u.toString())||t.isAccountSigner(i),isWritable:t.isAccountWritable(i)}});r.instructions.push(new Dt({keys:o,programId:t.accountKeys[s.programIdIndex],data:Tt.decode(s.data)}))}),r._message=t,r._json=r.toJSON(),r}}new R("SysvarC1ock11111111111111111111111111111111");new R("SysvarEpochSchedu1e111111111111111111111111");new R("Sysvar1nstructions1111111111111111111111111");const Mr=new R("SysvarRecentB1ockHashes11111111111111111111"),Ps=new R("SysvarRent111111111111111111111111111111111");new R("SysvarRewards111111111111111111111111111111");new R("SysvarS1otHashes111111111111111111111111111");new R("SysvarS1otHistory11111111111111111111111111");new R("SysvarStakeHistory1111111111111111111111111");function Pt(n,t){const e=n.layout.span>=0?n.layout.span:wo(n,t),r=V.Buffer.alloc(e),s=Object.assign({instruction:n.index},t);return n.layout.encode(s,r),r}const na=Bt("lamportsPerSignature"),ra=M([D("version"),D("state"),Q("authorizedPubkey"),Q("nonce"),M([na],"feeCalculator")]),Fs=ra.span,sa=n=>{const t=n.decode.bind(n),e=n.encode.bind(n);return{decode:t,encode:e}},oa=n=>t=>{const e=gt(n,t),{encode:r,decode:s}=sa(e),o=e;return o.decode=(i,u)=>{const c=s(i,u);return Zo(V.Buffer.from(c))},o.encode=(i,u,c)=>{const l=Yo(i,n);return r(l,u,c)},o},Oe=oa(8),Ft=Object.freeze({Create:{index:0,layout:M([D("instruction"),Nt("lamports"),Nt("space"),Q("programId")])},Assign:{index:1,layout:M([D("instruction"),Q("programId")])},Transfer:{index:2,layout:M([D("instruction"),Oe("lamports")])},CreateWithSeed:{index:3,layout:M([D("instruction"),Q("base"),Fe("seed"),Nt("lamports"),Nt("space"),Q("programId")])},AdvanceNonceAccount:{index:4,layout:M([D("instruction")])},WithdrawNonceAccount:{index:5,layout:M([D("instruction"),Nt("lamports")])},InitializeNonceAccount:{index:6,layout:M([D("instruction"),Q("authorized")])},AuthorizeNonceAccount:{index:7,layout:M([D("instruction"),Q("authorized")])},Allocate:{index:8,layout:M([D("instruction"),Nt("space")])},AllocateWithSeed:{index:9,layout:M([D("instruction"),Q("base"),Fe("seed"),Nt("space"),Q("programId")])},AssignWithSeed:{index:10,layout:M([D("instruction"),Q("base"),Fe("seed"),Q("programId")])},TransferWithSeed:{index:11,layout:M([D("instruction"),Oe("lamports"),Fe("seed"),Q("programId")])},UpgradeNonceAccount:{index:12,layout:M([D("instruction")])}});class en{constructor(){}static createAccount(t){const e=Ft.Create,r=Pt(e,{lamports:t.lamports,space:t.space,programId:Mt(t.programId.toBuffer())});return new Dt({keys:[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(t){let e,r;if("basePubkey"in t){const s=Ft.TransferWithSeed;e=Pt(s,{lamports:BigInt(t.lamports),seed:t.seed,programId:Mt(t.programId.toBuffer())}),r=[{pubkey:t.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=Ft.Transfer;e=Pt(s,{lamports:BigInt(t.lamports)}),r=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}return new Dt({keys:r,programId:this.programId,data:e})}static assign(t){let e,r;if("basePubkey"in t){const s=Ft.AssignWithSeed;e=Pt(s,{base:Mt(t.basePubkey.toBuffer()),seed:t.seed,programId:Mt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Ft.Assign;e=Pt(s,{programId:Mt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new Dt({keys:r,programId:this.programId,data:e})}static createAccountWithSeed(t){const e=Ft.CreateWithSeed,r=Pt(e,{base:Mt(t.basePubkey.toBuffer()),seed:t.seed,lamports:t.lamports,space:t.space,programId:Mt(t.programId.toBuffer())});let s=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!1,isWritable:!0}];return t.basePubkey.equals(t.fromPubkey)||s.push({pubkey:t.basePubkey,isSigner:!0,isWritable:!1}),new Dt({keys:s,programId:this.programId,data:r})}static createNonceAccount(t){const e=new En;"basePubkey"in t&&"seed"in t?e.add(en.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:Fs,programId:this.programId})):e.add(en.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,lamports:t.lamports,space:Fs,programId:this.programId}));const r={noncePubkey:t.noncePubkey,authorizedPubkey:t.authorizedPubkey};return e.add(this.nonceInitialize(r)),e}static nonceInitialize(t){const e=Ft.InitializeNonceAccount,r=Pt(e,{authorized:Mt(t.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Mr,isSigner:!1,isWritable:!1},{pubkey:Ps,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new Dt(s)}static nonceAdvance(t){const e=Ft.AdvanceNonceAccount,r=Pt(e),s={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Mr,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new Dt(s)}static nonceWithdraw(t){const e=Ft.WithdrawNonceAccount,r=Pt(e,{lamports:t.lamports});return new Dt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Mr,isSigner:!1,isWritable:!1},{pubkey:Ps,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(t){const e=Ft.AuthorizeNonceAccount,r=Pt(e,{authorized:Mt(t.newAuthorizedPubkey.toBuffer())});return new Dt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(t){let e,r;if("basePubkey"in t){const s=Ft.AllocateWithSeed;e=Pt(s,{base:Mt(t.basePubkey.toBuffer()),seed:t.seed,space:t.space,programId:Mt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Ft.Allocate;e=Pt(s,{space:t.space}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new Dt({keys:r,programId:this.programId,data:e})}}en.programId=new R("11111111111111111111111111111111");new R("BPFLoader2111111111111111111111111111111111");M([D("typeIndex"),Oe("deactivationSlot"),Bt("lastExtendedSlot"),rt("lastExtendedStartIndex"),rt(),Kt(Q(),De(rt(),-1),"authority")]);const ht=cn(Jr(R),v(),n=>new R(n)),So=ts([v(),lt("base64")]),ns=cn(Jr(V.Buffer),So,n=>V.Buffer.from(n[0],"base64"));function Ao(n){return _t([x({jsonrpc:lt("2.0"),id:v(),result:n}),x({jsonrpc:lt("2.0"),id:v(),error:x({code:We(),message:v(),data:q(Mc())})})])}const ia=Ao(We());function ot(n){return cn(Ao(n),ia,t=>"error"in t?t:{...t,result:Xe(t.result,n)})}function Ht(n){return ot(x({context:x({slot:g()}),value:n}))}function Fn(n){return x({context:x({slot:g()}),value:n})}const ca=x({foundation:g(),foundationTerm:g(),initial:g(),taper:g(),terminal:g()});ot(T(_(x({epoch:g(),effectiveSlot:g(),amount:g(),postBalance:g(),commission:q(_(g()))}))));const aa=T(x({slot:g(),prioritizationFee:g()})),ua=x({total:g(),validator:g(),foundation:g(),epoch:g()}),la=x({epoch:g(),slotIndex:g(),slotsInEpoch:g(),absoluteSlot:g(),blockHeight:q(g()),transactionCount:q(g())}),da=x({slotsPerEpoch:g(),leaderScheduleSlotOffset:g(),warmup:Jt(),firstNormalEpoch:g(),firstNormalSlot:g()}),fa=fo(v(),T(g())),Me=_(_t([x({}),v()])),ha=x({err:Me}),ga=lt("receivedSignature");x({"solana-core":v(),"feature-set":q(g())});const pa=x({program:v(),programId:ht,parsed:We()}),ma=x({programId:ht,accounts:T(ht),data:v()});Ht(x({err:_(_t([x({}),v()])),logs:_(T(v())),accounts:q(_(T(_(x({executable:Jt(),owner:v(),lamports:g(),data:T(v()),rentEpoch:q(g())}))))),unitsConsumed:q(g()),returnData:q(_(x({programId:v(),data:ts([v(),lt("base64")])}))),innerInstructions:q(_(T(x({index:g(),instructions:T(_t([pa,ma]))}))))}));Ht(x({byIdentity:fo(v(),T(g())),range:x({firstSlot:g(),lastSlot:g()})}));ot(ca);ot(ua);ot(aa);ot(la);ot(da);ot(fa);ot(g());Ht(x({total:g(),circulating:g(),nonCirculating:g(),nonCirculatingAccounts:T(ht)}));const ya=x({amount:v(),uiAmount:_(g()),decimals:g(),uiAmountString:q(v())});Ht(T(x({address:ht,amount:v(),uiAmount:_(g()),decimals:g(),uiAmountString:q(v())})));Ht(T(x({pubkey:ht,account:x({executable:Jt(),owner:ht,lamports:g(),data:ns,rentEpoch:g()})})));const Ur=x({program:v(),parsed:We(),space:g()});Ht(T(x({pubkey:ht,account:x({executable:Jt(),owner:ht,lamports:g(),data:Ur,rentEpoch:g()})})));Ht(T(x({lamports:g(),address:ht})));const rs=x({executable:Jt(),owner:ht,lamports:g(),data:ns,rentEpoch:g()});x({pubkey:ht,account:rs});const ba=cn(_t([Jr(V.Buffer),Ur]),_t([So,Ur]),n=>Array.isArray(n)?Xe(n,ns):n),wa=x({executable:Jt(),owner:ht,lamports:g(),data:ba,rentEpoch:g()});x({pubkey:ht,account:wa});x({state:_t([lt("active"),lt("inactive"),lt("activating"),lt("deactivating")]),active:g(),inactive:g()});ot(T(x({signature:v(),slot:g(),err:Me,memo:_(v()),blockTime:q(_(g()))})));ot(T(x({signature:v(),slot:g(),err:Me,memo:_(v()),blockTime:q(_(g()))})));x({subscription:g(),result:Fn(rs)});const xa=x({pubkey:ht,account:rs});x({subscription:g(),result:Fn(xa)});const Sa=x({parent:g(),slot:g(),root:g()});x({subscription:g(),result:Sa});const Aa=_t([x({type:_t([lt("firstShredReceived"),lt("completed"),lt("optimisticConfirmation"),lt("root")]),slot:g(),timestamp:g()}),x({type:lt("createdBank"),parent:g(),slot:g(),timestamp:g()}),x({type:lt("frozen"),slot:g(),timestamp:g(),stats:x({numTransactionEntries:g(),numSuccessfulTransactions:g(),numFailedTransactions:g(),maxTransactionsPerEntry:g()})}),x({type:lt("dead"),slot:g(),timestamp:g(),err:v()})]);x({subscription:g(),result:Aa});x({subscription:g(),result:Fn(_t([ha,ga]))});x({subscription:g(),result:g()});x({pubkey:v(),gossip:_(v()),tpu:_(v()),rpc:_(v()),version:_(v())});const Ds=x({votePubkey:v(),nodePubkey:v(),activatedStake:g(),epochVoteAccount:Jt(),epochCredits:T(ts([g(),g(),g()])),commission:g(),lastVote:g(),rootSlot:_(g())});ot(x({current:T(Ds),delinquent:T(Ds)}));const ka=_t([lt("processed"),lt("confirmed"),lt("finalized")]),Ia=x({slot:g(),confirmations:_(g()),err:Me,confirmationStatus:q(ka)});Ht(T(_(Ia)));ot(g());const ko=x({accountKey:ht,writableIndexes:T(g()),readonlyIndexes:T(g())}),ss=x({signatures:T(v()),message:x({accountKeys:T(v()),header:x({numRequiredSignatures:g(),numReadonlySignedAccounts:g(),numReadonlyUnsignedAccounts:g()}),instructions:T(x({accounts:T(g()),data:v(),programIdIndex:g()})),recentBlockhash:v(),addressTableLookups:q(T(ko))})}),Io=x({pubkey:ht,signer:Jt(),writable:Jt(),source:q(_t([lt("transaction"),lt("lookupTable")]))}),Bo=x({accountKeys:T(Io),signatures:T(v())}),vo=x({parsed:We(),program:v(),programId:ht}),Eo=x({accounts:T(ht),data:v(),programId:ht}),Ba=_t([Eo,vo]),va=_t([x({parsed:We(),program:v(),programId:v()}),x({accounts:T(v()),data:v(),programId:v()})]),To=cn(Ba,va,n=>"accounts"in n?Xe(n,Eo):Xe(n,vo)),_o=x({signatures:T(v()),message:x({accountKeys:T(Io),instructions:T(To),recentBlockhash:v(),addressTableLookups:q(_(T(ko)))})}),Tn=x({accountIndex:g(),mint:v(),owner:q(v()),uiTokenAmount:ya}),Lo=x({writable:T(ht),readonly:T(ht)}),Dn=x({err:Me,fee:g(),innerInstructions:q(_(T(x({index:g(),instructions:T(x({accounts:T(g()),data:v(),programIdIndex:g()}))})))),preBalances:T(g()),postBalances:T(g()),logMessages:q(_(T(v()))),preTokenBalances:q(_(T(Tn))),postTokenBalances:q(_(T(Tn))),loadedAddresses:q(Lo),computeUnitsConsumed:q(g())}),os=x({err:Me,fee:g(),innerInstructions:q(_(T(x({index:g(),instructions:T(To)})))),preBalances:T(g()),postBalances:T(g()),logMessages:q(_(T(v()))),preTokenBalances:q(_(T(Tn))),postTokenBalances:q(_(T(Tn))),loadedAddresses:q(Lo),computeUnitsConsumed:q(g())}),Ve=_t([lt(0),lt("legacy")]),Ce=x({pubkey:v(),lamports:g(),postBalance:_(g()),rewardType:_(v()),commission:q(_(g()))});ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:ss,meta:_(Dn),version:q(Ve)})),rewards:q(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),rewards:q(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:Bo,meta:_(Dn),version:q(Ve)})),rewards:q(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:_o,meta:_(os),version:q(Ve)})),rewards:q(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:Bo,meta:_(os),version:q(Ve)})),rewards:q(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),rewards:q(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:ss,meta:_(Dn)})),rewards:q(T(Ce)),blockTime:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),signatures:T(v()),blockTime:_(g())})));ot(_(x({slot:g(),meta:_(Dn),blockTime:q(_(g())),transaction:ss,version:q(Ve)})));ot(_(x({slot:g(),transaction:_o,meta:_(os),blockTime:q(_(g())),version:q(Ve)})));Ht(x({blockhash:v(),feeCalculator:x({lamportsPerSignature:g()})}));Ht(x({blockhash:v(),lastValidBlockHeight:g()}));Ht(Jt());const Ea=x({slot:g(),numTransactions:g(),numSlots:g(),samplePeriodSecs:g()});ot(T(Ea));Ht(_(x({feeCalculator:x({lamportsPerSignature:g()})})));ot(v());ot(v());const Ta=x({err:Me,logs:T(v()),signature:v()});x({result:Fn(Ta),subscription:g()});Object.freeze({CreateLookupTable:{index:0,layout:M([D("instruction"),Oe("recentSlot"),rt("bumpSeed")])},FreezeLookupTable:{index:1,layout:M([D("instruction")])},ExtendLookupTable:{index:2,layout:M([D("instruction"),Oe(),Kt(Q(),De(D(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:M([D("instruction")])},CloseLookupTable:{index:4,layout:M([D("instruction")])}});new R("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:M([rt("instruction"),D("units"),D("additionalFee")])},RequestHeapFrame:{index:1,layout:M([rt("instruction"),D("bytes")])},SetComputeUnitLimit:{index:2,layout:M([rt("instruction"),D("units")])},SetComputeUnitPrice:{index:3,layout:M([rt("instruction"),Oe("microLamports")])}});new R("ComputeBudget111111111111111111111111111111");M([rt("numSignatures"),rt("padding"),jt("signatureOffset"),jt("signatureInstructionIndex"),jt("publicKeyOffset"),jt("publicKeyInstructionIndex"),jt("messageDataOffset"),jt("messageDataSize"),jt("messageInstructionIndex")]);new R("Ed25519SigVerify111111111111111111111111111");es.utils.isValidPrivateKey;es.getPublicKey;M([rt("numSignatures"),jt("signatureOffset"),rt("signatureInstructionIndex"),jt("ethAddressOffset"),rt("ethAddressInstructionIndex"),jt("messageDataOffset"),jt("messageDataSize"),rt("messageInstructionIndex"),gt(20,"ethAddress"),gt(64,"signature"),rt("recoveryId")]);new R("KeccakSecp256k11111111111111111111111111111");var zo;new R("StakeConfig11111111111111111111111111111111");class Ro{constructor(t,e,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=t,this.epoch=e,this.custodian=r}}zo=Ro;Ro.default=new zo(0,0,R.default);Object.freeze({Initialize:{index:0,layout:M([D("instruction"),Qc(),Xc()])},Authorize:{index:1,layout:M([D("instruction"),Q("newAuthorized"),D("stakeAuthorizationType")])},Delegate:{index:2,layout:M([D("instruction")])},Split:{index:3,layout:M([D("instruction"),Nt("lamports")])},Withdraw:{index:4,layout:M([D("instruction"),Nt("lamports")])},Deactivate:{index:5,layout:M([D("instruction")])},Merge:{index:7,layout:M([D("instruction")])},AuthorizeWithSeed:{index:8,layout:M([D("instruction"),Q("newAuthorized"),D("stakeAuthorizationType"),Fe("authoritySeed"),Q("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});new R("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:M([D("instruction"),Jc()])},Authorize:{index:1,layout:M([D("instruction"),Q("newAuthorized"),D("voteAuthorizationType")])},Withdraw:{index:3,layout:M([D("instruction"),Nt("lamports")])},UpdateValidatorIdentity:{index:4,layout:M([D("instruction")])},AuthorizeWithSeed:{index:10,layout:M([D("instruction"),ta()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});new R("Vote111111111111111111111111111111111111111");new R("Va1idator1nfo111111111111111111111111111111");x({name:v(),website:q(v()),details:q(v()),iconUrl:q(v()),keybaseUsername:q(v())});new R("Vote111111111111111111111111111111111111111");M([Q("nodePubkey"),Q("authorizedWithdrawer"),rt("commission"),Bt(),Kt(M([Bt("slot"),D("confirmationCount")]),De(D(),-8),"votes"),rt("rootSlotValid"),Bt("rootSlot"),Bt(),Kt(M([Bt("epoch"),Q("authorizedVoter")]),De(D(),-8),"authorizedVoters"),M([Kt(M([Q("authorizedPubkey"),Bt("epochOfLastAuthorizedSwitch"),Bt("targetEpoch")]),32,"buf"),Bt("idx"),rt("isEmpty")],"priorVoters"),Bt(),Kt(M([Bt("epoch"),Bt("credits"),Bt("prevCredits")]),De(D(),-8),"epochCredits"),M([Bt("slot"),Bt("timestamp")],"lastTimestamp")]);const _a=[156,194,70,44,22,88,137,44];class we{multisig;creator;index;bump;vaultIndex;vaultBump;size;executedTransactionIndex;constructor(t,e,r,s,o,i,u,c){this.multisig=t,this.creator=e,this.index=r,this.bump=s,this.vaultIndex=o,this.vaultBump=i,this.size=u,this.executedTransactionIndex=c}static fromArgs(t){return new we(t.multisig,t.creator,t.index,t.bump,t.vaultIndex,t.vaultBump,t.size,t.executedTransactionIndex)}static fromAccountInfo(t,e=0){return we.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find Batch account at ${e}`);return we.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,gn)}static deserialize(t,e=0){return gn.deserialize(t,e)}serialize(){return gn.serialize({accountDiscriminator:_a,...this})}static get byteSize(){return gn.byteSize}static async getMinimumBalanceForRentExemption(t,e){return t.getMinimumBalanceForRentExemption(we.byteSize,e)}static hasCorrectByteSize(t,e=0){return t.byteLength-e===we.byteSize}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const t=this.index;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,vaultIndex:this.vaultIndex,vaultBump:this.vaultBump,size:this.size,executedTransactionIndex:this.executedTransactionIndex}}}const gn=new a.BeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["multisig",P.publicKey],["creator",P.publicKey],["index",a.u64],["bump",a.u8],["vaultIndex",a.u8],["vaultBump",a.u8],["size",a.u32],["executedTransactionIndex",a.u32]],we.fromArgs,"Batch"),La=new a.BeetArgsStruct([["mask",a.u8]],"Permissions"),an=new a.BeetArgsStruct([["key",P.publicKey],["permissions",La]],"Member");var _n;(function(n){n[n.OneTime=0]="OneTime",n[n.Day=1]="Day",n[n.Week=2]="Week",n[n.Month=3]="Month"})(_n||(_n={}));const is=a.fixedScalarEnum(_n),Mo=a.dataEnum([["AddMember",new a.BeetArgsStruct([["newMember",an]],'ConfigActionRecord["AddMember"]')],["RemoveMember",new a.BeetArgsStruct([["oldMember",P.publicKey]],'ConfigActionRecord["RemoveMember"]')],["ChangeThreshold",new a.BeetArgsStruct([["newThreshold",a.u16]],'ConfigActionRecord["ChangeThreshold"]')],["SetTimeLock",new a.BeetArgsStruct([["newTimeLock",a.u32]],'ConfigActionRecord["SetTimeLock"]')],["AddSpendingLimit",new a.FixableBeetArgsStruct([["createKey",P.publicKey],["vaultIndex",a.u8],["mint",P.publicKey],["amount",a.u64],["period",is],["members",a.array(P.publicKey)],["destinations",a.array(P.publicKey)]],'ConfigActionRecord["AddSpendingLimit"]')],["RemoveSpendingLimit",new a.BeetArgsStruct([["spendingLimit",P.publicKey]],'ConfigActionRecord["RemoveSpendingLimit"]')],["SetRentCollector",new a.FixableBeetArgsStruct([["newRentCollector",a.coption(P.publicKey)]],'ConfigActionRecord["SetRentCollector"]')]]),Ns=[94,8,4,35,113,139,139,112];class xe{multisig;creator;index;bump;actions;constructor(t,e,r,s,o){this.multisig=t,this.creator=e,this.index=r,this.bump=s,this.actions=o}static fromArgs(t){return new xe(t.multisig,t.creator,t.index,t.bump,t.actions)}static fromAccountInfo(t,e=0){return xe.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find ConfigTransaction account at ${e}`);return xe.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,pn)}static deserialize(t,e=0){return pn.deserialize(t,e)}serialize(){return pn.serialize({accountDiscriminator:Ns,...this})}static byteSize(t){const e=xe.fromArgs(t);return pn.toFixedFromValue({accountDiscriminator:Ns,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(xe.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const t=this.index;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,actions:this.actions}}}const pn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["multisig",P.publicKey],["creator",P.publicKey],["index",a.u64],["bump",a.u8],["actions",a.array(Mo)]],xe.fromArgs,"ConfigTransaction"),qs=[224,116,121,186,68,161,79,236];class fe{createKey;configAuthority;threshold;timeLock;transactionIndex;staleTransactionIndex;rentCollector;bump;members;constructor(t,e,r,s,o,i,u,c,l){this.createKey=t,this.configAuthority=e,this.threshold=r,this.timeLock=s,this.transactionIndex=o,this.staleTransactionIndex=i,this.rentCollector=u,this.bump=c,this.members=l}static fromArgs(t){return new fe(t.createKey,t.configAuthority,t.threshold,t.timeLock,t.transactionIndex,t.staleTransactionIndex,t.rentCollector,t.bump,t.members)}static fromAccountInfo(t,e=0){return fe.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find Multisig account at ${e}`);return fe.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,mn)}static deserialize(t,e=0){return mn.deserialize(t,e)}serialize(){return mn.serialize({accountDiscriminator:qs,...this})}static byteSize(t){const e=fe.fromArgs(t);return mn.toFixedFromValue({accountDiscriminator:qs,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(fe.byteSize(t),r)}pretty(){return{createKey:this.createKey.toBase58(),configAuthority:this.configAuthority.toBase58(),threshold:this.threshold,timeLock:this.timeLock,transactionIndex:(()=>{const t=this.transactionIndex;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),staleTransactionIndex:(()=>{const t=this.staleTransactionIndex;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),rentCollector:this.rentCollector,bump:this.bump,members:this.members}}}const mn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["createKey",P.publicKey],["configAuthority",P.publicKey],["threshold",a.u16],["timeLock",a.u32],["transactionIndex",a.u64],["staleTransactionIndex",a.u64],["rentCollector",a.coption(P.publicKey)],["bump",a.u8],["members",a.array(an)]],fe.fromArgs,"Multisig"),za=[196,210,90,231,144,149,140,63];class Se{authority;multisigCreationFee;treasury;reserved;constructor(t,e,r,s){this.authority=t,this.multisigCreationFee=e,this.treasury=r,this.reserved=s}static fromArgs(t){return new Se(t.authority,t.multisigCreationFee,t.treasury,t.reserved)}static fromAccountInfo(t,e=0){return Se.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find ProgramConfig account at ${e}`);return Se.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,yn)}static deserialize(t,e=0){return yn.deserialize(t,e)}serialize(){return yn.serialize({accountDiscriminator:za,...this})}static get byteSize(){return yn.byteSize}static async getMinimumBalanceForRentExemption(t,e){return t.getMinimumBalanceForRentExemption(Se.byteSize,e)}static hasCorrectByteSize(t,e=0){return t.byteLength-e===Se.byteSize}pretty(){return{authority:this.authority.toBase58(),multisigCreationFee:(()=>{const t=this.multisigCreationFee;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),treasury:this.treasury.toBase58(),reserved:this.reserved}}}const yn=new a.BeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["authority",P.publicKey],["multisigCreationFee",a.u64],["treasury",P.publicKey],["reserved",a.uniformFixedSizeArray(a.u8,64)]],Se.fromArgs,"ProgramConfig"),Ra=a.dataEnum([["Draft",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Draft"]')],["Active",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Active"]')],["Rejected",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Rejected"]')],["Approved",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Approved"]')],["Executing",a.unit],["Executed",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Executed"]')],["Cancelled",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Cancelled"]')]]),$s=[26,94,189,187,116,136,53,33];class Ae{multisig;transactionIndex;status;bump;approved;rejected;cancelled;constructor(t,e,r,s,o,i,u){this.multisig=t,this.transactionIndex=e,this.status=r,this.bump=s,this.approved=o,this.rejected=i,this.cancelled=u}static fromArgs(t){return new Ae(t.multisig,t.transactionIndex,t.status,t.bump,t.approved,t.rejected,t.cancelled)}static fromAccountInfo(t,e=0){return Ae.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find Proposal account at ${e}`);return Ae.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,bn)}static deserialize(t,e=0){return bn.deserialize(t,e)}serialize(){return bn.serialize({accountDiscriminator:$s,...this})}static byteSize(t){const e=Ae.fromArgs(t);return bn.toFixedFromValue({accountDiscriminator:$s,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(Ae.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),transactionIndex:(()=>{const t=this.transactionIndex;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),status:this.status.__kind,bump:this.bump,approved:this.approved,rejected:this.rejected,cancelled:this.cancelled}}}const bn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["multisig",P.publicKey],["transactionIndex",a.u64],["status",Ra],["bump",a.u8],["approved",a.array(P.publicKey)],["rejected",a.array(P.publicKey)],["cancelled",a.array(P.publicKey)]],Ae.fromArgs,"Proposal"),Us=[10,201,27,160,218,195,222,152];class ke{multisig;createKey;vaultIndex;mint;amount;period;remainingAmount;lastReset;bump;members;destinations;constructor(t,e,r,s,o,i,u,c,l,d,f){this.multisig=t,this.createKey=e,this.vaultIndex=r,this.mint=s,this.amount=o,this.period=i,this.remainingAmount=u,this.lastReset=c,this.bump=l,this.members=d,this.destinations=f}static fromArgs(t){return new ke(t.multisig,t.createKey,t.vaultIndex,t.mint,t.amount,t.period,t.remainingAmount,t.lastReset,t.bump,t.members,t.destinations)}static fromAccountInfo(t,e=0){return ke.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find SpendingLimit account at ${e}`);return ke.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,wn)}static deserialize(t,e=0){return wn.deserialize(t,e)}serialize(){return wn.serialize({accountDiscriminator:Us,...this})}static byteSize(t){const e=ke.fromArgs(t);return wn.toFixedFromValue({accountDiscriminator:Us,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(ke.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),createKey:this.createKey.toBase58(),vaultIndex:this.vaultIndex,mint:this.mint.toBase58(),amount:(()=>{const t=this.amount;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),period:"Period."+_n[this.period],remainingAmount:(()=>{const t=this.remainingAmount;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),lastReset:(()=>{const t=this.lastReset;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,members:this.members,destinations:this.destinations}}}const wn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["multisig",P.publicKey],["createKey",P.publicKey],["vaultIndex",a.u8],["mint",P.publicKey],["amount",a.u64],["period",is],["remainingAmount",a.u64],["lastReset",a.i64],["bump",a.u8],["members",a.array(P.publicKey)],["destinations",a.array(P.publicKey)]],ke.fromArgs,"SpendingLimit"),Ma=new a.FixableBeetArgsStruct([["programIdIndex",a.u8],["accountIndexes",a.bytes],["data",a.bytes]],"MultisigCompiledInstruction"),Ca=new a.FixableBeetArgsStruct([["accountKey",P.publicKey],["writableIndexes",a.bytes],["readonlyIndexes",a.bytes]],"MultisigMessageAddressTableLookup"),Co=new a.FixableBeetArgsStruct([["numSigners",a.u8],["numWritableSigners",a.u8],["numWritableNonSigners",a.u8],["accountKeys",a.array(P.publicKey)],["instructions",a.array(Ma)],["addressTableLookups",a.array(Ca)]],"VaultTransactionMessage"),Os=[196,121,46,36,12,19,252,7];class Ie{bump;ephemeralSignerBumps;message;constructor(t,e,r){this.bump=t,this.ephemeralSignerBumps=e,this.message=r}static fromArgs(t){return new Ie(t.bump,t.ephemeralSignerBumps,t.message)}static fromAccountInfo(t,e=0){return Ie.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find VaultBatchTransaction account at ${e}`);return Ie.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,xn)}static deserialize(t,e=0){return xn.deserialize(t,e)}serialize(){return xn.serialize({accountDiscriminator:Os,...this})}static byteSize(t){const e=Ie.fromArgs(t);return xn.toFixedFromValue({accountDiscriminator:Os,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(Ie.byteSize(t),r)}pretty(){return{bump:this.bump,ephemeralSignerBumps:this.ephemeralSignerBumps,message:this.message}}}const xn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["bump",a.u8],["ephemeralSignerBumps",a.bytes],["message",Co]],Ie.fromArgs,"VaultBatchTransaction"),Hs=[168,250,162,100,81,14,162,207];class Be{multisig;creator;index;bump;vaultIndex;vaultBump;ephemeralSignerBumps;message;constructor(t,e,r,s,o,i,u,c){this.multisig=t,this.creator=e,this.index=r,this.bump=s,this.vaultIndex=o,this.vaultBump=i,this.ephemeralSignerBumps=u,this.message=c}static fromArgs(t){return new Be(t.multisig,t.creator,t.index,t.bump,t.vaultIndex,t.vaultBump,t.ephemeralSignerBumps,t.message)}static fromAccountInfo(t,e=0){return Be.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find VaultTransaction account at ${e}`);return Be.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,Sn)}static deserialize(t,e=0){return Sn.deserialize(t,e)}serialize(){return Sn.serialize({accountDiscriminator:Hs,...this})}static byteSize(t){const e=Be.fromArgs(t);return Sn.toFixedFromValue({accountDiscriminator:Hs,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(Be.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const t=this.index;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,vaultIndex:this.vaultIndex,vaultBump:this.vaultBump,ephemeralSignerBumps:this.ephemeralSignerBumps,message:this.message}}}const Sn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["multisig",P.publicKey],["creator",P.publicKey],["index",a.u64],["bump",a.u8],["vaultIndex",a.u8],["vaultBump",a.u8],["ephemeralSignerBumps",a.bytes],["message",Co]],Be.fromArgs,"VaultTransaction"),j=new Map,Z=new Map;class Nn extends Error{code=6e3;name="DuplicateMember";constructor(){super("Found multiple members with the same pubkey"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Nn)}}j.set(6e3,()=>new Nn);Z.set("DuplicateMember",()=>new Nn);class qn extends Error{code=6001;name="EmptyMembers";constructor(){super("Members array is empty"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,qn)}}j.set(6001,()=>new qn);Z.set("EmptyMembers",()=>new qn);class $n extends Error{code=6002;name="TooManyMembers";constructor(){super("Too many members, can be up to 65535"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$n)}}j.set(6002,()=>new $n);Z.set("TooManyMembers",()=>new $n);class Un extends Error{code=6003;name="InvalidThreshold";constructor(){super("Invalid threshold, must be between 1 and number of members with Vote permission"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Un)}}j.set(6003,()=>new Un);Z.set("InvalidThreshold",()=>new Un);class On extends Error{code=6004;name="Unauthorized";constructor(){super("Attempted to perform an unauthorized action"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,On)}}j.set(6004,()=>new On);Z.set("Unauthorized",()=>new On);class Hn extends Error{code=6005;name="NotAMember";constructor(){super("Provided pubkey is not a member of multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Hn)}}j.set(6005,()=>new Hn);Z.set("NotAMember",()=>new Hn);class Wn extends Error{code=6006;name="InvalidTransactionMessage";constructor(){super("TransactionMessage is malformed."),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Wn)}}j.set(6006,()=>new Wn);Z.set("InvalidTransactionMessage",()=>new Wn);class Vn extends Error{code=6007;name="StaleProposal";constructor(){super("Proposal is stale"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Vn)}}j.set(6007,()=>new Vn);Z.set("StaleProposal",()=>new Vn);class jn extends Error{code=6008;name="InvalidProposalStatus";constructor(){super("Invalid proposal status"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,jn)}}j.set(6008,()=>new jn);Z.set("InvalidProposalStatus",()=>new jn);class Gn extends Error{code=6009;name="InvalidTransactionIndex";constructor(){super("Invalid transaction index"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Gn)}}j.set(6009,()=>new Gn);Z.set("InvalidTransactionIndex",()=>new Gn);class Zn extends Error{code=6010;name="AlreadyApproved";constructor(){super("Member already approved the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Zn)}}j.set(6010,()=>new Zn);Z.set("AlreadyApproved",()=>new Zn);class Yn extends Error{code=6011;name="AlreadyRejected";constructor(){super("Member already rejected the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Yn)}}j.set(6011,()=>new Yn);Z.set("AlreadyRejected",()=>new Yn);class Qn extends Error{code=6012;name="AlreadyCancelled";constructor(){super("Member already cancelled the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Qn)}}j.set(6012,()=>new Qn);Z.set("AlreadyCancelled",()=>new Qn);class Xn extends Error{code=6013;name="InvalidNumberOfAccounts";constructor(){super("Wrong number of accounts provided"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Xn)}}j.set(6013,()=>new Xn);Z.set("InvalidNumberOfAccounts",()=>new Xn);class Jn extends Error{code=6014;name="InvalidAccount";constructor(){super("Invalid account provided"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Jn)}}j.set(6014,()=>new Jn);Z.set("InvalidAccount",()=>new Jn);class tr extends Error{code=6015;name="RemoveLastMember";constructor(){super("Cannot remove last member"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,tr)}}j.set(6015,()=>new tr);Z.set("RemoveLastMember",()=>new tr);class er extends Error{code=6016;name="NoVoters";constructor(){super("Members don't include any voters"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,er)}}j.set(6016,()=>new er);Z.set("NoVoters",()=>new er);class nr extends Error{code=6017;name="NoProposers";constructor(){super("Members don't include any proposers"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,nr)}}j.set(6017,()=>new nr);Z.set("NoProposers",()=>new nr);class rr extends Error{code=6018;name="NoExecutors";constructor(){super("Members don't include any executors"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,rr)}}j.set(6018,()=>new rr);Z.set("NoExecutors",()=>new rr);class sr extends Error{code=6019;name="InvalidStaleTransactionIndex";constructor(){super("`stale_transaction_index` must be <= `transaction_index`"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,sr)}}j.set(6019,()=>new sr);Z.set("InvalidStaleTransactionIndex",()=>new sr);class or extends Error{code=6020;name="NotSupportedForControlled";constructor(){super("Instruction not supported for controlled multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,or)}}j.set(6020,()=>new or);Z.set("NotSupportedForControlled",()=>new or);class ir extends Error{code=6021;name="TimeLockNotReleased";constructor(){super("Proposal time lock has not been released"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ir)}}j.set(6021,()=>new ir);Z.set("TimeLockNotReleased",()=>new ir);class cr extends Error{code=6022;name="NoActions";constructor(){super("Config transaction must have at least one action"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,cr)}}j.set(6022,()=>new cr);Z.set("NoActions",()=>new cr);class ar extends Error{code=6023;name="MissingAccount";constructor(){super("Missing account"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ar)}}j.set(6023,()=>new ar);Z.set("MissingAccount",()=>new ar);class ur extends Error{code=6024;name="InvalidMint";constructor(){super("Invalid mint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ur)}}j.set(6024,()=>new ur);Z.set("InvalidMint",()=>new ur);class lr extends Error{code=6025;name="InvalidDestination";constructor(){super("Invalid destination"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,lr)}}j.set(6025,()=>new lr);Z.set("InvalidDestination",()=>new lr);class dr extends Error{code=6026;name="SpendingLimitExceeded";constructor(){super("Spending limit exceeded"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,dr)}}j.set(6026,()=>new dr);Z.set("SpendingLimitExceeded",()=>new dr);class fr extends Error{code=6027;name="DecimalsMismatch";constructor(){super("Decimals don't match the mint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,fr)}}j.set(6027,()=>new fr);Z.set("DecimalsMismatch",()=>new fr);class hr extends Error{code=6028;name="UnknownPermission";constructor(){super("Member has unknown permission"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,hr)}}j.set(6028,()=>new hr);Z.set("UnknownPermission",()=>new hr);class gr extends Error{code=6029;name="ProtectedAccount";constructor(){super("Account is protected, it cannot be passed into a CPI as writable"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,gr)}}j.set(6029,()=>new gr);Z.set("ProtectedAccount",()=>new gr);class pr extends Error{code=6030;name="TimeLockExceedsMaxAllowed";constructor(){super("Time lock exceeds the maximum allowed (90 days)"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pr)}}j.set(6030,()=>new pr);Z.set("TimeLockExceedsMaxAllowed",()=>new pr);class mr extends Error{code=6031;name="IllegalAccountOwner";constructor(){super("Account is not owned by Multisig program"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,mr)}}j.set(6031,()=>new mr);Z.set("IllegalAccountOwner",()=>new mr);class yr extends Error{code=6032;name="RentReclamationDisabled";constructor(){super("Rent reclamation is disabled for this multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,yr)}}j.set(6032,()=>new yr);Z.set("RentReclamationDisabled",()=>new yr);class br extends Error{code=6033;name="InvalidRentCollector";constructor(){super("Invalid rent collector address"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,br)}}j.set(6033,()=>new br);Z.set("InvalidRentCollector",()=>new br);class wr extends Error{code=6034;name="ProposalForAnotherMultisig";constructor(){super("Proposal is for another multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,wr)}}j.set(6034,()=>new wr);Z.set("ProposalForAnotherMultisig",()=>new wr);class xr extends Error{code=6035;name="TransactionForAnotherMultisig";constructor(){super("Transaction is for another multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,xr)}}j.set(6035,()=>new xr);Z.set("TransactionForAnotherMultisig",()=>new xr);class Sr extends Error{code=6036;name="TransactionNotMatchingProposal";constructor(){super("Transaction doesn't match proposal"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Sr)}}j.set(6036,()=>new Sr);Z.set("TransactionNotMatchingProposal",()=>new Sr);class Ar extends Error{code=6037;name="TransactionNotLastInBatch";constructor(){super("Transaction is not last in batch"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ar)}}j.set(6037,()=>new Ar);Z.set("TransactionNotLastInBatch",()=>new Ar);class kr extends Error{code=6038;name="BatchNotEmpty";constructor(){super("Batch is not empty"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,kr)}}j.set(6038,()=>new kr);Z.set("BatchNotEmpty",()=>new kr);class Ir extends Error{code=6039;name="SpendingLimitInvalidAmount";constructor(){super("Invalid SpendingLimit amount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ir)}}j.set(6039,()=>new Ir);Z.set("SpendingLimitInvalidAmount",()=>new Ir);function Ka(n){const t=j.get(n);return t!=null?t():null}new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"BatchAccountsCloseInstructionArgs");const Pa=new a.FixableBeetArgsStruct([["ephemeralSigners",a.u8],["transactionMessage",a.bytes]],"BatchAddTransactionArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Pa]],"BatchAddTransactionInstructionArgs");const Fa=new a.FixableBeetArgsStruct([["vaultIndex",a.u8],["memo",a.coption(a.utf8String)]],"BatchCreateArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Fa]],"BatchCreateInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"BatchExecuteTransactionInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"ConfigTransactionAccountsCloseInstructionArgs");const Da=new a.FixableBeetArgsStruct([["actions",a.array(Mo)],["memo",a.coption(a.utf8String)]],"ConfigTransactionCreateArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Da]],"ConfigTransactionCreateInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"ConfigTransactionExecuteInstructionArgs");const Na=new a.FixableBeetArgsStruct([["newMember",an],["memo",a.coption(a.utf8String)]],"MultisigAddMemberArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Na]],"MultisigAddMemberInstructionArgs");const qa=new a.FixableBeetArgsStruct([["createKey",P.publicKey],["vaultIndex",a.u8],["mint",P.publicKey],["amount",a.u64],["period",is],["members",a.array(P.publicKey)],["destinations",a.array(P.publicKey)],["memo",a.coption(a.utf8String)]],"MultisigAddSpendingLimitArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",qa]],"MultisigAddSpendingLimitInstructionArgs");const $a=new a.FixableBeetArgsStruct([["newThreshold",a.u16],["memo",a.coption(a.utf8String)]],"MultisigChangeThresholdArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",$a]],"MultisigChangeThresholdInstructionArgs");const Ua=new a.FixableBeetArgsStruct([["configAuthority",a.coption(P.publicKey)],["threshold",a.u16],["members",a.array(an)],["timeLock",a.u32],["memo",a.coption(a.utf8String)]],"MultisigCreateArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Ua]],"MultisigCreateInstructionArgs");const Oa=new a.FixableBeetArgsStruct([["configAuthority",a.coption(P.publicKey)],["threshold",a.u16],["members",a.array(an)],["timeLock",a.u32],["rentCollector",a.coption(P.publicKey)],["memo",a.coption(a.utf8String)]],"MultisigCreateArgsV2");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Oa]],"MultisigCreateV2InstructionArgs");const Ha=new a.FixableBeetArgsStruct([["oldMember",P.publicKey],["memo",a.coption(a.utf8String)]],"MultisigRemoveMemberArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Ha]],"MultisigRemoveMemberInstructionArgs");const Wa=new a.FixableBeetArgsStruct([["memo",a.coption(a.utf8String)]],"MultisigRemoveSpendingLimitArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Wa]],"MultisigRemoveSpendingLimitInstructionArgs");const Va=new a.FixableBeetArgsStruct([["configAuthority",P.publicKey],["memo",a.coption(a.utf8String)]],"MultisigSetConfigAuthorityArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Va]],"MultisigSetConfigAuthorityInstructionArgs");const ja=new a.FixableBeetArgsStruct([["rentCollector",a.coption(P.publicKey)],["memo",a.coption(a.utf8String)]],"MultisigSetRentCollectorArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",ja]],"MultisigSetRentCollectorInstructionArgs");const Ga=new a.FixableBeetArgsStruct([["timeLock",a.u32],["memo",a.coption(a.utf8String)]],"MultisigSetTimeLockArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Ga]],"MultisigSetTimeLockInstructionArgs");const Za=new a.BeetArgsStruct([["authority",P.publicKey],["multisigCreationFee",a.u64],["treasury",P.publicKey]],"ProgramConfigInitArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Za]],"ProgramConfigInitInstructionArgs");const Ya=new a.BeetArgsStruct([["newAuthority",P.publicKey]],"ProgramConfigSetAuthorityArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Ya]],"ProgramConfigSetAuthorityInstructionArgs");const Qa=new a.BeetArgsStruct([["newMultisigCreationFee",a.u64]],"ProgramConfigSetMultisigCreationFeeArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Qa]],"ProgramConfigSetMultisigCreationFeeInstructionArgs");const Xa=new a.BeetArgsStruct([["newTreasury",P.publicKey]],"ProgramConfigSetTreasuryArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Xa]],"ProgramConfigSetTreasuryInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"ProposalActivateInstructionArgs");const cs=new a.FixableBeetArgsStruct([["memo",a.coption(a.utf8String)]],"ProposalVoteArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",cs]],"ProposalApproveInstructionArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",cs]],"ProposalCancelInstructionArgs");const Ja=new a.BeetArgsStruct([["transactionIndex",a.u64],["draft",a.bool]],"ProposalCreateArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Ja]],"ProposalCreateInstructionArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",cs]],"ProposalRejectInstructionArgs");const tu=new a.FixableBeetArgsStruct([["amount",a.u64],["decimals",a.u8],["memo",a.coption(a.utf8String)]],"SpendingLimitUseArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",tu]],"SpendingLimitUseInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"VaultBatchTransactionAccountCloseInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"VaultTransactionAccountsCloseInstructionArgs");const eu=new a.FixableBeetArgsStruct([["vaultIndex",a.u8],["ephemeralSigners",a.u8],["transactionMessage",a.bytes],["memo",a.coption(a.utf8String)]],"VaultTransactionCreateArgs"),nu=new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",eu]],"VaultTransactionCreateInstructionArgs"),ru=[48,250,78,168,208,226,218,211];function su(n,t,e=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){const[r]=nu.serialize({instructionDiscriminator:ru,...t}),s=[{pubkey:n.multisig,isWritable:!0,isSigner:!1},{pubkey:n.transaction,isWritable:!0,isSigner:!1},{pubkey:n.creator,isWritable:!1,isSigner:!0},{pubkey:n.rentPayer,isWritable:!0,isSigner:!0},{pubkey:n.systemProgram??en.programId,isWritable:!1,isSigner:!1}];if(n.anchorRemainingAccounts!=null)for(const i of n.anchorRemainingAccounts)s.push(i);return new Dt({programId:e,keys:s,data:r})}new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"VaultTransactionExecuteInstructionArgs");var Or;(function(n){n[n.Approve=0]="Approve",n[n.Reject=1]="Reject",n[n.Cancel=2]="Cancel"})(Or||(Or={}));a.fixedScalarEnum(Or);const ou="SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf",as=new R(ou);si.initCusper(Ka);var iu=function(n,t,e,r,s,o,i,u){if(!n){var c;if(t===void 0)c=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var l=[e,r,s,o,i,u],d=0;c=new Error(t.replace(/%s/g,function(){return l[d++]})),c.name="Invariant Violation"}throw c.framesToPop=1,c}},Ln=iu;function Ws(n,t,e){const r=t.length,s=r===0?"<EMPTY>":t[0].description;return{write:function(o,i,u){Ln(u.length===r,`array length ${u.length} should match len ${r}`),n.write(o,i,r);let c=i+n.byteSize;for(let l=0;l<r;l++){const d=t[l];d.write(o,c,u[l]),c+=d.byteSize}},read:function(o,i){const u=n.read(o,i);Ln(u===r,"invalid byte size");let c=i+n.byteSize;const l=new Array(r);for(let d=0;d<r;d++){const f=t[d];l[d]=f.read(o,c),c+=f.byteSize}return l},byteSize:n.byteSize+e,length:r,description:`Array<${s}>(${r})[ ${n.byteSize} + ${e} ]`}}function Te(n,t){return{toFixedFromData(e,r){const s=n.read(e,r),o=r+n.byteSize;let i=o;const u=new Array(s);for(let c=0;c<s;c++){const l=a.fixBeetFromData(t,e,i);u[c]=l,i+=l.byteSize}return Ws(n,u,i-o)},toFixedFromValue(e){Ln(Array.isArray(e),`${e} should be an array`);let r=0;const s=new Array(e.length);for(let o=0;o<e.length;o++){const i=a.fixBeetFromValue(t,e[o]);s[o]=i,r+=i.byteSize}return Ws(n,s,r)},description:"smallArray"}}const cu=new a.FixableBeetArgsStruct([["programIdIndex",a.u8],["accountIndexes",Te(a.u8,a.u8)],["data",Te(a.u16,a.u8)]],"CompiledMsInstruction"),au=new a.FixableBeetArgsStruct([["accountKey",P.publicKey],["writableIndexes",Te(a.u8,a.u8)],["readonlyIndexes",Te(a.u8,a.u8)]],"MessageAddressTableLookup"),uu=new a.FixableBeetArgsStruct([["numSigners",a.u8],["numWritableSigners",a.u8],["numWritableNonSigners",a.u8],["accountKeys",Te(a.u8,P.publicKey)],["instructions",Te(a.u8,cu)],["addressTableLookups",Te(a.u8,au)]],"TransactionMessage");class us{payer;keyMetaMap;constructor(t,e){this.payer=t,this.keyMetaMap=e}static compile(t,e){const r=new Map,s=i=>{const u=i.toBase58();let c=r.get(u);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(u,c)),c},o=s(e);o.isSigner=!0,o.isWritable=!0;for(const i of t){s(i.programId).isInvoked=!1;for(const u of i.keys){const c=s(u.pubkey);c.isSigner||=u.isSigner,c.isWritable||=u.isWritable}}return new us(e,r)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];ln(t.length<=256,"Max static account keys length exceeded");const e=t.filter(([,c])=>c.isSigner&&c.isWritable),r=t.filter(([,c])=>c.isSigner&&!c.isWritable),s=t.filter(([,c])=>!c.isSigner&&c.isWritable),o=t.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:e.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{ln(e.length>0,"Expected at least one writable signer key");const[c]=e[0];ln(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const u=[...e.map(([c])=>new R(c)),...r.map(([c])=>new R(c)),...s.map(([c])=>new R(c)),...o.map(([c])=>new R(c))];return[i,u]}extractTableLookup(t){const[e,r]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(e.length===0&&s.length===0))return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:s},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(t,e){const r=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(e(i)){const u=new R(o),c=t.findIndex(l=>l.equals(u));c>=0&&(ln(c<256,"Max lookup table index exceeded"),r.push(c),s.push(u),this.keyMetaMap.delete(o))}return[r,s]}}function lu({payerKey:n,recentBlockhash:t,instructions:e,addressLookupTableAccounts:r}){const s=us.compile(e,n),o=new Array,i={writable:[],readonly:[]},u=r||[];for(const S of u){const I=s.extractTableLookup(S);if(I!==void 0){const[w,{writable:h,readonly:p}]=I;o.push(w),i.writable.push(...h),i.readonly.push(...p)}}const[c,l]=s.getMessageComponents(),f=new Je(l,i).compileInstructions(e);return new vn({header:c,staticAccountKeys:l,recentBlockhash:t,compiledInstructions:f,addressTableLookups:o})}function ie(n){return new TextEncoder().encode(n)}function du(n){const t=V.Buffer.alloc(1);return a.u8.write(t,0,n),t}function fu(n){const t=V.Buffer.alloc(8);return a.u64.write(t,0,n),t}function hu({message:n,addressLookupTableAccounts:t,vaultPda:e}){const r=lu({payerKey:n.payerKey,recentBlockhash:n.recentBlockhash,instructions:n.instructions,addressLookupTableAccounts:t}),[s]=uu.serialize({numSigners:r.header.numRequiredSignatures,numWritableSigners:r.header.numRequiredSignatures-r.header.numReadonlySignedAccounts,numWritableNonSigners:r.staticAccountKeys.length-r.header.numRequiredSignatures-r.header.numReadonlyUnsignedAccounts,accountKeys:r.staticAccountKeys,instructions:r.compiledInstructions.map(o=>({programIdIndex:o.programIdIndex,accountIndexes:o.accountKeyIndexes,data:Array.from(o.data)})),addressTableLookups:r.addressTableLookups});return s}const Ko=ie("multisig");ie("program_config");ie("multisig");const gu=ie("vault"),pu=ie("transaction");ie("proposal");ie("batch_transaction");ie("ephemeral_signer");ie("spending_limit");function Hr({multisigPda:n,index:t,programId:e=as}){return Ln(t>=0&&t<256,"Invalid vault index"),R.findProgramAddressSync([Ko,n.toBytes(),gu,du(t)],e)}function mu({multisigPda:n,index:t,programId:e=as}){return R.findProgramAddressSync([Ko,n.toBytes(),pu,fu(t)],e)}function yu({multisigPda:n,transactionIndex:t,creator:e,rentPayer:r,vaultIndex:s,ephemeralSigners:o,transactionMessage:i,addressLookupTableAccounts:u,memo:c,programId:l=as}){const[d]=Hr({multisigPda:n,index:s,programId:l}),[f]=mu({multisigPda:n,index:t,programId:l}),S=hu({message:i,addressLookupTableAccounts:u,vaultPda:d});return su({multisig:n,transaction:f,creator:e,rentPayer:r??e},{args:{vaultIndex:s,ephemeralSigners:o,transactionMessage:S,memo:c??null}},l)}const Ke="[ATLAS-LOCKER] ",bu=8,he=new Xt("ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx"),Ze=new Xt("poLisWXnNRwC6oBu1vHiuKQzFjGL4XDSu4g9qjz9qVk"),Qt=new Xt("ATLocKpzDbTokxgvnLew3d7drZkEzLzDpzwgrgWKDbmc"),Vs=new Xt("ATLkZsBofSKG845dNFpNoUyMciGpeH29BCbMqYFUoxzU"),$=Qo("globalStarAtlasLockerStore",{state:()=>({multisigPDA:Xo("multisigPDA",""),vaultPDA:{},multisigInfo:{},registeredStakeAtlas:{},registeredStakePolis:{},stakingAccountAtlas:{},stakingAccountAtlasInfo:{},atlas_balance_wallet:"0",polis_balance_wallet:"0",atlas_balance_squads:"0",polis_balance_squads:"0",atlas_balance_locker:"0",polis_balance_locker:"0"}),getters:{getMultisigPDA(n){return new Xt(n.multisigPDA)},getVaultPDA(){try{const[n]=Hr({multisigPda:new Xt(this.multisigPDA),index:0});return n}catch{return""}},getNewTransactionIndex(n){const t=Number(n.multisigInfo.transactionIndex);return BigInt(t+1)}},actions:{async setAccounts(){$().atlas_balance_wallet="0",$().polis_balance_wallet="0",$().atlas_balance_squads="0",$().polis_balance_squads="0",$().atlas_balance_locker="0",$().polis_balance_locker="0";const[n]=Hr({multisigPda:new Xt(this.multisigPDA),index:0});this.vaultPDA=n,this.multisigInfo=await fe.fromAccountAddress(Et().connection,new Xt(this.multisigPDA));const[t]=await Zt.getRegisteredStake(Qt,Vs,he,Ze);this.registeredStakeAtlas=t;const[e]=await Zt.getRegisteredStake(Qt,Vs,he,Ze);this.registeredStakePolis=e;try{const[r]=await Zt.getStakingAccount(Qt,this.vaultPDA,this.registeredStakeAtlas);this.stakingAccountAtlas=r}catch{}try{this.stakingAccountAtlasInfo=await Zt.getStakingAccountInfo(Et().connection,this.stakingAccountAtlas,Qt)}catch{}await wu()},async build_CreateStatingAccount(){const n=await Zt.createStakingAccountInstruction({connection:Et().connection,user:this.vaultPDA,registeredStake:this.registeredStakeAtlas,programId:Qt});await Pe(Ke+"CreateStatingAccount: "+oi,[n.instructions[0]])},async build_StakeTokens(n){const[t]=Xt.findProgramAddressSync([this.vaultPDA.toBuffer(),ai.toBuffer(),he.toBuffer()],ci.ASSOCIATED_PROGRAM_ID),e=await Zt.stakeTokensInstruction({connection:Et().connection,user:this.vaultPDA,stakeMint:he,tokenSource:t,stakingAccount:this.stakingAccountAtlas,stakeQuantity:new Kr(parseFloat(n.toString())*Math.pow(10,bu)),registeredStake:this.registeredStakeAtlas,programId:Qt});await Pe(Ke+"StakeTokens: "+n,[e.instructions[0]])},async build_harvestRewards(){const n=await Zt.harvestRewardsInstruction({connection:Et().connection,user:this.vaultPDA,rewardMint:Ze,registeredStake:this.registeredStakeAtlas,stakingAccount:this.stakingAccountAtlas,programId:Qt});await Pe(Ke+"HarvestRewards",[n.instructions[0]])},async build_withdrawTokens(){const n=await Zt.withdrawTokensInstruction({connection:Et().connection,user:this.vaultPDA,authority:this.vaultPDA,stakeMint:he,registeredStake:this.registeredStakeAtlas,stakingAccount:this.stakingAccountAtlas,programId:Qt});await Pe(Ke+"WithdrawTokens",[n.instructions[0]])},async build_unstakeTokens(){const n=await Zt.unstakeTokensInstruction({connection:Et().connection,user:this.vaultPDA,registeredStake:this.registeredStakeAtlas,stakingAccount:this.stakingAccountAtlas,programId:Qt});await Pe(Ke+"UnstakeTokens",[n.instructions[0]])},async build_cancelUnstake(){const n=await Zt.cancelUnstakeInstruction({connection:Et().connection,user:this.vaultPDA,registeredStake:this.registeredStakeAtlas,programId:Qt});await Pe(Ke+"CancelUnstake",[n.instructions[0]])}}});async function Pe(n,t){const{sendTransaction:e,publicKey:r}=zn(),s=new Jo({payerKey:$().vaultPDA,recentBlockhash:(await Et().connection.getLatestBlockhash()).blockhash,instructions:t}),o=yu({multisigPda:new Xt($().multisigPDA),transactionIndex:$().getNewTransactionIndex,creator:r.value,vaultIndex:0,ephemeralSigners:0,transactionMessage:s,memo:n});console.log("build: "+n);const i=await e(new ti().add(o),Et().connection);await ii(i)}async function wu(){const{publicKey:n}=zn();if(!n.value)return;const t=await Ge(he,n.value),e=await Ge(Ze,n.value),r=await Ge(he,$().vaultPDA,!0),s=await Ge(Ze,$().vaultPDA,!0),o=await Ge(he,$().stakingAccountAtlas,!0);try{$().atlas_balance_wallet=(await Et().connection.getTokenAccountBalance(t)).value.uiAmountString??"0"}catch{$().atlas_balance_wallet="-"}try{$().polis_balance_wallet=(await Et().connection.getTokenAccountBalance(e)).value.uiAmountString??"0"}catch{$().polis_balance_wallet="-"}try{$().atlas_balance_squads=(await Et().connection.getTokenAccountBalance(r)).value.uiAmountString??"0"}catch{$().atlas_balance_squads="-"}try{$().polis_balance_squads=(await Et().connection.getTokenAccountBalance(s)).value.uiAmountString??"0"}catch{$().polis_balance_squads="-"}try{$().atlas_balance_locker=(await Et().connection.getTokenAccountBalance(o)).value.uiAmountString??""}catch{$().atlas_balance_locker="-"}}const xu=b("div",{class:"text-h6 text-weight-thin"}," This Tool is build for easy interaction between StarAtlasLockers using a Squads.so multi signature account! ",-1),Su=b("div",{class:"text-subtitle1"}," Please enter the required information so send instructions to your Squads Account ",-1),Au=b("div",{class:"text-subtitle2 text-weight-thin"}," You will still need to approve the transaction in you squads account! ",-1),ku={class:"row q-gutter-x-sm items-center"},Iu={class:"col"},Bu=b("div",{class:"col text-weight-light"}," Squads.so -> Settings -> Multisig Account ",-1),vu={class:"row q-gutter-x-sm items-center"},Eu={class:"col"},Tu=b("div",{class:"col text-weight-light"},"Your Squads Account",-1),_u={class:"row items-center"},Lu=b("div",{class:"text-subtitle1"},"Squads Multisig Info",-1),zu={key:0},Ru=b("div",{class:"text-subtitle2"},"Members",-1),Mu=b("div",{class:"row"},[b("div",{class:"col"},"Member Address"),b("div",null,"Permission")],-1),Cu={class:"row"},Ku={class:"col"},Pu=Rn({__name:"SetupLockerView",setup(n){return(t,e)=>(kt(),se(Wr,{flat:""},{default:St(()=>[tt(ge,null,{default:St(()=>[xu]),_:1}),tt(ge,null,{default:St(()=>[Su,Au]),_:1}),tt(ge,{class:"q-gutter-y-sm"},{default:St(()=>[b("div",ku,[b("div",Iu,[tt(Cr,{dense:"",standout:"",modelValue:st($)().multisigPDA,"onUpdate:modelValue":e[0]||(e[0]=r=>st($)().multisigPDA=r),label:"MultisigPDA"},null,8,["modelValue"])]),Bu]),b("div",vu,[b("div",Eu,[tt(Cr,{disable:"",dense:"",standout:"",modelValue:st($)().getVaultPDA,"onUpdate:modelValue":e[1]||(e[1]=r=>st($)().getVaultPDA=r),label:"VaultPDA"},null,8,["modelValue"])]),Tu])]),_:1}),tt(ge,null,{default:St(()=>{var r,s;return[b("div",_u,[Lu,tt(Wo),tt(ye,{square:"",color:"primary",label:"Update Squads info",onClick:e[2]||(e[2]=o=>st($)().setAccounts())})]),(s=(r=st($)().multisigInfo)==null?void 0:r.members)!=null&&s.length?(kt(),pe("div",zu,[Ru,tt(ri,{dense:"",bordered:"",padding:"",class:"rounded-borders"},{default:St(()=>[ys((kt(),se(ws,null,{default:St(()=>[tt(xs,null,{default:St(()=>[Mu]),_:1})]),_:1})),[[bs]]),(kt(!0),pe(Gs,null,Zs(st($)().multisigInfo.members,o=>ys((kt(),se(ws,{clickable:"",key:o.key},{default:St(()=>[tt(xs,null,{default:St(()=>[b("div",Cu,[b("div",Ku,Ct(o.key),1),b("div",null,Ct(o.permissions.mask),1)])]),_:2},1024)]),_:2},1024)),[[bs]])),128))]),_:1})])):An("",!0)]}),_:1})]),_:1}))}}),Fu={class:"row"},Du={class:"col-1"},Nu={class:"col"},qu={class:"row q-pr-md items-center"},$u=b("div",{class:"col text-right text-subtitle2 text-weight-light"},[b("div",null,"Squads Vault Account")],-1),Uu={class:"col text-right text-subtitle1"},Ou={class:"row q-pr-md items-center"},Hu=b("div",{class:"col text-right text-subtitle2 text-weight-light"},[b("div",null,"Squads Registered Stake")],-1),Wu={class:"col text-right text-subtitle1"},Vu={class:"row q-pr-md items-center"},ju=b("div",{class:"col text-right text-subtitle2 text-weight-light"},[b("div",null,"Squads Staking Account")],-1),Gu={class:"col text-right text-subtitle1"},Zu=b("div",{class:"row items-center q-mx-md"},[b("div",{class:"col"},[b("div",{class:"text-h4"},"Instruction")]),b("div",{class:"col-4"},[b("div",{class:"text-h4 text-center"},"Action")])],-1),Yu={class:"row items-center q-mx-md"},Qu=b("div",{class:"col"},[b("div",{class:"text-h6"},"Create Staking Account"),b("div",{class:"text-subtitle2 text-weight-light"}," This instruction will create a new locker instance for you ")],-1),Xu={class:"col-4"},Ju={class:"row items-center q-mx-md"},tl=b("div",{class:"col"},[b("div",{class:"text-h6"},"Stake Tokens"),b("div",{class:"text-subtitle2 text-weight-light"}," This instruction will stake additional tokens ")],-1),el={class:"col-4"},nl={class:"row q-gutter-x-xs"},rl={class:"row items-center q-mx-md"},sl=b("div",{class:"col"},[b("div",{class:"col text-h6"},"Harvest"),b("div",{class:"text-subtitle2 text-weight-light"}," This instruction will claim your rewards ")],-1),ol={class:"col-4"},il={class:"row items-center q-mx-md"},cl=b("div",{class:"col"},[b("div",{class:"text-h6"},"Unstake Tokens"),b("div",{class:"text-subtitle2 text-weight-light"}," This instruction will stake additional tokens ")],-1),al={class:"col-4"},ul={class:"row items-center q-mx-md"},ll=b("div",{class:"col"},[b("div",{class:"text-h6"},"Cancel Unstake"),b("div",{class:"text-subtitle2 text-weight-light"}," This instruction will stake additional tokens ")],-1),dl={class:"col-4"},fl={class:"row items-center q-mx-md"},hl=b("div",{class:"col"},[b("div",{class:"text-h6"},"Withdraw Tokens"),b("div",{class:"text-subtitle2 text-weight-light"}," This instruction will stake additional tokens ")],-1),gl={class:"col-4"},pl={class:"row items-center"},ml=b("div",{class:"col-1 text-h5"},"Locker Info",-1),yl={key:0,class:"col"},bl={class:"col text-right text-subtitle2 text-weight-light"},wl={class:"col text-right text-subtitle1"},xl={key:1,class:"text-subtitle2 text-center"},Sl=Rn({__name:"AtlasLockerView",setup(n){const t=Ys(0);return Qs(async()=>{await $().setAccounts()}),(e,r)=>(kt(),se(Wr,{flat:""},{default:St(()=>[tt(ge,null,{default:St(()=>[b("div",Fu,[b("div",Du,[tt(ui,{src:"/currencies/ATLAS.webp"})]),tt(dn,{class:"q-mx-sm",vertical:""}),b("div",Nu,[b("div",qu,[$u,b("div",Uu,[b("div",null,Ct(st($)().vaultPDA),1)])]),b("div",Ou,[Hu,b("div",Wu,[b("div",null,Ct(st($)().registeredStakeAtlas),1)])]),b("div",Vu,[ju,b("div",Gu,[b("div",null,Ct(st($)().stakingAccountAtlas),1)])])])])]),_:1}),tt(ge,null,{default:St(()=>[Zu,tt(dn,{class:"q-my-sm"}),b("div",Yu,[Qu,b("div",Xu,[tt(ye,{class:"full-width",square:"",label:"Sign",color:"primary",onClick:r[0]||(r[0]=s=>st($)().build_CreateStatingAccount())})])]),b("div",Ju,[tl,b("div",el,[b("div",nl,[tt(Cr,{dense:"",square:"",class:"col",standout:"",type:"number",modelValue:t.value,"onUpdate:modelValue":r[1]||(r[1]=s=>t.value=s),label:"Amount to stake"},null,8,["modelValue"]),tt(ye,{square:"",class:"col-3",label:"Sign",color:"primary",onClick:r[2]||(r[2]=s=>st($)().build_StakeTokens(t.value))})])])]),b("div",rl,[sl,b("div",ol,[tt(ye,{class:"full-width",label:"Sign",color:"primary",onClick:r[3]||(r[3]=s=>st($)().build_harvestRewards())})])]),b("div",il,[cl,b("div",al,[tt(ye,{class:"full-width",label:"Sign",color:"primary",onClick:r[4]||(r[4]=s=>st($)().build_unstakeTokens())})])]),b("div",ul,[ll,b("div",dl,[tt(ye,{class:"full-width",label:"Sign",color:"primary"})])]),b("div",fl,[hl,b("div",gl,[tt(ye,{class:"full-width",label:"Sign",color:"primary",onClick:r[5]||(r[5]=s=>st($)().build_withdrawTokens())})])])]),_:1}),tt(ge,null,{default:St(()=>[tt(dn,{class:"q-my-sm"}),b("div",pl,[ml,tt(dn,{class:"q-mx-sm",vertical:""}),st($)().stakingAccountAtlasInfo.length?(kt(),pe("div",yl,[(kt(!0),pe(Gs,null,Zs(Object.keys(st($)().stakingAccountAtlasInfo),(s,o)=>(kt(),pe("div",{class:"row q-pr-md items-center",key:o},[b("div",bl,[b("div",null,Ct(s.toUpperCase()),1)]),b("div",wl,[b("div",null,Ct(st($)().stakingAccountAtlasInfo[s]),1)])]))),128))])):(kt(),pe("div",xl,"No Locker found!"))])]),_:1})]),_:1}))}}),Al={};function kl(n,t){return"!Under construction!"}var Il=li(Al,[["render",kl]]);const Bl={class:"row"},vl=b("div",{class:"col-3"},"Wallet",-1),El={class:"col"},Tl={class:"row q-gutter-x-xs no-wrap justify-end"},_l=b("div",null,"Atlas",-1),Ll={class:"col"},zl={class:"row q-gutter-x-xs no-wrap justify-end"},Rl=b("div",null,"Polis",-1),Ml={class:"row"},Cl=b("div",{class:"col-3"},"Squads",-1),Kl={class:"col"},Pl={class:"row q-gutter-x-xs no-wrap justify-end"},Fl=b("div",null,"Atlas",-1),Dl={class:"col"},Nl={class:"row q-gutter-x-xs no-wrap justify-end"},ql=b("div",null,"Polis",-1),$l={class:"row"},Ul=b("div",{class:"col-3"},"Locker",-1),Ol={class:"col"},Hl={class:"row q-gutter-x-xs no-wrap justify-end"},Wl=b("div",null,"Atlas",-1),Vl={class:"col"},jl={class:"row q-gutter-x-xs no-wrap justify-end"},Gl=b("div",null,"Polis",-1),Zl=Rn({__name:"TokenLockerBalances",setup(n){return Qs(async()=>{await $().setAccounts()}),ei(()=>zn().publicKey.value,async()=>{await $().setAccounts()}),(t,e)=>(kt(),se(Wr,{class:""},{default:St(()=>[tt(ge,null,{default:St(()=>[b("div",Bl,[vl,b("div",El,[b("div",Tl,[b("div",null,Ct(st($)().atlas_balance_wallet),1),_l])]),b("div",Ll,[b("div",zl,[b("div",null,Ct(st($)().polis_balance_wallet),1),Rl])])]),b("div",Ml,[Cl,b("div",Kl,[b("div",Pl,[b("div",null,Ct(st($)().atlas_balance_squads),1),Fl])]),b("div",Dl,[b("div",Nl,[b("div",null,Ct(st($)().polis_balance_squads),1),ql])])]),b("div",$l,[Ul,b("div",Ol,[b("div",Hl,[b("div",null,Ct(st($)().atlas_balance_locker),1),Wl])]),b("div",Vl,[b("div",jl,[b("div",null,Ct(st($)().polis_balance_locker),1),Gl])])])]),_:1})]),_:1}))}}),Yl={key:0,class:"col absolute-center"},Ql={key:1},Xl=b("div",{class:"col"},null,-1),bd=Rn({__name:"StarAtlasLocker",setup(n){const t=Ys("setup");return(e,r)=>(kt(),se(Ho,{class:"bg-black"},{default:St(()=>{var s,o;return[(o=(s=st(zn)().publicKey)==null?void 0:s.value)!=null&&o.toString()?(kt(),pe("div",Ql,[tt(Oo,{modelValue:t.value,"onUpdate:modelValue":r[0]||(r[0]=i=>t.value=i),align:"left"},{default:St(()=>[tt(vr,{name:"setup",label:"Setup"}),tt(vr,{name:"atlas",label:"Atlas"}),tt(vr,{name:"polis",label:"Polis"}),Xl,tt(Zl,{class:"q-pr-md col"})]),_:1},8,["modelValue"]),t.value=="setup"?(kt(),se(Pu,{key:0})):An("",!0),t.value=="atlas"?(kt(),se(Sl,{key:1})):An("",!0),t.value=="polis"?(kt(),se(Il,{key:2})):An("",!0)])):(kt(),pe("div",Yl,[tt(st(ni),{dark:""})]))]}),_:1}))}});export{bd as default};
