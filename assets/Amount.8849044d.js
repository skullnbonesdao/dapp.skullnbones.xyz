import{ea as rs,dF as hr,dG as ss,dH as ns,dI as os,dJ as fr,dK as pr,dL as gr,dM as yr,dN as mr,cY as is,dO as br,dP as kr,bY as Sr,dQ as x,dR as se,d1 as v,dB as T,dC as le,d2 as M,dS as ne,dT as Ee,dE as de,dU as vt,da as j,dp as Fe,dW as Gt,dX as We,dY as as,dZ as cs,d_ as us,db as ls,dc as wr,eg as jt}from"./index.e3ff99be.js";function Ve(o){return Ve=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol=="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Ve(o)}function ds(o,e){if(Ve(o)!=="object"||o===null)return o;var t=o[Symbol.toPrimitive];if(t!==void 0){var r=t.call(o,e||"default");if(Ve(r)!=="object")return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(o)}function hs(o){var e=ds(o,"string");return Ve(e)==="symbol"?e:String(e)}function ni(o,e,t){return e=hs(e),e in o?Object.defineProperty(o,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):o[e]=t,o}function Z(o,e,t){return e=ps(e),e in o?Object.defineProperty(o,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):o[e]=t,o}function fs(o,e){if(typeof o!="object"||o===null)return o;var t=o[Symbol.toPrimitive];if(t!==void 0){var r=t.call(o,e||"default");if(typeof r!="object")return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return(e==="string"?String:Number)(o)}function ps(o){var e=fs(o,"string");return typeof e=="symbol"?e:String(e)}class gs extends Error{constructor(e,t,r,s){super(e),Z(this,"name","MetaplexError"),this.source=t,this.sourceDetails=r,this.cause=s,this.message=this.message+`

Source: ${this.getFullSource()}`+(this.cause?`

Caused By: ${this.cause}`:"")+`
`}getCapitalizedSource(){return this.source==="sdk"||this.source==="rpc"?this.source.toUpperCase():this.source[0].toUpperCase()+this.source.slice(1)}getFullSource(){const e=this.getCapitalizedSource(),t=this.sourceDetails?` > ${this.sourceDetails}`:"";return e+t}toString(){return`[${this.name}] ${this.message}`}}class re extends gs{constructor(e,t){super(e,"sdk",void 0,t),Z(this,"name","SdkError")}}class oi extends re{constructor(e){const t=`No operation handler was registered for the [${e}] operation. Did you forget to register it? You may do this by using: "metaplex.operations().register(operation, operationHandler)".`;super(t),Z(this,"name","OperationHandlerMissingError")}}class ii extends re{constructor(e){const t=`The SDK tried to access the driver [${e}] but was not provided. Make sure the driver is registered by using the "setDriver(myDriver)" method.`;super(t),Z(this,"name","DriverNotProvidedError")}}class ys extends re{constructor(e,t){const r=`Expected currency [${t}] but got [${e}]. Ensure the provided Amount or Currency is of the expected type.`;super(r),Z(this,"name","UnexpectedCurrencyError"),this.actual=e,this.expected=t}}class ms extends re{constructor(e,t,r){const n=`The SDK tried to execute an operation${r?` [${r}]`:""} on two different currencies: ${e.symbol} and ${t.symbol}. Provide both amounts in the same currency to perform this operation.`;super(n),Z(this,"name","CurrencyMismatchError"),this.left=e,this.right=t,this.operation=r}}class ai extends re{constructor(e){super("The provided JSON variable could not be parsed into a string.",e),Z(this,"name","InvalidJsonVariableError")}}class ci extends re{constructor(e){super("The provided string could not be parsed into a JSON variable.",e),Z(this,"name","InvalidJsonStringError")}}class ui extends re{constructor(e){const t=`Trying to access the [${e}] operation as a guest. Ensure your wallet is connected using the identity driver. For instance, by using "metaplex.use(walletAdapterIdentity(wallet))" or "metaplex.use(keypairIdentity(keypair))".`;super(t),Z(this,"name","OperationUnauthorizedForGuestsError")}}class li extends re{constructor(e,t,r){const s=(t?`The account of type [${t}] was not found`:"No account was found")+` at the provided address [${e.toString()}].`+(r?` ${r}`:"");super(s),Z(this,"name","AccountNotFoundError")}}class di extends re{constructor(e,t,r){const s=`The account at the provided address [${e.toString()}] is not of the expected type [${t}].`;super(s,r),Z(this,"name","UnexpectedAccountError")}}class hi extends re{constructor(e,t,r){const s=`Expected variable [${e}] to be of type [Signer] but got [${t}]. `+(r??"Please check that you are providing the variable as a signer. Note that, it may be allowed to provide a non-signer variable for certain use cases but not this one.");super(s),Z(this,"name","ExpectedSignerError")}}class fi extends re{constructor(e,t){const r=typeof e=="string",s=r?e:e.toString(),n=`The provided program ${r?"name":"address"} [${s}] is not recognized in the [${t}] cluster.Did you forget to register this program? If so, you may use "metaplex.programs().register(myProgram)" to fix this.`;super(n),Z(this,"name","ProgramNotRecognizedError"),this.nameOrAddress=e,this.cluster=t}}class pi extends re{constructor(e,t){const r=`The input provided to the [${e}] resulted in a Transaction containing no Instructions. `+(t??"Ensure that the provided input has an effect on the operation. This typically happens when trying to update an account with the same data it already contains.");super(r),Z(this,"name","NoInstructionsToSendError")}}class gi extends re{constructor(e,t){const r=`The received data could not be serialized as a [${e}].`;super(r,t),Z(this,"name","FailedToSerializeDataError")}}class yi extends re{constructor(e,t){const r=`The received serialized data could not be deserialized to a [${e}].`;super(r,t),Z(this,"name","FailedToDeserializeDataError")}}class mi extends re{constructor(e,t){const r=`Some parameters are missing from the provided input object. Please provide the following missing parameters [${e.join(", ")}].`+(t?` ${t}`:"");super(r),Z(this,"name","MissingInputDataError")}}class bi extends re{constructor(){const e="This feature is not yet implemented. Please check back later.";super(e),Z(this,"name","NotYetImplementedError")}}class ki extends re{constructor(e){const t=`A switch statement is not handling the provided case [${e}]. Check your inputs or raise an issue to have ensure all cases are handled properly.`;super(t),Z(this,"name","UnreachableCaseError")}}var tt=rs.exports.Buffer;function bs(o){if(o.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),t=0;t<e.length;t++)e[t]=255;for(var r=0;r<o.length;r++){var s=o.charAt(r),n=s.charCodeAt(0);if(e[n]!==255)throw new TypeError(s+" is ambiguous");e[n]=r}var i=o.length,a=o.charAt(0),c=Math.log(i)/Math.log(256),l=Math.log(256)/Math.log(i);function g(d){if((Array.isArray(d)||d instanceof Uint8Array)&&(d=tt.from(d)),!tt.isBuffer(d))throw new TypeError("Expected Buffer");if(d.length===0)return"";for(var p=0,h=0,y=0,_=d.length;y!==_&&d[y]===0;)y++,p++;for(var I=(_-y)*l+1>>>0,b=new Uint8Array(I);y!==_;){for(var K=d[y],E=0,N=I-1;(K!==0||E<h)&&N!==-1;N--,E++)K+=256*b[N]>>>0,b[N]=K%i>>>0,K=K/i>>>0;if(K!==0)throw new Error("Non-zero carry");h=E,y++}for(var B=I-h;B!==I&&b[B]===0;)B++;for(var O=a.repeat(p);B<I;++B)O+=o.charAt(b[B]);return O}function m(d){if(typeof d!="string")throw new TypeError("Expected String");if(d.length===0)return tt.alloc(0);for(var p=0,h=0,y=0;d[p]===a;)h++,p++;for(var _=(d.length-p)*c+1>>>0,I=new Uint8Array(_);d[p];){var b=e[d.charCodeAt(p)];if(b===255)return;for(var K=0,E=_-1;(b!==0||K<y)&&E!==-1;E--,K++)b+=i*I[E]>>>0,I[E]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");y=K,p++}for(var N=_-y;N!==_&&I[N]===0;)N++;var B=tt.allocUnsafe(h+(_-N));B.fill(0,0,h);for(var O=h;N!==_;)B[O++]=I[N++];return B}function P(d){var p=m(d);if(p)return p;throw new Error("Non-base"+i+" character")}return{encode:g,decodeUnsafe:m,decode:P}}var ks=bs,Ss=ks,ws="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",ee=Ss(ws);class Is extends TypeError{constructor(e,t){let r;const{message:s,...n}=e,{path:i}=e,a=i.length===0?s:"At path: "+i.join(".")+" -- "+s;super(a),Object.assign(this,n),this.name=this.constructor.name,this.failures=()=>{var c;return(c=r)!=null?c:r=[e,...t()]}}}function _s(o){return we(o)&&typeof o[Symbol.iterator]=="function"}function we(o){return typeof o=="object"&&o!=null}function he(o){return typeof o=="string"?JSON.stringify(o):""+o}function As(o){const{done:e,value:t}=o.next();return e?void 0:t}function Rs(o,e,t,r){if(o===!0)return;o===!1?o={}:typeof o=="string"&&(o={message:o});const{path:s,branch:n}=e,{type:i}=t,{refinement:a,message:c="Expected a value of type `"+i+"`"+(a?" with refinement `"+a+"`":"")+", but received: `"+he(r)+"`"}=o;return{value:r,type:i,refinement:a,key:s[s.length-1],path:s,branch:n,...o,message:c}}function*Yt(o,e,t,r){_s(o)||(o=[o]);for(const s of o){const n=Rs(s,e,t,r);n&&(yield n)}}function*Tt(o,e,t={}){const{path:r=[],branch:s=[o],coerce:n=!1,mask:i=!1}=t,a={path:r,branch:s};if(n&&(o=e.coercer(o,a),i&&e.type!=="type"&&we(e.schema)&&we(o)&&!Array.isArray(o)))for(const l in o)e.schema[l]===void 0&&delete o[l];let c=!0;for(const l of e.validator(o,a))c=!1,yield[l,void 0];for(let[l,g,m]of e.entries(o,a)){const P=Tt(g,m,{path:l===void 0?r:[...r,l],branch:l===void 0?s:[...s,g],coerce:n,mask:i});for(const d of P)d[0]?(c=!1,yield[d[0],void 0]):n&&(g=d[1],l===void 0?o=g:o instanceof Map?o.set(l,g):o instanceof Set?o.add(g):we(o)&&(o[l]=g))}if(c)for(const l of e.refiner(o,a))c=!1,yield[l,void 0];c&&(yield[void 0,o])}class me{constructor(e){const{type:t,schema:r,validator:s,refiner:n,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=r,this.entries=a,this.coercer=i,s?this.validator=(c,l)=>{const g=s(c,l);return Yt(g,l,this,c)}:this.validator=()=>[],n?this.refiner=(c,l)=>{const g=n(c,l);return Yt(g,l,this,c)}:this.refiner=()=>[]}assert(e){return Ir(e,this)}create(e){return w(e,this)}is(e){return _r(e,this)}mask(e){return Es(e,this)}validate(e,t={}){return Ye(e,this,t)}}function Ir(o,e){const t=Ye(o,e);if(t[0])throw t[0]}function w(o,e){const t=Ye(o,e,{coerce:!0});if(t[0])throw t[0];return t[1]}function Es(o,e){const t=Ye(o,e,{coerce:!0,mask:!0});if(t[0])throw t[0];return t[1]}function _r(o,e){return!Ye(o,e)[0]}function Ye(o,e,t={}){const r=Tt(o,e,t),s=As(r);if(s[0])return[new Is(s[0],function*(){for(const i of r)i[0]&&(yield i[0])}),void 0];{const n=s[1];return[void 0,n]}}function Te(o,e){return new me({type:o,schema:null,validator:e})}function Ps(){return Te("any",()=>!0)}function A(o){return new me({type:"array",schema:o,*entries(e){if(o&&Array.isArray(e))for(const[t,r]of e.entries())yield[t,r,o]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||"Expected an array value, but received: "+he(e)}})}function ye(){return Te("boolean",o=>typeof o=="boolean")}function Bt(o){return Te("instance",e=>e instanceof o||"Expected a `"+o.name+"` instance, but received: "+he(e))}function Y(o){const e=he(o),t=typeof o;return new me({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?o:null,validator(r){return r===o||"Expected the literal `"+e+"`, but received: "+he(r)}})}function vs(){return Te("never",()=>!1)}function R(o){return new me({...o,validator:(e,t)=>e===null||o.validator(e,t),refiner:(e,t)=>e===null||o.refiner(e,t)})}function u(){return Te("number",o=>typeof o=="number"&&!isNaN(o)||"Expected a number, but received: "+he(o))}function L(o){return new me({...o,validator:(e,t)=>e===void 0||o.validator(e,t),refiner:(e,t)=>e===void 0||o.refiner(e,t)})}function Ar(o,e){return new me({type:"record",schema:null,*entries(t){if(we(t))for(const r in t){const s=t[r];yield[r,r,o],yield[r,s,e]}},validator(t){return we(t)||"Expected an object, but received: "+he(t)}})}function k(){return Te("string",o=>typeof o=="string"||"Expected a string, but received: "+he(o))}function Ct(o){const e=vs();return new me({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const r=Math.max(o.length,t.length);for(let s=0;s<r;s++)yield[s,t[s],o[s]||e]}},validator(t){return Array.isArray(t)||"Expected an array, but received: "+he(t)}})}function f(o){const e=Object.keys(o);return new me({type:"type",schema:o,*entries(t){if(we(t))for(const r of e)yield[r,t[r],o[r]]},validator(t){return we(t)||"Expected an object, but received: "+he(t)}})}function ae(o){const e=o.map(t=>t.type).join(" | ");return new me({type:"union",schema:null,validator(t,r){const s=[];for(const n of o){const[...i]=Tt(t,n,r),[a]=i;if(a[0])for(const[c]of i)c&&s.push(c);else return[]}return["Expected the value to satisfy a union of `"+e+"`, but received: "+he(t),...s]}})}function Je(){return Te("unknown",()=>!0)}function Xe(o,e,t){return new me({...o,coercer:(r,s)=>_r(r,e)?o.coercer(t(r,s),s):o.coercer(r,s)})}const Ts=hr.v4,Bs=function(o,e,t,r){if(typeof o!="string")throw new TypeError(o+" must be a string");r=r||{};const s=typeof r.version=="number"?r.version:2;if(s!==1&&s!==2)throw new TypeError(s+" must be 1 or 2");const n={method:o};if(s===2&&(n.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");n.params=e}if(typeof t>"u"){const i=typeof r.generator=="function"?r.generator:function(){return Ts()};n.id=i(n,r)}else s===2&&t===null?r.notificationIdNull&&(n.id=null):n.id=t;return n};var Cs=Bs;const xs=hr.v4,Ls=Cs,He=function(o,e){if(!(this instanceof He))return new He(o,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return xs()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=o};var Ns=He;He.prototype.request=function(o,e,t,r){const s=this;let n=null;const i=Array.isArray(o)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&o&&typeof o=="object"&&typeof e=="function")r=e,n=o;else{typeof t=="function"&&(r=t,t=void 0);const l=typeof r=="function";try{n=Ls(o,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(g){if(l)return r(g);throw g}if(!l)return n}let c;try{c=JSON.stringify(n,this.options.replacer)}catch(l){return r(l)}return this.callServer(c,function(l,g){s._parseResponse(l,g,r)}),n};He.prototype._parseResponse=function(o,e,t){if(o){t(o);return}if(!e)return t();let r;try{r=JSON.parse(e,this.options.reviver)}catch(s){return t(s)}if(t.length===3)if(Array.isArray(r)){const s=function(i){return typeof i.error<"u"},n=function(i){return!s(i)};return t(null,r.filter(s),r.filter(n))}else return t(null,r.error,r.result);t(null,r)};var Rr={};(function(o){var e=br.exports;Object.defineProperty(o,"__esModule",{value:!0}),o.default=void 0;var t=e(ss),r=e(ns.exports),s=e(os.exports),n=e(fr.exports),i=e(pr.exports),a=e(gr.exports),c=e(yr.exports),l=e(mr.exports),g=kr.exports;function m(h){var y=P();return function(){var I=(0,l.default)(h),b;if(y){var K=(0,l.default)(this).constructor;b=Reflect.construct(I,arguments,K)}else b=I.apply(this,arguments);return(0,c.default)(this,b)}}function P(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var d=function(h,y){var _={};for(var I in h)Object.prototype.hasOwnProperty.call(h,I)&&y.indexOf(I)<0&&(_[I]=h[I]);if(h!=null&&typeof Object.getOwnPropertySymbols=="function")for(var b=0,I=Object.getOwnPropertySymbols(h);b<I.length;b++)y.indexOf(I[b])<0&&Object.prototype.propertyIsEnumerable.call(h,I[b])&&(_[I[b]]=h[I[b]]);return _},p=function(h){(0,a.default)(_,h);var y=m(_);function _(I){var b,K=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"ws://localhost:8080",E=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},N=arguments.length>3?arguments[3]:void 0;(0,n.default)(this,_);var B=E.autoconnect,O=B===void 0?!0:B,oe=E.reconnect,_e=oe===void 0?!0:oe,Qe=E.reconnect_interval,et=Qe===void 0?1e3:Qe,Ht=E.max_reconnects,es=Ht===void 0?5:Ht,ts=d(E,["autoconnect","reconnect","reconnect_interval","max_reconnects"]);return b=y.call(this),b.webSocketFactory=I,b.queue={},b.rpc_id=0,b.address=K,b.autoconnect=O,b.ready=!1,b.reconnect=_e,b.reconnect_timer_id=void 0,b.reconnect_interval=et,b.max_reconnects=es,b.rest_options=ts,b.current_reconnects=0,b.generate_request_id=N||function(){return++b.rpc_id},b.autoconnect&&b._connect(b.address,Object.assign({autoconnect:b.autoconnect,reconnect:b.reconnect,reconnect_interval:b.reconnect_interval,max_reconnects:b.max_reconnects},b.rest_options)),b}return(0,i.default)(_,[{key:"connect",value:function(){this.socket||this._connect(this.address,Object.assign({autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects},this.rest_options))}},{key:"call",value:function(b,K,E,N){var B=this;return!N&&(0,s.default)(E)==="object"&&(N=E,E=null),new Promise(function(O,oe){if(!B.ready)return oe(new Error("socket not ready"));var _e=B.generate_request_id(b,K),Qe={jsonrpc:"2.0",method:b,params:K||null,id:_e};B.socket.send(JSON.stringify(Qe),N,function(et){if(et)return oe(et);B.queue[_e]={promise:[O,oe]},E&&(B.queue[_e].timeout=setTimeout(function(){delete B.queue[_e],oe(new Error("reply timeout"))},E))})})}},{key:"login",value:function(){var I=(0,r.default)(t.default.mark(function K(E){var N;return t.default.wrap(function(O){for(;;)switch(O.prev=O.next){case 0:return O.next=2,this.call("rpc.login",E);case 2:if(N=O.sent,N){O.next=5;break}throw new Error("authentication failed");case 5:return O.abrupt("return",N);case 6:case"end":return O.stop()}},K,this)}));function b(K){return I.apply(this,arguments)}return b}()},{key:"listMethods",value:function(){var I=(0,r.default)(t.default.mark(function K(){return t.default.wrap(function(N){for(;;)switch(N.prev=N.next){case 0:return N.next=2,this.call("__listMethods");case 2:return N.abrupt("return",N.sent);case 3:case"end":return N.stop()}},K,this)}));function b(){return I.apply(this,arguments)}return b}()},{key:"notify",value:function(b,K){var E=this;return new Promise(function(N,B){if(!E.ready)return B(new Error("socket not ready"));var O={jsonrpc:"2.0",method:b,params:K||null};E.socket.send(JSON.stringify(O),function(oe){if(oe)return B(oe);N()})})}},{key:"subscribe",value:function(){var I=(0,r.default)(t.default.mark(function K(E){var N;return t.default.wrap(function(O){for(;;)switch(O.prev=O.next){case 0:return typeof E=="string"&&(E=[E]),O.next=3,this.call("rpc.on",E);case 3:if(N=O.sent,!(typeof E=="string"&&N[E]!=="ok")){O.next=6;break}throw new Error("Failed subscribing to an event '"+E+"' with: "+N[E]);case 6:return O.abrupt("return",N);case 7:case"end":return O.stop()}},K,this)}));function b(K){return I.apply(this,arguments)}return b}()},{key:"unsubscribe",value:function(){var I=(0,r.default)(t.default.mark(function K(E){var N;return t.default.wrap(function(O){for(;;)switch(O.prev=O.next){case 0:return typeof E=="string"&&(E=[E]),O.next=3,this.call("rpc.off",E);case 3:if(N=O.sent,!(typeof E=="string"&&N[E]!=="ok")){O.next=6;break}throw new Error("Failed unsubscribing from an event with: "+N);case 6:return O.abrupt("return",N);case 7:case"end":return O.stop()}},K,this)}));function b(K){return I.apply(this,arguments)}return b}()},{key:"close",value:function(b,K){this.socket.close(b||1e3,K)}},{key:"_connect",value:function(b,K){var E=this;clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(b,K),this.socket.addEventListener("open",function(){E.ready=!0,E.emit("open"),E.current_reconnects=0}),this.socket.addEventListener("message",function(N){var B=N.data;B instanceof ArrayBuffer&&(B=is.Buffer.from(B).toString());try{B=JSON.parse(B)}catch{return}if(B.notification&&E.listeners(B.notification).length){if(!Object.keys(B.params).length)return E.emit(B.notification);var O=[B.notification];if(B.params.constructor===Object)O.push(B.params);else for(var oe=0;oe<B.params.length;oe++)O.push(B.params[oe]);return Promise.resolve().then(function(){E.emit.apply(E,O)})}if(!E.queue[B.id])return B.method&&B.params?Promise.resolve().then(function(){E.emit(B.method,B.params)}):void 0;"error"in B=="result"in B&&E.queue[B.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),E.queue[B.id].timeout&&clearTimeout(E.queue[B.id].timeout),B.error?E.queue[B.id].promise[1](B.error):E.queue[B.id].promise[0](B.result),delete E.queue[B.id]}),this.socket.addEventListener("error",function(N){return E.emit("error",N)}),this.socket.addEventListener("close",function(N){var B=N.code,O=N.reason;E.ready&&setTimeout(function(){return E.emit("close",B,O)},0),E.ready=!1,E.socket=void 0,B!==1e3&&(E.current_reconnects++,E.reconnect&&(E.max_reconnects>E.current_reconnects||E.max_reconnects===0)&&(E.reconnect_timer_id=setTimeout(function(){return E._connect(b,K)},E.reconnect_interval)))})}}]),_}(g.EventEmitter);o.default=p})(Rr);var Ks=Sr(Rr),Er={};(function(o){var e=br.exports;Object.defineProperty(o,"__esModule",{value:!0}),o.default=m;var t=e(fr.exports),r=e(pr.exports),s=e(gr.exports),n=e(yr.exports),i=e(mr.exports),a=kr.exports;function c(P){var d=l();return function(){var h=(0,i.default)(P),y;if(d){var _=(0,i.default)(this).constructor;y=Reflect.construct(h,arguments,_)}else y=h.apply(this,arguments);return(0,n.default)(this,y)}}function l(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if(typeof Proxy=="function")return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}var g=function(P){(0,s.default)(p,P);var d=c(p);function p(h,y,_){var I;return(0,t.default)(this,p),I=d.call(this),I.socket=new window.WebSocket(h,_),I.socket.onopen=function(){return I.emit("open")},I.socket.onmessage=function(b){return I.emit("message",b.data)},I.socket.onerror=function(b){return I.emit("error",b)},I.socket.onclose=function(b){I.emit("close",b.code,b.reason)},I}return(0,r.default)(p,[{key:"send",value:function(y,_,I){var b=I||_;try{this.socket.send(y),b()}catch(K){b(K)}}},{key:"close",value:function(y,_){this.socket.close(y,_)}},{key:"addEventListener",value:function(y,_,I){this.socket.addEventListener(y,_,I)}}]),p}(a.EventEmitter);function m(P,d){return new g(P,d)}})(Er);var Os=Sr(Er);const zs=We.utils.randomPrivateKey,Jt=()=>{const o=We.utils.randomPrivateKey(),e=ot(o),t=new Uint8Array(64);return t.set(o),t.set(e,32),{publicKey:e,secretKey:t}},ot=We.getPublicKey;function Xt(o){try{return We.ExtendedPoint.fromHex(o),!0}catch{return!1}}const xt=(o,e)=>We.sign(o,e.slice(0,32)),Ws=We.verify,W=o=>x.Buffer.isBuffer(o)?o:o instanceof Uint8Array?x.Buffer.from(o.buffer,o.byteOffset,o.byteLength):x.Buffer.from(o);class Lt{constructor(e){Object.assign(this,e)}encode(){return x.Buffer.from(as($e,this))}static decode(e){return cs($e,this,e)}static decodeUnchecked(e){return us($e,this,e)}}class Us extends Lt{constructor(e){if(super(e),this.enum="",Object.keys(e).length!==1)throw new Error("Enum can only take single value");Object.keys(e).map(t=>{this.enum=t})}}const $e=new Map;var Pr;let vr;const Tr=32,ue=32;function Ds(o){return o._bn!==void 0}let Zt=1;vr=Symbol.toStringTag;class S extends Lt{constructor(e){if(super({}),this._bn=void 0,Ds(e))this._bn=e._bn;else{if(typeof e=="string"){const t=ee.decode(e);if(t.length!=ue)throw new Error("Invalid public key input");this._bn=new Fe(t)}else this._bn=new Fe(e);if(this._bn.byteLength()>ue)throw new Error("Invalid public key input")}}static unique(){const e=new S(Zt);return Zt+=1,new S(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return ee.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(x.Buffer);if(e.length===ue)return e;const t=x.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[vr](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const s=x.Buffer.concat([e.toBuffer(),x.Buffer.from(t),r.toBuffer()]),n=Gt(s);return new S(n)}static createProgramAddressSync(e,t){let r=x.Buffer.alloc(0);e.forEach(function(n){if(n.length>Tr)throw new TypeError("Max seed length exceeded");r=x.Buffer.concat([r,W(n)])}),r=x.Buffer.concat([r,t.toBuffer(),x.Buffer.from("ProgramDerivedAddress")]);const s=Gt(r);if(Xt(s))throw new Error("Invalid seeds, address must fall off the curve");return new S(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r=255,s;for(;r!=0;){try{const n=e.concat(x.Buffer.from([r]));s=this.createProgramAddressSync(n,t)}catch(n){if(n instanceof TypeError)throw n;r--;continue}return[s,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new S(e);return Xt(t.toBytes())}}Pr=S;S.default=new Pr("11111111111111111111111111111111");$e.set(S,{kind:"struct",fields:[["_bn","u256"]]});class qs{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=W(e);if(e.length!==64)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=W(zs()),this._publicKey=W(ot(this._secretKey))}get publicKey(){return new S(this._publicKey)}get secretKey(){return x.Buffer.concat([this._secretKey,this._publicKey],64)}}const Ms=new S("BPFLoader1111111111111111111111111111111111"),Ie=1280-40-8,ct=127,Ke=64;class Nt extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Nt.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Kt extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Kt.prototype,"name",{value:"TransactionExpiredTimeoutError"});class xe extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(xe.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class Ge{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((n,i)=>{r.set(n.toBase58(),i)});const s=n=>{const i=r.get(n.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(n=>({programIdIndex:s(n.programId),accountKeyIndexes:n.keys.map(i=>s(i.pubkey)),data:n.data}))}}const U=(o="publicKey")=>j(32,o),$s=(o="signature")=>j(64,o),Re=(o="string")=>{const e=v([T("length"),T("lengthPadding"),j(Ee(T(),-8),"chars")],o),t=e.decode.bind(e),r=e.encode.bind(e),s=e;return s.decode=(n,i)=>t(n,i).chars.toString(),s.encode=(n,i,a)=>{const c={chars:x.Buffer.from(n,"utf8")};return r(c,i,a)},s.alloc=n=>T().span+T().span+x.Buffer.from(n,"utf8").length,s},Fs=(o="authorized")=>v([U("staker"),U("withdrawer")],o),Vs=(o="lockup")=>v([le("unixTimestamp"),le("epoch"),U("custodian")],o),Hs=(o="voteInit")=>v([U("nodePubkey"),U("authorizedVoter"),U("authorizedWithdrawer"),M("commission")],o),Gs=(o="voteAuthorizeWithSeedArgs")=>v([T("voteAuthorizationType"),U("currentAuthorityDerivedKeyOwnerPubkey"),Re("currentAuthorityDerivedKeySeed"),U("newAuthorized")],o);function Br(o,e){const t=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(e[s.property]);if("count"in s&&"elementLayout"in s){const n=e[s.property];if(Array.isArray(n))return n.length*t(s.elementLayout)}else if("fields"in s)return Br({layout:s},e[s.property]);return 0};let r=0;return o.layout.fields.forEach(s=>{r+=t(s)}),r}function ie(o){let e=0,t=0;for(;;){let r=o.shift();if(e|=(r&127)<<t*7,t+=1,(r&128)===0)break}return e}function ce(o,e){let t=e;for(;;){let r=t&127;if(t>>=7,t==0){o.push(r);break}else r|=128,o.push(r)}}function q(o,e){if(!o)throw new Error(e||"Assertion failed")}class ut{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,s=i=>{const a=i.toBase58();let c=r.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(a,c)),c},n=s(t);n.isSigner=!0,n.isWritable=!0;for(const i of e){s(i.programId).isInvoked=!0;for(const a of i.keys){const c=s(a.pubkey);c.isSigner||=a.isSigner,c.isWritable||=a.isWritable}}return new ut(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];q(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),r=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),n=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:n.length};{q(t.length>0,"Expected at least one writable signer key");const[c]=t[0];q(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new S(c)),...r.map(([c])=>new S(c)),...s.map(([c])=>new S(c)),...n.map(([c])=>new S(c))];return[i,a]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:r,readonly:n}]}drainKeysFoundInLookupTable(e,t){const r=new Array,s=new Array;for(const[n,i]of this.keyMetaMap.entries())if(t(i)){const a=new S(n),c=e.findIndex(l=>l.equals(a));c>=0&&(q(c<256,"Max lookup table index exceeded"),r.push(c),s.push(a),this.keyMetaMap.delete(n))}return[r,s]}}class fe{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new S(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:ee.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Ge(this.staticAccountKeys)}static compile(e){const t=ut.compile(e.instructions,e.payerKey),[r,s]=t.getMessageComponents(),i=new Ge(s).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:ee.encode(a.data)}));return new fe({header:r,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const r=e-t,n=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return r<n}else{const r=t-this.header.numReadonlySignedAccounts;return e<r}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];ce(t,e);const r=this.instructions.map(m=>{const{accounts:P,programIdIndex:d}=m,p=Array.from(ee.decode(m.data));let h=[];ce(h,P.length);let y=[];return ce(y,p.length),{programIdIndex:d,keyIndicesCount:x.Buffer.from(h),keyIndices:P,dataLength:x.Buffer.from(y),data:p}});let s=[];ce(s,r.length);let n=x.Buffer.alloc(Ie);x.Buffer.from(s).copy(n);let i=s.length;r.forEach(m=>{i+=v([M("programIdIndex"),j(m.keyIndicesCount.length,"keyIndicesCount"),ne(M("keyIndex"),m.keyIndices.length,"keyIndices"),j(m.dataLength.length,"dataLength"),ne(M("userdatum"),m.data.length,"data")]).encode(m,n,i)}),n=n.slice(0,i);const a=v([j(1,"numRequiredSignatures"),j(1,"numReadonlySignedAccounts"),j(1,"numReadonlyUnsignedAccounts"),j(t.length,"keyCount"),ne(U("key"),e,"keys"),U("recentBlockhash")]),c={numRequiredSignatures:x.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:x.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:x.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:x.Buffer.from(t),keys:this.accountKeys.map(m=>W(m.toBytes())),recentBlockhash:ee.decode(this.recentBlockhash)};let l=x.Buffer.alloc(2048);const g=a.encode(c,l);return n.copy(l,g),l.slice(0,g+n.length)}static from(e){let t=[...e];const r=t.shift();if(r!==(r&ct))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=t.shift(),n=t.shift(),i=ie(t);let a=[];for(let P=0;P<i;P++){const d=t.slice(0,ue);t=t.slice(ue),a.push(new S(x.Buffer.from(d)))}const c=t.slice(0,ue);t=t.slice(ue);const l=ie(t);let g=[];for(let P=0;P<l;P++){const d=t.shift(),p=ie(t),h=t.slice(0,p);t=t.slice(p);const y=ie(t),_=t.slice(0,y),I=ee.encode(x.Buffer.from(_));t=t.slice(y),g.push({programIdIndex:d,accounts:h,data:I})}const m={header:{numRequiredSignatures:r,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:n},recentBlockhash:ee.encode(x.Buffer.from(c)),accountKeys:a,instructions:g};return new fe(m)}}class Pe{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Ge(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){const s=e-r,n=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return s<n}else if(e>=this.header.numRequiredSignatures){const s=e-t,i=r-t-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const s=e.find(n=>n.key.equals(r.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const n of r.writableIndexes)if(n<s.state.addresses.length)t.writable.push(s.state.addresses[n]);else throw new Error(`Failed to find address for index ${n} in address lookup table ${r.accountKey.toBase58()}`);for(const n of r.readonlyIndexes)if(n<s.state.addresses.length)t.readonly.push(s.state.addresses[n]);else throw new Error(`Failed to find address for index ${n} in address lookup table ${r.accountKey.toBase58()}`)}return t}static compile(e){const t=ut.compile(e.instructions,e.payerKey),r=new Array,s={writable:new Array,readonly:new Array},n=e.addressLookupTableAccounts||[];for(const g of n){const m=t.extractTableLookup(g);if(m!==void 0){const[P,{writable:d,readonly:p}]=m;r.push(P),s.writable.push(...d),s.readonly.push(...p)}}const[i,a]=t.getMessageComponents(),l=new Ge(a,s).compileInstructions(e.instructions);return new Pe({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:l,addressTableLookups:r})}serialize(){const e=Array();ce(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();ce(r,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),n=Array();ce(n,this.addressTableLookups.length);const i=v([M("prefix"),v([M("numRequiredSignatures"),M("numReadonlySignedAccounts"),M("numReadonlyUnsignedAccounts")],"header"),j(e.length,"staticAccountKeysLength"),ne(U(),this.staticAccountKeys.length,"staticAccountKeys"),U("recentBlockhash"),j(r.length,"instructionsLength"),j(t.length,"serializedInstructions"),j(n.length,"addressTableLookupsLength"),j(s.length,"serializedAddressTableLookups")]),a=new Uint8Array(Ie),c=1<<7,l=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(g=>g.toBytes()),recentBlockhash:ee.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(n),serializedAddressTableLookups:s},a);return a.slice(0,l)}serializeInstructions(){let e=0;const t=new Uint8Array(Ie);for(const r of this.compiledInstructions){const s=Array();ce(s,r.accountKeyIndexes.length);const n=Array();ce(n,r.data.length),e+=v([M("programIdIndex"),j(s.length,"encodedAccountKeyIndexesLength"),ne(M(),r.accountKeyIndexes.length,"accountKeyIndexes"),j(n.length,"encodedDataLength"),j(r.data.length,"data")]).encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(n),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(Ie);for(const r of this.addressTableLookups){const s=Array();ce(s,r.writableIndexes.length);const n=Array();ce(n,r.readonlyIndexes.length),e+=v([U("accountKey"),j(s.length,"encodedWritableIndexesLength"),ne(M(),r.writableIndexes.length,"writableIndexes"),j(n.length,"encodedReadonlyIndexesLength"),ne(M(),r.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(n),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=t.shift(),s=r&ct;q(r!==s,"Expected versioned message but received legacy message");const n=s;q(n===0,`Expected versioned message with version 0 but found version ${n}`);const i={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},a=[],c=ie(t);for(let p=0;p<c;p++)a.push(new S(t.splice(0,ue)));const l=ee.encode(t.splice(0,ue)),g=ie(t),m=[];for(let p=0;p<g;p++){const h=t.shift(),y=ie(t),_=t.splice(0,y),I=ie(t),b=new Uint8Array(t.splice(0,I));m.push({programIdIndex:h,accountKeyIndexes:_,data:b})}const P=ie(t),d=[];for(let p=0;p<P;p++){const h=new S(t.splice(0,ue)),y=ie(t),_=t.splice(0,y),I=ie(t),b=t.splice(0,I);d.push({accountKey:h,writableIndexes:_,readonlyIndexes:b})}return new Pe({header:i,staticAccountKeys:a,recentBlockhash:l,compiledInstructions:m,addressTableLookups:d})}}const Ot={deserializeMessageVersion(o){const e=o[0],t=e&ct;return t===e?"legacy":t},deserialize:o=>{const e=Ot.deserializeMessageVersion(o);if(e==="legacy")return fe.from(o);if(e===0)return Pe.deserialize(o);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let be=function(o){return o[o.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",o[o.PROCESSED=1]="PROCESSED",o[o.TIMED_OUT=2]="TIMED_OUT",o[o.NONCE_INVALID=3]="NONCE_INVALID",o}({});const js=x.Buffer.alloc(Ke).fill(0);class V{constructor(e){this.keys=void 0,this.programId=void 0,this.data=x.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class F{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new V(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let h=0;h<t.length;h++)if(t[h].programId===void 0)throw new Error(`Transaction instruction index ${h} has undefined program id`);const s=[],n=[];t.forEach(h=>{h.keys.forEach(_=>{n.push({..._})});const y=h.programId.toString();s.includes(y)||s.push(y)}),s.forEach(h=>{n.push({pubkey:new S(h),isSigner:!1,isWritable:!1})});const i=[];n.forEach(h=>{const y=h.pubkey.toString(),_=i.findIndex(I=>I.pubkey.toString()===y);_>-1?(i[_].isWritable=i[_].isWritable||h.isWritable,i[_].isSigner=i[_].isSigner||h.isSigner):i.push(h)}),i.sort(function(h,y){if(h.isSigner!==y.isSigner)return h.isSigner?-1:1;if(h.isWritable!==y.isWritable)return h.isWritable?-1:1;const _={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return h.pubkey.toBase58().localeCompare(y.pubkey.toBase58(),"en",_)});const a=i.findIndex(h=>h.pubkey.equals(r));if(a>-1){const[h]=i.splice(a,1);h.isSigner=!0,h.isWritable=!0,i.unshift(h)}else i.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const h of this.signatures){const y=i.findIndex(_=>_.pubkey.equals(h.publicKey));if(y>-1)i[y].isSigner||(i[y].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${h.publicKey.toString()}`)}let c=0,l=0,g=0;const m=[],P=[];i.forEach(({pubkey:h,isSigner:y,isWritable:_})=>{y?(m.push(h.toString()),c+=1,_||(l+=1)):(P.push(h.toString()),_||(g+=1))});const d=m.concat(P),p=t.map(h=>{const{data:y,programId:_}=h;return{programIdIndex:d.indexOf(_.toString()),accounts:h.keys.map(I=>d.indexOf(I.pubkey.toString())),data:ee.encode(y)}});return p.forEach(h=>{q(h.programIdIndex>=0),h.accounts.forEach(y=>q(y>=0))}),new fe({header:{numRequiredSignatures:c,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:g},accountKeys:d,recentBlockhash:e,instructions:p})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,n)=>t[n].equals(s.publicKey))||(this.signatures=t.map(r=>({signature:null,publicKey:r}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(r=>{const s=r.toString();return t.has(s)?!1:(t.add(s),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const i=n.publicKey.toString();t.has(i)||(t.add(i),r.push(n))}this.signatures=r.map(n=>({signature:null,publicKey:n.publicKey}));const s=this._compile();this._partialSign(s,...r)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const n of e){const i=n.publicKey.toString();t.has(i)||(t.add(i),r.push(n))}const s=this._compile();this._partialSign(s,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach(s=>{const n=xt(r,s.secretKey);this._addSignature(s.publicKey,W(n))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){q(t.length===64);const r=this.signatures.findIndex(s=>e.equals(s.publicKey));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=x.Buffer.from(t)}verifySignatures(e){return this._verifySignatures(this.serializeMessage(),e===void 0?!0:e)}_verifySignatures(e,t){for(const{signature:r,publicKey:s}of this.signatures)if(r===null){if(t)return!1}else if(!Ws(r,e,s.toBytes()))return!1;return!0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(r&&!this._verifySignatures(s,t))throw new Error("Signature verification failed");return this._serialize(s)}_serialize(e){const{signatures:t}=this,r=[];ce(r,t.length);const s=r.length+t.length*64+e.length,n=x.Buffer.alloc(s);return q(t.length<256),x.Buffer.from(r).copy(n,0),t.forEach(({signature:i},a)=>{i!==null&&(q(i.length===64,"signature has invalid length"),x.Buffer.from(i).copy(n,r.length+a*64))}),e.copy(n,r.length+t.length*64),q(n.length<=Ie,`Transaction too large: ${n.length} > ${Ie}`),n}get keys(){return q(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return q(this.instructions.length===1),this.instructions[0].programId}get data(){return q(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const r=ie(t);let s=[];for(let n=0;n<r;n++){const i=t.slice(0,Ke);t=t.slice(Ke),s.push(ee.encode(x.Buffer.from(i)))}return F.populate(fe.from(t),s)}static populate(e,t=[]){const r=new F;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach((s,n)=>{const i={signature:s==ee.encode(js)?null:ee.decode(s),publicKey:e.accountKeys[n]};r.signatures.push(i)}),e.instructions.forEach(s=>{const n=s.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:r.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});r.instructions.push(new V({keys:n,programId:e.accountKeys[s.programIdIndex],data:ee.decode(s.data)}))}),r._message=e,r._json=r.toJSON(),r}}class zt{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:r,compiledInstructions:s,recentBlockhash:n}=e,{numRequiredSignatures:i,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:c}=r,l=i-a;q(l>0,"Message header is invalid");const g=e.staticAccountKeys.length-i-c;q(g>=0,"Message header is invalid");const m=e.getAccountKeys(t),P=m.get(0);if(P===void 0)throw new Error("Failed to decompile message because no account keys were found");const d=[];for(const p of s){const h=[];for(const _ of p.accountKeyIndexes){const I=m.get(_);if(I===void 0)throw new Error(`Failed to find key for account key index ${_}`);const b=_<i;let K;b?K=_<l:_<m.staticAccountKeys.length?K=_-i<g:K=_-m.staticAccountKeys.length<m.accountKeysFromLookups.writable.length,h.push({pubkey:I,isSigner:_<r.numRequiredSignatures,isWritable:K})}const y=m.get(p.programIdIndex);if(y===void 0)throw new Error(`Failed to find program id for program id index ${p.programIdIndex}`);d.push(new V({programId:y,data:W(p.data),keys:h}))}return new zt({payerKey:P,instructions:d,recentBlockhash:n})}compileToLegacyMessage(){return fe.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return Pe.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class Wt{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)q(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const r=[];for(let s=0;s<e.header.numRequiredSignatures;s++)r.push(new Uint8Array(Ke));this.signatures=r}this.message=e}serialize(){const e=this.message.serialize(),t=Array();ce(t,this.signatures.length);const r=v([j(t.length,"encodedSignaturesLength"),ne($s(),this.signatures.length,"signatures"),j(e.length,"serializedMessage")]),s=new Uint8Array(2048),n=r.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},s);return s.slice(0,n)}static deserialize(e){let t=[...e];const r=[],s=ie(t);for(let i=0;i<s;i++)r.push(new Uint8Array(t.splice(0,Ke)));const n=Ot.deserialize(new Uint8Array(t));return new Wt(n,r)}sign(e){const t=this.message.serialize(),r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const s of e){const n=r.findIndex(i=>i.equals(s.publicKey));q(n>=0,`Cannot sign with non signer key ${s.publicKey.toBase58()}`),this.signatures[n]=xt(t,s.secretKey)}}addSignature(e,t){q(t.byteLength===64,"Signature must be 64 bytes long");const s=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(n=>n.equals(e));q(s>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[s]=t}}const Ys=160,Js=64,Xs=Ys/Js,Cr=1e3/Xs,pe=new S("SysvarC1ock11111111111111111111111111111111"),Zs=new S("SysvarEpochSchedu1e111111111111111111111111"),Qs=new S("Sysvar1nstructions1111111111111111111111111"),st=new S("SysvarRecentB1ockHashes11111111111111111111"),Oe=new S("SysvarRent111111111111111111111111111111111"),en=new S("SysvarRewards111111111111111111111111111111"),tn=new S("SysvarS1otHashes111111111111111111111111111"),rn=new S("SysvarS1otHistory11111111111111111111111111"),nt=new S("SysvarStakeHistory1111111111111111111111111");async function wt(o,e,t,r){const s=r&&{skipPreflight:r.skipPreflight,preflightCommitment:r.preflightCommitment||r.commitment,maxRetries:r.maxRetries,minContextSlot:r.minContextSlot},n=await o.sendTransaction(e,t,s);let i;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)i=(await o.confirmTransaction({abortSignal:r==null?void 0:r.abortSignal,signature:n,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},r&&r.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){const{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;i=(await o.confirmTransaction({abortSignal:r==null?void 0:r.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:n},r&&r.commitment)).value}else(r==null?void 0:r.abortSignal)!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),i=(await o.confirmTransaction(n,r&&r.commitment)).value;if(i.err)throw new Error(`Transaction ${n} failed (${JSON.stringify(i)})`);return n}function Ae(o){return new Promise(e=>setTimeout(e,o))}function D(o,e){const t=o.layout.span>=0?o.layout.span:Br(o,e),r=x.Buffer.alloc(t),s=Object.assign({instruction:o.index},e);return o.layout.encode(s,r),r}function $(o,e){let t;try{t=o.layout.decode(e)}catch(r){throw new Error("invalid instruction; "+r)}if(t.instruction!==o.index)throw new Error(`invalid instruction; instruction index mismatch ${t.instruction} != ${o.index}`);return t}const xr=se("lamportsPerSignature"),Lr=v([T("version"),T("state"),U("authorizedPubkey"),U("nonce"),v([xr],"feeCalculator")]),It=Lr.span;class lt{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Lr.decode(W(e),0);return new lt({authorizedPubkey:new S(t.authorizedPubkey),nonce:new S(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const sn=o=>{const e=o.decode.bind(o),t=o.encode.bind(o);return{decode:e,encode:t}},nn=o=>e=>{const t=j(o,e),{encode:r,decode:s}=sn(t),n=t;return n.decode=(i,a)=>{const c=s(i,a);return ls(x.Buffer.from(c))},n.encode=(i,a,c)=>{const l=wr(i,o);return r(l,a,c)},n},ze=nn(8);class on{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=T("instruction").decode(e.data);let s;for(const[n,i]of Object.entries(H))if(i.index==r){s=n;break}if(!s)throw new Error("Instruction type incorrect; not a SystemInstruction");return s}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:r,programId:s}=$(H.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:r,programId:new S(s)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=$(H.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:r,programId:s}=$(H.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:r,programId:new S(s)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=$(H.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,space:s,programId:n}=$(H.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new S(t),seed:r,space:s,programId:new S(n)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=$(H.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new S(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:r,programId:s}=$(H.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new S(t),seed:r,programId:new S(s)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:r,lamports:s,space:n,programId:i}=$(H.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new S(t),seed:r,lamports:s,space:n,programId:new S(i)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=$(H.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new S(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),$(H.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=$(H.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=$(H.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new S(t)}}static checkProgramId(e){if(!e.equals(te.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const H=Object.freeze({Create:{index:0,layout:v([T("instruction"),le("lamports"),le("space"),U("programId")])},Assign:{index:1,layout:v([T("instruction"),U("programId")])},Transfer:{index:2,layout:v([T("instruction"),ze("lamports")])},CreateWithSeed:{index:3,layout:v([T("instruction"),U("base"),Re("seed"),le("lamports"),le("space"),U("programId")])},AdvanceNonceAccount:{index:4,layout:v([T("instruction")])},WithdrawNonceAccount:{index:5,layout:v([T("instruction"),le("lamports")])},InitializeNonceAccount:{index:6,layout:v([T("instruction"),U("authorized")])},AuthorizeNonceAccount:{index:7,layout:v([T("instruction"),U("authorized")])},Allocate:{index:8,layout:v([T("instruction"),le("space")])},AllocateWithSeed:{index:9,layout:v([T("instruction"),U("base"),Re("seed"),le("space"),U("programId")])},AssignWithSeed:{index:10,layout:v([T("instruction"),U("base"),Re("seed"),U("programId")])},TransferWithSeed:{index:11,layout:v([T("instruction"),ze("lamports"),Re("seed"),U("programId")])},UpgradeNonceAccount:{index:12,layout:v([T("instruction")])}});class te{constructor(){}static createAccount(e){const t=H.Create,r=D(t,{lamports:e.lamports,space:e.space,programId:W(e.programId.toBuffer())});return new V({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(e){let t,r;if("basePubkey"in e){const s=H.TransferWithSeed;t=D(s,{lamports:BigInt(e.lamports),seed:e.seed,programId:W(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=H.Transfer;t=D(s,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new V({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){const s=H.AssignWithSeed;t=D(s,{base:W(e.basePubkey.toBuffer()),seed:e.seed,programId:W(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=H.Assign;t=D(s,{programId:W(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new V({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=H.CreateWithSeed,r=D(t,{base:W(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:W(e.programId.toBuffer())});let s=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&s.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new V({keys:s,programId:this.programId,data:r})}static createNonceAccount(e){const t=new F;"basePubkey"in e&&"seed"in e?t.add(te.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:It,programId:this.programId})):t.add(te.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:It,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=H.InitializeNonceAccount,r=D(t,{authorized:W(e.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:st,isSigner:!1,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new V(s)}static nonceAdvance(e){const t=H.AdvanceNonceAccount,r=D(t),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:st,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new V(s)}static nonceWithdraw(e){const t=H.WithdrawNonceAccount,r=D(t,{lamports:e.lamports});return new V({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:st,isSigner:!1,isWritable:!1},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(e){const t=H.AuthorizeNonceAccount,r=D(t,{authorized:W(e.newAuthorizedPubkey.toBuffer())});return new V({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(e){let t,r;if("basePubkey"in e){const s=H.AllocateWithSeed;t=D(s,{base:W(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:W(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=H.Allocate;t=D(s,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new V({keys:r,programId:this.programId,data:t})}}te.programId=new S("11111111111111111111111111111111");const an=Ie-300;class ve{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/ve.chunkSize)+1+1)}static async load(e,t,r,s,n){{const m=await e.getMinimumBalanceForRentExemption(n.length),P=await e.getAccountInfo(r.publicKey,"confirmed");let d=null;if(P!==null){if(P.executable)return console.error("Program load failed, account is already executable"),!1;P.data.length!==n.length&&(d=d||new F,d.add(te.allocate({accountPubkey:r.publicKey,space:n.length}))),P.owner.equals(s)||(d=d||new F,d.add(te.assign({accountPubkey:r.publicKey,programId:s}))),P.lamports<m&&(d=d||new F,d.add(te.transfer({fromPubkey:t.publicKey,toPubkey:r.publicKey,lamports:m-P.lamports})))}else d=new F().add(te.createAccount({fromPubkey:t.publicKey,newAccountPubkey:r.publicKey,lamports:m>0?m:1,space:n.length,programId:s}));d!==null&&await wt(e,d,[t,r],{commitment:"confirmed"})}const i=v([T("instruction"),T("offset"),T("bytesLength"),T("bytesLengthPadding"),ne(M("byte"),Ee(T(),-8),"bytes")]),a=ve.chunkSize;let c=0,l=n,g=[];for(;l.length>0;){const m=l.slice(0,a),P=x.Buffer.alloc(a+16);i.encode({instruction:0,offset:c,bytes:m,bytesLength:0,bytesLengthPadding:0},P);const d=new F().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0}],programId:s,data:P});g.push(wt(e,d,[t,r],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await Ae(1e3/4),c+=a,l=l.slice(a)}await Promise.all(g);{const m=v([T("instruction")]),P=x.Buffer.alloc(m.span);m.encode({instruction:1},P);const d=new F().add({keys:[{pubkey:r.publicKey,isSigner:!0,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1}],programId:s,data:P}),p="processed",h=await e.sendTransaction(d,[t,r],{preflightCommitment:p}),{context:y,value:_}=await e.confirmTransaction({signature:h,lastValidBlockHeight:d.lastValidBlockHeight,blockhash:d.recentBlockhash},p);if(_.err)throw new Error(`Transaction ${h} failed (${JSON.stringify(_)})`);for(;;){try{if(await e.getSlot({commitment:p})>y.slot)break}catch{}await new Promise(I=>setTimeout(I,Math.round(Cr/2)))}}return!0}}ve.chunkSize=an;const cn=new S("BPFLoader2111111111111111111111111111111111");class un{static getMinNumSignatures(e){return ve.getMinNumSignatures(e)}static load(e,t,r,s,n){return ve.load(e,t,r,n,s)}}function ln(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}var dn=Object.prototype.toString,hn=Object.keys||function(o){var e=[];for(var t in o)e.push(t);return e};function Me(o,e){var t,r,s,n,i,a,c;if(o===!0)return"true";if(o===!1)return"false";switch(typeof o){case"object":if(o===null)return null;if(o.toJSON&&typeof o.toJSON=="function")return Me(o.toJSON(),e);if(c=dn.call(o),c==="[object Array]"){for(s="[",r=o.length-1,t=0;t<r;t++)s+=Me(o[t],!0)+",";return r>-1&&(s+=Me(o[t],!0)),s+"]"}else if(c==="[object Object]"){for(n=hn(o).sort(),r=n.length,s="",t=0;t<r;)i=n[t],a=Me(o[i],!1),a!==void 0&&(s&&(s+=","),s+=JSON.stringify(i)+":"+a),t++;return"{"+s+"}"}else return JSON.stringify(o);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(o);default:return isFinite(o)?o:null}}var fn=function(o){var e=Me(o,!1);if(e!==void 0)return""+e},Qt=ln(fn);const qe=32;function yt(o){let e=0;for(;o>1;)o/=2,e++;return e}function pn(o){return o===0?1:(o--,o|=o>>1,o|=o>>2,o|=o>>4,o|=o>>8,o|=o>>16,o|=o>>32,o+1)}class Nr{constructor(e,t,r,s,n){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=r,this.firstNormalEpoch=s,this.firstNormalSlot=n}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=yt(pn(e+qe+1))-yt(qe)-1,r=this.getSlotsInEpoch(t),s=e-(r-qe);return[t,s]}else{const t=e-this.firstNormalSlot,r=Math.floor(t/this.slotsPerEpoch),s=this.firstNormalEpoch+r,n=t%this.slotsPerEpoch;return[s,n]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*qe:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+yt(qe)):this.slotsPerEpoch}}class _t extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}const gn={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class C extends Error{constructor({code:e,message:t,data:r},s){super(s!=null?`${s}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=r,this.name="SolanaJSONRPCError"}}var yn=globalThis.fetch;class mn extends Ks{constructor(e,t,r){const s=n=>{const i=Os(n,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(s,e,t,r),this.underlyingSocket=void 0}call(...e){var r;const t=(r=this.underlyingSocket)==null?void 0:r.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var r;const t=(r=this.underlyingSocket)==null?void 0:r.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function bn(o,e){let t;try{t=o.layout.decode(e)}catch(r){throw new Error("invalid instruction; "+r)}if(t.typeIndex!==o.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${o.index}`);return t}const er=56;class At{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=bn(kn,e),r=e.length-er;q(r>=0,"lookup table is invalid"),q(r%32===0,"lookup table is invalid");const s=r/32,{addresses:n}=v([ne(U(),s,"addresses")]).decode(e.slice(er));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new S(t.authority[0]):void 0,addresses:n.map(i=>new S(i))}}}const kn={index:1,layout:v([T("typeIndex"),ze("deactivationSlot"),se("lastExtendedSlot"),M("lastExtendedStartIndex"),M(),ne(U(),Ee(M(),-1),"authority")])},Sn=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function wn(o){const e=o.match(Sn);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${o}\``);const[t,r,s,n]=e,i=o.startsWith("https:")?"wss:":"ws:",a=s==null?null:parseInt(s.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${r}${c}${n}`}const X=Xe(Bt(S),k(),o=>new S(o)),Kr=Ct([k(),Y("base64")]),Ut=Xe(Bt(x.Buffer),Kr,o=>x.Buffer.from(o[0],"base64")),Or=30*1e3;function In(o){if(/^https?:/.test(o)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return o}function G(o){let e,t;if(typeof o=="string")e=o;else if(o){const{commitment:r,...s}=o;e=r,t=s}return{commitment:e,config:t}}function zr(o){return ae([f({jsonrpc:Y("2.0"),id:k(),result:o}),f({jsonrpc:Y("2.0"),id:k(),error:f({code:Je(),message:k(),data:L(Ps())})})])}const _n=zr(Je());function z(o){return Xe(zr(o),_n,e=>"error"in e?e:{...e,result:w(e.result,o)})}function J(o){return z(f({context:f({slot:u()}),value:o}))}function dt(o){return f({context:f({slot:u()}),value:o})}function mt(o,e){return o===0?new Pe({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new S(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:ee.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new fe(e)}const An=f({foundation:u(),foundationTerm:u(),initial:u(),taper:u(),terminal:u()}),Rn=z(A(R(f({epoch:u(),effectiveSlot:u(),amount:u(),postBalance:u(),commission:L(R(u()))})))),En=A(f({slot:u(),prioritizationFee:u()})),Pn=f({total:u(),validator:u(),foundation:u(),epoch:u()}),vn=f({epoch:u(),slotIndex:u(),slotsInEpoch:u(),absoluteSlot:u(),blockHeight:L(u()),transactionCount:L(u())}),Tn=f({slotsPerEpoch:u(),leaderScheduleSlotOffset:u(),warmup:ye(),firstNormalEpoch:u(),firstNormalSlot:u()}),Bn=Ar(k(),A(u())),Be=R(ae([f({}),k()])),Cn=f({err:Be}),xn=Y("receivedSignature"),Ln=f({"solana-core":k(),"feature-set":L(u())}),tr=J(f({err:R(ae([f({}),k()])),logs:R(A(k())),accounts:L(R(A(R(f({executable:ye(),owner:k(),lamports:u(),data:A(k()),rentEpoch:L(u())}))))),unitsConsumed:L(u()),returnData:L(R(f({programId:k(),data:Ct([k(),Y("base64")])})))})),Nn=J(f({byIdentity:Ar(k(),A(u())),range:f({firstSlot:u(),lastSlot:u()})}));function Kn(o,e,t,r,s,n){const i=t||yn;let a;n!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return r&&(c=async(g,m)=>{const P=await new Promise((d,p)=>{try{r(g,m,(h,y)=>d([h,y]))}catch(h){p(h)}});return await i(...P)}),new Ns(async(g,m)=>{const P={method:"POST",body:g,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},zo)};try{let d=5,p,h=500;for(;c?p=await c(o,P):p=await i(o,P),!(p.status!==429||s===!0||(d-=1,d===0));)console.log(`Server responded with ${p.status} ${p.statusText}.  Retrying after ${h}ms delay...`),await Ae(h),h*=2;const y=await p.text();p.ok?m(null,y):m(new Error(`${p.status} ${p.statusText}: ${y}`))}catch(d){d instanceof Error&&m(d)}},{})}function On(o){return(e,t)=>new Promise((r,s)=>{o.request(e,t,(n,i)=>{if(n){s(n);return}r(i)})})}function zn(o){return e=>new Promise((t,r)=>{e.length===0&&t([]);const s=e.map(n=>o.request(n.methodName,n.args));o.request(s,(n,i)=>{if(n){r(n);return}t(i)})})}const Wn=z(An),Un=z(Pn),Dn=z(En),qn=z(vn),Mn=z(Tn),$n=z(Bn),Fn=z(u()),Vn=J(f({total:u(),circulating:u(),nonCirculating:u(),nonCirculatingAccounts:A(X)})),Rt=f({amount:k(),uiAmount:R(u()),decimals:u(),uiAmountString:L(k())}),Hn=J(A(f({address:X,amount:k(),uiAmount:R(u()),decimals:u(),uiAmountString:L(k())}))),Gn=J(A(f({pubkey:X,account:f({executable:ye(),owner:X,lamports:u(),data:Ut,rentEpoch:u()})}))),Et=f({program:k(),parsed:Je(),space:u()}),jn=J(A(f({pubkey:X,account:f({executable:ye(),owner:X,lamports:u(),data:Et,rentEpoch:u()})}))),Yn=J(A(f({lamports:u(),address:X}))),je=f({executable:ye(),owner:X,lamports:u(),data:Ut,rentEpoch:u()}),Jn=f({pubkey:X,account:je}),Xn=Xe(ae([Bt(x.Buffer),Et]),ae([Kr,Et]),o=>Array.isArray(o)?w(o,Ut):o),Pt=f({executable:ye(),owner:X,lamports:u(),data:Xn,rentEpoch:u()}),Zn=f({pubkey:X,account:Pt}),Qn=f({state:ae([Y("active"),Y("inactive"),Y("activating"),Y("deactivating")]),active:u(),inactive:u()}),eo=z(A(f({signature:k(),slot:u(),err:Be,memo:R(k()),blockTime:L(R(u()))}))),to=z(A(f({signature:k(),slot:u(),err:Be,memo:R(k()),blockTime:L(R(u()))}))),ro=f({subscription:u(),result:dt(je)}),so=f({pubkey:X,account:je}),no=f({subscription:u(),result:dt(so)}),oo=f({parent:u(),slot:u(),root:u()}),io=f({subscription:u(),result:oo}),ao=ae([f({type:ae([Y("firstShredReceived"),Y("completed"),Y("optimisticConfirmation"),Y("root")]),slot:u(),timestamp:u()}),f({type:Y("createdBank"),parent:u(),slot:u(),timestamp:u()}),f({type:Y("frozen"),slot:u(),timestamp:u(),stats:f({numTransactionEntries:u(),numSuccessfulTransactions:u(),numFailedTransactions:u(),maxTransactionsPerEntry:u()})}),f({type:Y("dead"),slot:u(),timestamp:u(),err:k()})]),co=f({subscription:u(),result:ao}),uo=f({subscription:u(),result:dt(ae([Cn,xn]))}),lo=f({subscription:u(),result:u()}),ho=f({pubkey:k(),gossip:R(k()),tpu:R(k()),rpc:R(k()),version:R(k())}),rr=f({votePubkey:k(),nodePubkey:k(),activatedStake:u(),epochVoteAccount:ye(),epochCredits:A(Ct([u(),u(),u()])),commission:u(),lastVote:u(),rootSlot:R(u())}),fo=z(f({current:A(rr),delinquent:A(rr)})),po=ae([Y("processed"),Y("confirmed"),Y("finalized")]),go=f({slot:u(),confirmations:R(u()),err:Be,confirmationStatus:L(po)}),yo=J(A(R(go))),mo=z(u()),Wr=f({accountKey:X,writableIndexes:A(u()),readonlyIndexes:A(u())}),Dt=f({signatures:A(k()),message:f({accountKeys:A(k()),header:f({numRequiredSignatures:u(),numReadonlySignedAccounts:u(),numReadonlyUnsignedAccounts:u()}),instructions:A(f({accounts:A(u()),data:k(),programIdIndex:u()})),recentBlockhash:k(),addressTableLookups:L(A(Wr))})}),Ur=f({pubkey:X,signer:ye(),writable:ye(),source:L(ae([Y("transaction"),Y("lookupTable")]))}),Dr=f({accountKeys:A(Ur),signatures:A(k())}),qr=f({parsed:Je(),program:k(),programId:X}),Mr=f({accounts:A(X),data:k(),programId:X}),bo=ae([Mr,qr]),ko=ae([f({parsed:Je(),program:k(),programId:k()}),f({accounts:A(k()),data:k(),programId:k()})]),$r=Xe(bo,ko,o=>"accounts"in o?w(o,Mr):w(o,qr)),Fr=f({signatures:A(k()),message:f({accountKeys:A(Ur),instructions:A($r),recentBlockhash:k(),addressTableLookups:L(R(A(Wr)))})}),it=f({accountIndex:u(),mint:k(),owner:L(k()),uiTokenAmount:Rt}),Vr=f({writable:A(X),readonly:A(X)}),ht=f({err:Be,fee:u(),innerInstructions:L(R(A(f({index:u(),instructions:A(f({accounts:A(u()),data:k(),programIdIndex:u()}))})))),preBalances:A(u()),postBalances:A(u()),logMessages:L(R(A(k()))),preTokenBalances:L(R(A(it))),postTokenBalances:L(R(A(it))),loadedAddresses:L(Vr),computeUnitsConsumed:L(u())}),qt=f({err:Be,fee:u(),innerInstructions:L(R(A(f({index:u(),instructions:A($r)})))),preBalances:A(u()),postBalances:A(u()),logMessages:L(R(A(k()))),preTokenBalances:L(R(A(it))),postTokenBalances:L(R(A(it))),loadedAddresses:L(Vr),computeUnitsConsumed:L(u())}),Ue=ae([Y(0),Y("legacy")]),Ce=f({pubkey:k(),lamports:u(),postBalance:R(u()),rewardType:R(k()),commission:L(R(u()))}),So=z(R(f({blockhash:k(),previousBlockhash:k(),parentSlot:u(),transactions:A(f({transaction:Dt,meta:R(ht),version:L(Ue)})),rewards:L(A(Ce)),blockTime:R(u()),blockHeight:R(u())}))),wo=z(R(f({blockhash:k(),previousBlockhash:k(),parentSlot:u(),rewards:L(A(Ce)),blockTime:R(u()),blockHeight:R(u())}))),Io=z(R(f({blockhash:k(),previousBlockhash:k(),parentSlot:u(),transactions:A(f({transaction:Dr,meta:R(ht),version:L(Ue)})),rewards:L(A(Ce)),blockTime:R(u()),blockHeight:R(u())}))),_o=z(R(f({blockhash:k(),previousBlockhash:k(),parentSlot:u(),transactions:A(f({transaction:Fr,meta:R(qt),version:L(Ue)})),rewards:L(A(Ce)),blockTime:R(u()),blockHeight:R(u())}))),Ao=z(R(f({blockhash:k(),previousBlockhash:k(),parentSlot:u(),transactions:A(f({transaction:Dr,meta:R(qt),version:L(Ue)})),rewards:L(A(Ce)),blockTime:R(u()),blockHeight:R(u())}))),Ro=z(R(f({blockhash:k(),previousBlockhash:k(),parentSlot:u(),rewards:L(A(Ce)),blockTime:R(u()),blockHeight:R(u())}))),Eo=z(R(f({blockhash:k(),previousBlockhash:k(),parentSlot:u(),transactions:A(f({transaction:Dt,meta:R(ht)})),rewards:L(A(Ce)),blockTime:R(u())}))),sr=z(R(f({blockhash:k(),previousBlockhash:k(),parentSlot:u(),signatures:A(k()),blockTime:R(u())}))),bt=z(R(f({slot:u(),meta:ht,blockTime:L(R(u())),transaction:Dt,version:L(Ue)}))),rt=z(R(f({slot:u(),transaction:Fr,meta:R(qt),blockTime:L(R(u())),version:L(Ue)}))),Po=J(f({blockhash:k(),feeCalculator:f({lamportsPerSignature:u()})})),vo=J(f({blockhash:k(),lastValidBlockHeight:u()})),To=J(ye()),Bo=f({slot:u(),numTransactions:u(),numSlots:u(),samplePeriodSecs:u()}),Co=z(A(Bo)),xo=J(R(f({feeCalculator:f({lamportsPerSignature:u()})}))),Lo=z(k()),No=z(k()),Ko=f({err:Be,logs:A(k()),signature:k()}),Oo=f({result:dt(Ko),subscription:u()}),zo={"solana-client":"js/0.0.0-development"};class Wo{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const l={};return async g=>{const{commitment:m,config:P}=G(g),d=this._buildArgs([],m,void 0,P),p=Qt(d);return l[p]=l[p]??(async()=>{try{const h=await this._rpcRequest("getBlockHeight",d),y=w(h,z(u()));if("error"in y)throw new C(y.error,"failed to get block height information");return y.result}finally{delete l[p]}})(),await l[p]}})();let r,s,n,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,r=t.wsEndpoint,s=t.httpHeaders,n=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=In(e),this._rpcWsEndpoint=r||wn(e),this._rpcClient=Kn(e,s,n,i,a,c),this._rpcRequest=On(this._rpcClient),this._rpcBatchRequest=zn(this._rpcClient),this._rpcWebSocket=new mn(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:r,config:s}=G(t),n=this._buildArgs([e.toBase58()],r,void 0,s),i=await this._rpcRequest("getBalance",n),a=w(i,J(u()));if("error"in a)throw new C(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+r)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),r=w(t,z(R(u())));if("error"in r)throw new C(r.error,`failed to get block time for slot ${e}`);return r.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=w(e,z(u()));if("error"in t)throw new C(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=w(e,Fn);if("error"in t)throw new C(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const r=await this._rpcRequest("getSupply",[t]),s=w(r,Vn);if("error"in s)throw new C(s.error,"failed to get supply");return s.result}async getTokenSupply(e,t){const r=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenSupply",r),n=w(s,J(Rt));if("error"in n)throw new C(n.error,"failed to get token supply");return n.result}async getTokenAccountBalance(e,t){const r=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenAccountBalance",r),n=w(s,J(Rt));if("error"in n)throw new C(n.error,"failed to get token account balance");return n.result}async getTokenAccountsByOwner(e,t,r){const{commitment:s,config:n}=G(r);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,s,"base64",n),c=await this._rpcRequest("getTokenAccountsByOwner",a),l=w(c,Gn);if("error"in l)throw new C(l.error,`failed to get token accounts owned by account ${e.toBase58()}`);return l.result}async getParsedTokenAccountsByOwner(e,t,r){let s=[e.toBase58()];"mint"in t?s.push({mint:t.mint.toBase58()}):s.push({programId:t.programId.toBase58()});const n=this._buildArgs(s,r,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",n),a=w(i,jn);if("error"in a)throw new C(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},r=t.filter||t.commitment?[t]:[],s=await this._rpcRequest("getLargestAccounts",r),n=w(s,Yn);if("error"in n)throw new C(n.error,"failed to get largest accounts");return n.result}async getTokenLargestAccounts(e,t){const r=this._buildArgs([e.toBase58()],t),s=await this._rpcRequest("getTokenLargestAccounts",r),n=w(s,Hn);if("error"in n)throw new C(n.error,"failed to get token largest accounts");return n.result}async getAccountInfoAndContext(e,t){const{commitment:r,config:s}=G(t),n=this._buildArgs([e.toBase58()],r,"base64",s),i=await this._rpcRequest("getAccountInfo",n),a=w(i,J(R(je)));if("error"in a)throw new C(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:r,config:s}=G(t),n=this._buildArgs([e.toBase58()],r,"jsonParsed",s),i=await this._rpcRequest("getAccountInfo",n),a=w(i,J(R(Pt)));if("error"in a)throw new C(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(r){throw new Error("failed to get info about account "+e.toBase58()+": "+r)}}async getMultipleParsedAccounts(e,t){const{commitment:r,config:s}=G(t),n=e.map(l=>l.toBase58()),i=this._buildArgs([n],r,"jsonParsed",s),a=await this._rpcRequest("getMultipleAccounts",i),c=w(a,J(A(R(Pt))));if("error"in c)throw new C(c.error,`failed to get info for accounts ${n}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:r,config:s}=G(t),n=e.map(l=>l.toBase58()),i=this._buildArgs([n],r,"base64",s),a=await this._rpcRequest("getMultipleAccounts",i),c=w(a,J(A(R(je))));if("error"in c)throw new C(c.error,`failed to get info for accounts ${n}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,r){const{commitment:s,config:n}=G(t),i=this._buildArgs([e.toBase58()],s,void 0,{...n,epoch:r??(n==null?void 0:n.epoch)}),a=await this._rpcRequest("getStakeActivation",i),c=w(a,z(Qn));if("error"in c)throw new C(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:r,config:s}=G(t),{encoding:n,...i}=s||{},a=this._buildArgs([e.toBase58()],r,n||"base64",i),c=await this._rpcRequest("getProgramAccounts",a),l=A(Jn),g=i.withContext===!0?w(c,J(l)):w(c,z(l));if("error"in g)throw new C(g.error,`failed to get accounts owned by program ${e.toBase58()}`);return g.result}async getParsedProgramAccounts(e,t){const{commitment:r,config:s}=G(t),n=this._buildArgs([e.toBase58()],r,"jsonParsed",s),i=await this._rpcRequest("getProgramAccounts",n),a=w(i,z(A(Zn)));if("error"in a)throw new C(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var n;let r;if(typeof e=="string")r=e;else{const i=e;if((n=i.abortSignal)!=null&&n.aborted)return Promise.reject(i.abortSignal.reason);r=i.signature}let s;try{s=ee.decode(r)}catch{throw new Error("signature must be base58 encoded: "+r)}return q(s.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:r}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,r)=>{e!=null&&(e.aborted?r(e.reason):e.addEventListener("abort",()=>{r(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let r,s,n=!1;const i=new Promise((c,l)=>{try{r=this.onSignature(t,(m,P)=>{r=void 0;const d={context:P,value:m};c({__type:be.PROCESSED,response:d})},e);const g=new Promise(m=>{r==null?m():s=this._onSubscriptionStateChange(r,P=>{P==="subscribed"&&m()})});(async()=>{if(await g,n)return;const m=await this.getSignatureStatus(t);if(n||m==null)return;const{context:P,value:d}=m;if(d!=null)if(d!=null&&d.err)l(d.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(d.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(d.confirmationStatus==="processed"||d.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}n=!0,c({__type:be.PROCESSED,response:{context:P,value:d}})}})()}catch(g){l(g)}});return{abortConfirmation:()=>{s&&(s(),s=void 0),r!=null&&(this.removeSignatureListener(r),r=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:r,signature:s}}){let n=!1;const i=new Promise(m=>{const P=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let d=await P();if(!n){for(;d<=r;)if(await Ae(1e3),n||(d=await P(),n))return;m({__type:be.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:s}),l=this.getCancellationPromise(t);let g;try{const m=await Promise.race([l,c,i]);if(m.__type===be.PROCESSED)g=m.response;else throw new Nt(s)}finally{n=!0,a()}return g}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:r,nonceAccountPubkey:s,nonceValue:n,signature:i}}){let a=!1;const c=new Promise(d=>{let p=n,h=null;const y=async()=>{try{const{context:_,value:I}=await this.getNonceAndContext(s,{commitment:e,minContextSlot:r});return h=_.slot,I==null?void 0:I.nonce}catch{return p}};(async()=>{if(p=await y(),!a)for(;;){if(n!==p){d({__type:be.NONCE_INVALID,slotInWhichNonceDidAdvance:h});return}if(await Ae(2e3),a||(p=await y(),a))return}})()}),{abortConfirmation:l,confirmationPromise:g}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),m=this.getCancellationPromise(t);let P;try{const d=await Promise.race([m,g,c]);if(d.__type===be.PROCESSED)P=d.response;else{let p;for(;;){const h=await this.getSignatureStatus(i);if(h==null)break;if(h.context.slot<(d.slotInWhichNonceDidAdvance??r)){await Ae(400);continue}p=h;break}if(p!=null&&p.value){const h=e||"finalized",{confirmationStatus:y}=p.value;switch(h){case"processed":case"recent":if(y!=="processed"&&y!=="confirmed"&&y!=="finalized")throw new xe(i);break;case"confirmed":case"single":case"singleGossip":if(y!=="confirmed"&&y!=="finalized")throw new xe(i);break;case"finalized":case"max":case"root":if(y!=="finalized")throw new xe(i);break;default:(_=>{})(h)}P={context:p.context,value:{err:p.value.err}}}else throw new xe(i)}}finally{a=!0,l()}return P}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let r;const s=new Promise(c=>{let l=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{l=this._confirmTransactionInitialTimeout||3e4;break}}r=setTimeout(()=>c({__type:be.TIMED_OUT,timeoutMs:l}),l)}),{abortConfirmation:n,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,s]);if(c.__type===be.PROCESSED)a=c.response;else throw new Kt(t,c.timeoutMs/1e3)}finally{clearTimeout(r),n()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=w(e,z(A(ho)));if("error"in t)throw new C(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getVoteAccounts",t),s=w(r,fo);if("error"in s)throw new C(s.error,"failed to get vote accounts");return s.result}async getSlot(e){const{commitment:t,config:r}=G(e),s=this._buildArgs([],t,void 0,r),n=await this._rpcRequest("getSlot",s),i=w(n,z(u()));if("error"in i)throw new C(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:r}=G(e),s=this._buildArgs([],t,void 0,r),n=await this._rpcRequest("getSlotLeader",s),i=w(n,z(k()));if("error"in i)throw new C(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const r=[e,t],s=await this._rpcRequest("getSlotLeaders",r),n=w(s,z(A(X)));if("error"in n)throw new C(n.error,"failed to get slot leaders");return n.result}async getSignatureStatus(e,t){const{context:r,value:s}=await this.getSignatureStatuses([e],t);q(s.length===1);const n=s[0];return{context:r,value:n}}async getSignatureStatuses(e,t){const r=[e];t&&r.push(t);const s=await this._rpcRequest("getSignatureStatuses",r),n=w(s,yo);if("error"in n)throw new C(n.error,"failed to get signature status");return n.result}async getTransactionCount(e){const{commitment:t,config:r}=G(e),s=this._buildArgs([],t,void 0,r),n=await this._rpcRequest("getTransactionCount",s),i=w(n,z(u()));if("error"in i)throw new C(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getInflationGovernor",t),s=w(r,Wn);if("error"in s)throw new C(s.error,"failed to get inflation");return s.result}async getInflationReward(e,t,r){const{commitment:s,config:n}=G(r),i=this._buildArgs([e.map(l=>l.toBase58())],s,void 0,{...n,epoch:t??(n==null?void 0:n.epoch)}),a=await this._rpcRequest("getInflationReward",i),c=w(a,Rn);if("error"in c)throw new C(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=w(e,Un);if("error"in t)throw new C(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:r}=G(e),s=this._buildArgs([],t,void 0,r),n=await this._rpcRequest("getEpochInfo",s),i=w(n,qn);if("error"in i)throw new C(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=w(e,Mn);if("error"in t)throw new C(t.error,"failed to get epoch schedule");const r=t.result;return new Nr(r.slotsPerEpoch,r.leaderScheduleSlotOffset,r.warmup,r.firstNormalEpoch,r.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=w(e,$n);if("error"in t)throw new C(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const r=this._buildArgs([e],t),s=await this._rpcRequest("getMinimumBalanceForRentExemption",r),n=w(s,mo);return"error"in n?(console.warn("Unable to fetch minimum balance for rent exemption"),0):n.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),r=await this._rpcRequest("getRecentBlockhash",t),s=w(r,Po);if("error"in s)throw new C(s.error,"failed to get recent blockhash");return s.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),r=w(t,Co);if("error"in r)throw new C(r.error,"failed to get recent performance samples");return r.result}async getFeeCalculatorForBlockhash(e,t){const r=this._buildArgs([e],t),s=await this._rpcRequest("getFeeCalculatorForBlockhash",r),n=w(s,xo);if("error"in n)throw new C(n.error,"failed to get fee calculator");const{context:i,value:a}=n.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const r=W(e.serialize()).toString("base64"),s=this._buildArgs([r],t),n=await this._rpcRequest("getFeeForMessage",s),i=w(n,J(R(u())));if("error"in i)throw new C(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){var i;const t=(i=e==null?void 0:e.lockedWritableAccounts)==null?void 0:i.map(a=>a.toBase58()),r=t!=null&&t.length?[t]:[],s=await this._rpcRequest("getRecentPrioritizationFees",r),n=w(s,Dn);if("error"in n)throw new C(n.error,"failed to get recent prioritization fees");return n.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:r}=G(e),s=this._buildArgs([],t,void 0,r),n=await this._rpcRequest("getLatestBlockhash",s),i=w(n,vo);if("error"in i)throw new C(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){const{commitment:r,config:s}=G(t),n=this._buildArgs([e],r,void 0,s),i=await this._rpcRequest("isBlockhashValid",n),a=w(i,To);if("error"in a)throw new C(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=w(e,z(Ln));if("error"in t)throw new C(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=w(e,z(k()));if("error"in t)throw new C(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:r,config:s}=G(t),n=this._buildArgsAtLeastConfirmed([e],r,void 0,s),i=await this._rpcRequest("getBlock",n);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=w(i,Io);if("error"in a)throw a.error;return a.result}case"none":{const a=w(i,wo);if("error"in a)throw a.error;return a.result}default:{const a=w(i,So);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:l,meta:g,version:m})=>({meta:g,transaction:{...l,message:mt(m,l.message)},version:m}))}:null}}}catch(a){throw new C(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:r,config:s}=G(t),n=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",s),i=await this._rpcRequest("getBlock",n);try{switch(s==null?void 0:s.transactionDetails){case"accounts":{const a=w(i,Ao);if("error"in a)throw a.error;return a.result}case"none":{const a=w(i,Ro);if("error"in a)throw a.error;return a.result}default:{const a=w(i,_o);if("error"in a)throw a.error;return a.result}}}catch(a){throw new C(a,"failed to get block")}}async getBlockProduction(e){let t,r;if(typeof e=="string")r=e;else if(e){const{commitment:a,...c}=e;r=a,t=c}const s=this._buildArgs([],r,"base64",t),n=await this._rpcRequest("getBlockProduction",s),i=w(n,Nn);if("error"in i)throw new C(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:r,config:s}=G(t),n=this._buildArgsAtLeastConfirmed([e],r,void 0,s),i=await this._rpcRequest("getTransaction",n),a=w(i,bt);if("error"in a)throw new C(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:mt(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:r,config:s}=G(t),n=this._buildArgsAtLeastConfirmed([e],r,"jsonParsed",s),i=await this._rpcRequest("getTransaction",n),a=w(i,rt);if("error"in a)throw new C(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:r,config:s}=G(t),n=e.map(c=>{const l=this._buildArgsAtLeastConfirmed([c],r,"jsonParsed",s);return{methodName:"getTransaction",args:l}});return(await this._rpcBatchRequest(n)).map(c=>{const l=w(c,rt);if("error"in l)throw new C(l.error,"failed to get transactions");return l.result})}async getTransactions(e,t){const{commitment:r,config:s}=G(t),n=e.map(c=>{const l=this._buildArgsAtLeastConfirmed([c],r,void 0,s);return{methodName:"getTransaction",args:l}});return(await this._rpcBatchRequest(n)).map(c=>{const l=w(c,bt);if("error"in l)throw new C(l.error,"failed to get transactions");const g=l.result;return g&&{...g,transaction:{...g.transaction,message:mt(g.version,g.transaction.message)}}})}async getConfirmedBlock(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedBlock",r),n=w(s,Eo);if("error"in n)throw new C(n.error,"failed to get confirmed block");const i=n.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:l})=>{const g=new fe(c.message);return{meta:l,transaction:{...c,message:g}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:l})=>({meta:l,transaction:F.populate(c.message,c.signatures)}))}}async getBlocks(e,t,r){const s=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],r),n=await this._rpcRequest("getBlocks",s),i=w(n,z(A(u())));if("error"in i)throw new C(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getBlock",r),n=w(s,sr);if("error"in n)throw new C(n.error,"failed to get block");const i=n.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),s=await this._rpcRequest("getConfirmedBlock",r),n=w(s,sr);if("error"in n)throw new C(n.error,"failed to get confirmed block");const i=n.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t),s=await this._rpcRequest("getConfirmedTransaction",r),n=w(s,bt);if("error"in n)throw new C(n.error,"failed to get transaction");const i=n.result;if(!i)return i;const a=new fe(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:F.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const r=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),s=await this._rpcRequest("getConfirmedTransaction",r),n=w(s,rt);if("error"in n)throw new C(n.error,"failed to get confirmed transaction");return n.result}async getParsedConfirmedTransactions(e,t){const r=e.map(i=>{const a=this._buildArgsAtLeastConfirmed([i],t,"jsonParsed");return{methodName:"getConfirmedTransaction",args:a}});return(await this._rpcBatchRequest(r)).map(i=>{const a=w(i,rt);if("error"in a)throw new C(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,r){let s={},n=await this.getFirstAvailableBlock();for(;!("until"in s)&&(t--,!(t<=0||t<n));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(s.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in s)&&(r++,!(r>i));)try{const c=await this.getConfirmedBlockSignatures(r);c.signatures.length>0&&(s.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,s)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,r){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),n=await this._rpcRequest("getConfirmedSignaturesForAddress2",s),i=w(n,eo);if("error"in i)throw new C(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,r){const s=this._buildArgsAtLeastConfirmed([e.toBase58()],r,void 0,t),n=await this._rpcRequest("getSignaturesForAddress",s),i=w(n,to);if("error"in i)throw new C(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:r,value:s}=await this.getAccountInfoAndContext(e,t);let n=null;return s!==null&&(n=new At({key:e,state:At.deserialize(s.data)})),{context:r,value:n}}async getNonceAndContext(e,t){const{context:r,value:s}=await this.getAccountInfoAndContext(e,t);let n=null;return s!==null&&(n=lt.fromAccountData(s.data)),{context:r,value:n}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(r=>r.value).catch(r=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+r)})}async requestAirdrop(e,t){const r=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),s=w(r,Lo);if("error"in s)throw new C(s.error,`airdrop to ${e.toBase58()} failed`);return s.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await Ae(100);const r=Date.now()-this._blockhashInfo.lastFetch>=Or;if(this._blockhashInfo.latestBlockhash!==null&&!r)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,r=t?t.blockhash:null;for(let s=0;s<50;s++){const n=await this.getLatestBlockhash("finalized");if(r!==n.blockhash)return this._blockhashInfo={latestBlockhash:n,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},n;await Ae(Cr/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:r}=G(e),s=this._buildArgs([],t,"base64",r),n=await this._rpcRequest("getStakeMinimumDelegation",s),i=w(n,J(u()));if("error"in i)throw new C(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,r){if("message"in e){const h=e.serialize(),y=x.Buffer.from(h).toString("base64");if(Array.isArray(t)||r!==void 0)throw new Error("Invalid arguments");const _=t||{};_.encoding="base64","commitment"in _||(_.commitment=this.commitment);const I=[y,_],b=await this._rpcRequest("simulateTransaction",I),K=w(b,tr);if("error"in K)throw new Error("failed to simulate transaction: "+K.error.message);return K.result}let s;if(e instanceof F){let p=e;s=new F,s.feePayer=p.feePayer,s.instructions=e.instructions,s.nonceInfo=p.nonceInfo,s.signatures=p.signatures}else s=F.populate(e),s._message=s._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const n=t;if(s.nonceInfo&&n)s.sign(...n);else{let p=this._disableBlockhashCaching;for(;;){const h=await this._blockhashWithExpiryBlockHeight(p);if(s.lastValidBlockHeight=h.lastValidBlockHeight,s.recentBlockhash=h.blockhash,!n)break;if(s.sign(...n),!s.signature)throw new Error("!signature");const y=s.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(y)&&!this._blockhashInfo.transactionSignatures.includes(y)){this._blockhashInfo.simulatedSignatures.push(y);break}else p=!0}}const i=s._compile(),a=i.serialize(),l=s._serialize(a).toString("base64"),g={encoding:"base64",commitment:this.commitment};if(r){const p=(Array.isArray(r)?r:i.nonProgramIds()).map(h=>h.toBase58());g.accounts={encoding:"base64",addresses:p}}n&&(g.sigVerify=!0);const m=[l,g],P=await this._rpcRequest("simulateTransaction",m),d=w(P,tr);if("error"in d){let p;if("data"in d.error&&(p=d.error.data.logs,p&&Array.isArray(p))){const h=`
    `,y=h+p.join(h);console.error(d.error.message,y)}throw new _t("failed to simulate transaction: "+d.error.message,p)}return d.result}async sendTransaction(e,t,r){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(e.nonceInfo)e.sign(...s);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...s),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const n=e.serialize();return await this.sendRawTransaction(n,r)}async sendRawTransaction(e,t){const r=W(e).toString("base64");return await this.sendEncodedTransaction(r,t)}async sendEncodedTransaction(e,t){const r={encoding:"base64"},s=t&&t.skipPreflight,n=t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(r.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(r.minContextSlot=t.minContextSlot),s&&(r.skipPreflight=s),n&&(r.preflightCommitment=n);const i=[e,r],a=await this._rpcRequest("sendTransaction",i),c=w(a,No);if("error"in c){let l;throw"data"in c.error&&(l=c.error.data.logs),new _t("failed to send transaction: "+c.error.message,l)}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,r])=>{this._setSubscription(t,{...r,state:"pending"})})}_setSubscription(e,t){var s;const r=(s=this._subscriptionsByHash[e])==null?void 0:s.state;if(this._subscriptionsByHash[e]=t,r!==t.state){const n=this._subscriptionStateChangeCallbacksByHash[e];n&&n.forEach(i=>{try{i(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){const r=this._subscriptionHashByClientSubscriptionId[e];if(r==null)return()=>{};const s=this._subscriptionStateChangeCallbacksByHash[r]||=new Set;return s.add(t),()=>{s.delete(t),s.size===0&&delete this._subscriptionStateChangeCallbacksByHash[r]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(r){r instanceof Error&&console.log(`Error when closing socket connection: ${r.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async r=>{const s=this._subscriptionsByHash[r];if(s!==void 0)switch(s.state){case"pending":case"unsubscribed":if(s.callbacks.size===0){delete this._subscriptionsByHash[r],s.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[s.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:n,method:i}=s;try{this._setSubscription(r,{...s,state:"subscribing"});const a=await this._rpcWebSocket.call(i,n);this._setSubscription(r,{...s,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=s.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${i} error for argument`,n,a.message),!t())return;this._setSubscription(r,{...s,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":s.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:n,unsubscribeMethod:i}=s;if(this._subscriptionsAutoDisposedByRpc.has(n))this._subscriptionsAutoDisposedByRpc.delete(n);else{this._setSubscription(r,{...s,state:"unsubscribing"}),this._setSubscription(r,{...s,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[n])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(r,{...s,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(r,{...s,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const r=this._subscriptionCallbacksByServerSubscriptionId[e];r!==void 0&&r.forEach(s=>{try{s(...t)}catch(n){console.error(n)}})}_wsOnAccountNotification(e){const{result:t,subscription:r}=w(e,ro);this._handleServerNotification(r,[t.value,t.context])}_makeSubscription(e,t){const r=this._nextClientSubscriptionId++,s=Qt([e.method,t],!0),n=this._subscriptionsByHash[s];return n===void 0?this._subscriptionsByHash[s]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:n.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[r]=s,this._subscriptionDisposeFunctionsByClientSubscriptionId[r]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[r],delete this._subscriptionHashByClientSubscriptionId[r];const i=this._subscriptionsByHash[s];q(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${r}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),r}onAccountChange(e,t,r){const s=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},s)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:r}=w(e,no);this._handleServerNotification(r,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,r,s){const n=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",s?{filters:s}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},n)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,r){const s=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],r||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},s)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:r}=w(e,Oo);this._handleServerNotification(r,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:r}=w(e,io);this._handleServerNotification(r,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:r}=w(e,co);this._handleServerNotification(r,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const r=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];r?await r():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,r,s){const n=t||this._commitment;if(n||r||s){let i={};r&&(i.encoding=r),n&&(i.commitment=n),s&&(i=Object.assign(i,s)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,r,s){const n=t||this._commitment;if(n&&!["confirmed","finalized"].includes(n))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,r,s)}_wsOnSignatureNotification(e){const{result:t,subscription:r}=w(e,uo);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(r),this._handleServerNotification(r,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,r){const s=this._buildArgs([e],r||this._commitment||"finalized"),n=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(n)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},s);return n}onSignatureWithOptions(e,t,r){const{commitment:s,...n}={...r,commitment:r&&r.commitment||this._commitment||"finalized"},i=this._buildArgs([e],s,void 0,n),a=this._makeSubscription({callback:(c,l)=>{t(c,l);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:r}=w(e,lo);this._handleServerNotification(r,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Le{constructor(e){this._keypair=void 0,this._keypair=e??Jt()}static generate(){return new Le(Jt())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const r=e.slice(32,64);if(!t||!t.skipValidation){const s=e.slice(0,32),n=ot(s);for(let i=0;i<32;i++)if(r[i]!==n[i])throw new Error("provided secretKey is invalid")}return new Le({publicKey:r,secretKey:e})}static fromSeed(e){const t=ot(e),r=new Uint8Array(64);return r.set(e),r.set(t,32),new Le({publicKey:t,secretKey:r})}get publicKey(){return new S(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const ke=Object.freeze({CreateLookupTable:{index:0,layout:v([T("instruction"),ze("recentSlot"),M("bumpSeed")])},FreezeLookupTable:{index:1,layout:v([T("instruction")])},ExtendLookupTable:{index:2,layout:v([T("instruction"),ze(),ne(U(),Ee(T(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:v([T("instruction")])},CloseLookupTable:{index:4,layout:v([T("instruction")])}});class Uo{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=T("instruction").decode(e.data);let s;for(const[n,i]of Object.entries(ke))if(i.index==r){s=n;break}if(!s)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return s}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=$(ke.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=$(ke.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(r=>new S(r))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Mt.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class Mt{constructor(){}static createLookupTable(e){const[t,r]=S.findProgramAddressSync([e.authority.toBuffer(),wr(BigInt(e.recentSlot),8)],this.programId),s=ke.CreateLookupTable,n=D(s,{recentSlot:BigInt(e.recentSlot),bumpSeed:r}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:te.programId,isSigner:!1,isWritable:!1}];return[new V({programId:this.programId,keys:i,data:n}),t]}static freezeLookupTable(e){const t=ke.FreezeLookupTable,r=D(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new V({programId:this.programId,keys:s,data:r})}static extendLookupTable(e){const t=ke.ExtendLookupTable,r=D(t,{addresses:e.addresses.map(n=>n.toBytes())}),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&s.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:te.programId,isSigner:!1,isWritable:!1}),new V({programId:this.programId,keys:s,data:r})}static deactivateLookupTable(e){const t=ke.DeactivateLookupTable,r=D(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new V({programId:this.programId,keys:s,data:r})}static closeLookupTable(e){const t=ke.CloseLookupTable,r=D(t),s=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new V({programId:this.programId,keys:s,data:r})}}Mt.programId=new S("AddressLookupTab1e1111111111111111111111111");class Do{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=M("instruction").decode(e.data);let s;for(const[n,i]of Object.entries(ge))if(i.index==r){s=n;break}if(!s)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return s}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:r}=$(ge.RequestUnits,e.data);return{units:t,additionalFee:r}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=$(ge.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=$(ge.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=$(ge.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals($t.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const ge=Object.freeze({RequestUnits:{index:0,layout:v([M("instruction"),T("units"),T("additionalFee")])},RequestHeapFrame:{index:1,layout:v([M("instruction"),T("bytes")])},SetComputeUnitLimit:{index:2,layout:v([M("instruction"),T("units")])},SetComputeUnitPrice:{index:3,layout:v([M("instruction"),ze("microLamports")])}});class $t{constructor(){}static requestUnits(e){const t=ge.RequestUnits,r=D(t,e);return new V({keys:[],programId:this.programId,data:r})}static requestHeapFrame(e){const t=ge.RequestHeapFrame,r=D(t,e);return new V({keys:[],programId:this.programId,data:r})}static setComputeUnitLimit(e){const t=ge.SetComputeUnitLimit,r=D(t,e);return new V({keys:[],programId:this.programId,data:r})}static setComputeUnitPrice(e){const t=ge.SetComputeUnitPrice,r=D(t,{microLamports:BigInt(e.microLamports)});return new V({keys:[],programId:this.programId,data:r})}}$t.programId=new S("ComputeBudget111111111111111111111111111111");const nr=64,or=32,ir=64,ar=v([M("numSignatures"),M("padding"),de("signatureOffset"),de("signatureInstructionIndex"),de("publicKeyOffset"),de("publicKeyInstructionIndex"),de("messageDataOffset"),de("messageDataSize"),de("messageInstructionIndex")]);class ft{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:s,instructionIndex:n}=e;q(t.length===or,`Public Key must be ${or} bytes but received ${t.length} bytes`),q(s.length===ir,`Signature must be ${ir} bytes but received ${s.length} bytes`);const i=ar.span,a=i+t.length,c=a+s.length,l=1,g=x.Buffer.alloc(c+r.length),m=n??65535;return ar.encode({numSignatures:l,padding:0,signatureOffset:a,signatureInstructionIndex:m,publicKeyOffset:i,publicKeyInstructionIndex:m,messageDataOffset:c,messageDataSize:r.length,messageInstructionIndex:m},g),g.fill(t,i),g.fill(s,a),g.fill(r,c),new V({keys:[],programId:ft.programId,data:g})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:s}=e;q(t.length===nr,`Private key must be ${nr} bytes but received ${t.length} bytes`);try{const n=Le.fromSecretKey(t),i=n.publicKey.toBytes(),a=xt(r,n.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:a,instructionIndex:s})}catch(n){throw new Error(`Error creating instruction; ${n}`)}}}ft.programId=new S("Ed25519SigVerify111111111111111111111111111");const qo=(o,e)=>{const t=vt.sign(o,e);return[t.toCompactRawBytes(),t.recovery]};vt.utils.isValidPrivateKey;const Mo=vt.getPublicKey,cr=32,kt=20,ur=64,$o=11,St=v([M("numSignatures"),de("signatureOffset"),M("signatureInstructionIndex"),de("ethAddressOffset"),M("ethAddressInstructionIndex"),de("messageDataOffset"),de("messageDataSize"),M("messageInstructionIndex"),j(20,"ethAddress"),j(64,"signature"),M("recoveryId")]);class Ne{constructor(){}static publicKeyToEthAddress(e){q(e.length===ur,`Public key must be ${ur} bytes but received ${e.length} bytes`);try{return x.Buffer.from(jt(W(e))).slice(-kt)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:r,signature:s,recoveryId:n,instructionIndex:i}=e;return Ne.createInstructionWithEthAddress({ethAddress:Ne.publicKeyToEthAddress(t),message:r,signature:s,recoveryId:n,instructionIndex:i})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:r,signature:s,recoveryId:n,instructionIndex:i=0}=e;let a;typeof t=="string"?t.startsWith("0x")?a=x.Buffer.from(t.substr(2),"hex"):a=x.Buffer.from(t,"hex"):a=t,q(a.length===kt,`Address must be ${kt} bytes but received ${a.length} bytes`);const c=1+$o,l=c,g=c+a.length,m=g+s.length+1,P=1,d=x.Buffer.alloc(St.span+r.length);return St.encode({numSignatures:P,signatureOffset:g,signatureInstructionIndex:i,ethAddressOffset:l,ethAddressInstructionIndex:i,messageDataOffset:m,messageDataSize:r.length,messageInstructionIndex:i,signature:W(s),ethAddress:W(a),recoveryId:n},d),d.fill(W(r),St.span),new V({keys:[],programId:Ne.programId,data:d})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:r,instructionIndex:s}=e;q(t.length===cr,`Private key must be ${cr} bytes but received ${t.length} bytes`);try{const n=W(t),i=Mo(n,!1).slice(1),a=x.Buffer.from(jt(W(r))),[c,l]=qo(a,n);return this.createInstructionWithPublicKey({publicKey:i,message:r,signature:c,recoveryId:l,instructionIndex:s})}catch(n){throw new Error(`Error creating instruction; ${n}`)}}}Ne.programId=new S("KeccakSecp256k11111111111111111111111111111");var Hr;const Gr=new S("StakeConfig11111111111111111111111111111111");class jr{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class Ze{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}Hr=Ze;Ze.default=new Hr(0,0,S.default);class Fo{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=T("instruction").decode(e.data);let s;for(const[n,i]of Object.entries(Q))if(i.index==r){s=n;break}if(!s)throw new Error("Instruction type incorrect; not a StakeInstruction");return s}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:r}=$(Q.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new jr(new S(t.staker),new S(t.withdrawer)),lockup:new Ze(r.unixTimestamp,r.epoch,new S(r.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),$(Q.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:r}=$(Q.Authorize,e.data),s={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new S(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(s.custodianPubkey=e.keys[3].pubkey),s}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:r,authoritySeed:s,authorityOwner:n}=$(Q.AuthorizeWithSeed,e.data),i={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:s,authorityOwner:new S(n),newAuthorizedPubkey:new S(t),stakeAuthorizationType:{index:r}};return e.keys.length>3&&(i.custodianPubkey=e.keys[3].pubkey),i}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=$(Q.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),$(Q.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=$(Q.Withdraw,e.data),r={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(r.custodianPubkey=e.keys[5].pubkey),r}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),$(Q.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(pt.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Q=Object.freeze({Initialize:{index:0,layout:v([T("instruction"),Fs(),Vs()])},Authorize:{index:1,layout:v([T("instruction"),U("newAuthorized"),T("stakeAuthorizationType")])},Delegate:{index:2,layout:v([T("instruction")])},Split:{index:3,layout:v([T("instruction"),le("lamports")])},Withdraw:{index:4,layout:v([T("instruction"),le("lamports")])},Deactivate:{index:5,layout:v([T("instruction")])},Merge:{index:7,layout:v([T("instruction")])},AuthorizeWithSeed:{index:8,layout:v([T("instruction"),U("newAuthorized"),T("stakeAuthorizationType"),Re("authoritySeed"),U("authorityOwner")])}}),Vo=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class pt{constructor(){}static initialize(e){const{stakePubkey:t,authorized:r,lockup:s}=e,n=s||Ze.default,i=Q.Initialize,a=D(i,{authorized:{staker:W(r.staker.toBuffer()),withdrawer:W(r.withdrawer.toBuffer())},lockup:{unixTimestamp:n.unixTimestamp,epoch:n.epoch,custodian:W(n.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new V(c)}static createAccountWithSeed(e){const t=new F;t.add(te.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:s,lockup:n}=e;return t.add(this.initialize({stakePubkey:r,authorized:s,lockup:n}))}static createAccount(e){const t=new F;t.add(te.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:r,authorized:s,lockup:n}=e;return t.add(this.initialize({stakePubkey:r,authorized:s,lockup:n}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:r,votePubkey:s}=e,n=Q.Delegate,i=D(n);return new F().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:nt,isSigner:!1,isWritable:!1},{pubkey:Gr,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){const{stakePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:s,stakeAuthorizationType:n,custodianPubkey:i}=e,a=Q.Authorize,c=D(a,{newAuthorized:W(s.toBuffer()),stakeAuthorizationType:n.index}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:pe,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!1,isWritable:!1}),new F().add({keys:l,programId:this.programId,data:c})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:r,authoritySeed:s,authorityOwner:n,newAuthorizedPubkey:i,stakeAuthorizationType:a,custodianPubkey:c}=e,l=Q.AuthorizeWithSeed,g=D(l,{newAuthorized:W(i.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:s,authorityOwner:W(n.toBuffer())}),m=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1}];return c&&m.push({pubkey:c,isSigner:!1,isWritable:!1}),new F().add({keys:m,programId:this.programId,data:g})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:s,lamports:n}=e,i=Q.Split,a=D(i,{lamports:n});return new V({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e){const t=new F;return t.add(te.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:0,space:this.space,programId:this.programId})),t.add(this.splitInstruction(e))}static splitWithSeed(e){const{stakePubkey:t,authorizedPubkey:r,splitStakePubkey:s,basePubkey:n,seed:i,lamports:a}=e,c=new F;return c.add(te.allocate({accountPubkey:s,basePubkey:n,seed:i,space:this.space,programId:this.programId})),c.add(this.splitInstruction({stakePubkey:t,authorizedPubkey:r,splitStakePubkey:s,lamports:a}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:r,authorizedPubkey:s}=e,n=Q.Merge,i=D(n);return new F().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:nt,isSigner:!1,isWritable:!1},{pubkey:s,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:r,toPubkey:s,lamports:n,custodianPubkey:i}=e,a=Q.Withdraw,c=D(a,{lamports:n}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:nt,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!1,isWritable:!1}),new F().add({keys:l,programId:this.programId,data:c})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:r}=e,s=Q.Deactivate,n=D(s);return new F().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}}pt.programId=new S("Stake11111111111111111111111111111111111111");pt.space=200;class Yr{constructor(e,t,r,s){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=r,this.commission=s}}class Ho{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const r=T("instruction").decode(e.data);let s;for(const[n,i]of Object.entries(Se))if(i.index==r){s=n;break}if(!s)throw new Error("Instruction type incorrect; not a VoteInstruction");return s}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=$(Se.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new Yr(new S(t.nodePubkey),new S(t.authorizedVoter),new S(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:r}=$(Se.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new S(t),voteAuthorizationType:{index:r}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:r,newAuthorized:s,voteAuthorizationType:n}}=$(Se.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new S(t),currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:new S(s),voteAuthorizationType:{index:n},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=$(Se.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(De.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const Se=Object.freeze({InitializeAccount:{index:0,layout:v([T("instruction"),Hs()])},Authorize:{index:1,layout:v([T("instruction"),U("newAuthorized"),T("voteAuthorizationType")])},Withdraw:{index:3,layout:v([T("instruction"),le("lamports")])},AuthorizeWithSeed:{index:10,layout:v([T("instruction"),Gs()])}}),Go=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class De{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:r,voteInit:s}=e,n=Se.InitializeAccount,i=D(n,{voteInit:{nodePubkey:W(s.nodePubkey.toBuffer()),authorizedVoter:W(s.authorizedVoter.toBuffer()),authorizedWithdrawer:W(s.authorizedWithdrawer.toBuffer()),commission:s.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Oe,isSigner:!1,isWritable:!1},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new V(a)}static createAccount(e){const t=new F;return t.add(te.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:r,newAuthorizedPubkey:s,voteAuthorizationType:n}=e,i=Se.Authorize,a=D(i,{newAuthorized:W(s.toBuffer()),voteAuthorizationType:n.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}];return new F().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:r,currentAuthorityDerivedKeySeed:s,newAuthorizedPubkey:n,voteAuthorizationType:i,votePubkey:a}=e,c=Se.AuthorizeWithSeed,l=D(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:W(r.toBuffer()),currentAuthorityDerivedKeySeed:s,newAuthorized:W(n.toBuffer()),voteAuthorizationType:i.index}}),g=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:pe,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new F().add({keys:g,programId:this.programId,data:l})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:r,lamports:s,toPubkey:n}=e,i=Se.Withdraw,a=D(i,{lamports:s}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return new F().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,r){if(e.lamports>t-r)throw new Error("Withdraw will leave vote account with insuffcient funds.");return De.withdraw(e)}}De.programId=new S("Vote111111111111111111111111111111111111111");De.space=3731;const Jr=new S("Va1idator1nfo111111111111111111111111111111"),jo=f({name:k(),website:L(k()),details:L(k()),keybaseUsername:L(k())});class Ft{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];if(ie(t)!==2)return null;const s=[];for(let n=0;n<2;n++){const i=new S(t.slice(0,ue));t=t.slice(ue);const a=t.slice(0,1)[0]===1;t=t.slice(1),s.push({publicKey:i,isSigner:a})}if(s[0].publicKey.equals(Jr)&&s[1].isSigner){const n=Re().decode(x.Buffer.from(t)),i=JSON.parse(n);return Ir(i,jo),new Ft(s[1].publicKey,i)}return null}}const Yo=new S("Vote111111111111111111111111111111111111111"),Jo=v([U("nodePubkey"),U("authorizedWithdrawer"),M("commission"),se(),ne(v([se("slot"),T("confirmationCount")]),Ee(T(),-8),"votes"),M("rootSlotValid"),se("rootSlot"),se(),ne(v([se("epoch"),U("authorizedVoter")]),Ee(T(),-8),"authorizedVoters"),v([ne(v([U("authorizedPubkey"),se("epochOfLastAuthorizedSwitch"),se("targetEpoch")]),32,"buf"),se("idx"),M("isEmpty")],"priorVoters"),se(),ne(v([se("epoch"),se("credits"),se("prevCredits")]),Ee(T(),-8),"epochCredits"),v([se("slot"),se("timestamp")],"lastTimestamp")]);class Vt{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const r=Jo.decode(W(e),4);let s=r.rootSlot;return r.rootSlotValid||(s=null),new Vt({nodePubkey:new S(r.nodePubkey),authorizedWithdrawer:new S(r.authorizedWithdrawer),commission:r.commission,votes:r.votes,rootSlot:s,authorizedVoters:r.authorizedVoters.map(Xo),priorVoters:Zo(r.priorVoters),epochCredits:r.epochCredits,lastTimestamp:r.lastTimestamp})}}function Xo({authorizedVoter:o,epoch:e}){return{epoch:e,authorizedVoter:new S(o)}}function lr({authorizedPubkey:o,epochOfLastAuthorizedSwitch:e,targetEpoch:t}){return{authorizedPubkey:new S(o),epochOfLastAuthorizedSwitch:e,targetEpoch:t}}function Zo({buf:o,idx:e,isEmpty:t}){return t?[]:[...o.slice(e+1).map(lr),...o.slice(0,e).map(lr)]}const dr={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function Qo(o,e){const t=e===!1?"http":"https";if(!o)return dr[t].devnet;const r=dr[t][o];if(!r)throw new Error(`Unknown ${t} cluster: ${o}`);return r}async function ei(o,e,t,r){let s,n;t&&Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")||t&&Object.prototype.hasOwnProperty.call(t,"nonceValue")?(s=t,n=r):n=t;const i=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,minContextSlot:n.minContextSlot},a=await o.sendRawTransaction(e,i),c=n&&n.commitment,g=(await(s?o.confirmTransaction(s,c):o.confirmTransaction(a,c))).value;if(g.err)throw new Error(`Raw transaction ${a} failed (${JSON.stringify(g)})`);return a}const ti=1e9;var Si=Object.freeze(Object.defineProperty({__proto__:null,Account:qs,AddressLookupTableAccount:At,AddressLookupTableInstruction:Uo,AddressLookupTableProgram:Mt,Authorized:jr,BLOCKHASH_CACHE_TIMEOUT_MS:Or,BPF_LOADER_DEPRECATED_PROGRAM_ID:Ms,BPF_LOADER_PROGRAM_ID:cn,BpfLoader:un,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:ge,ComputeBudgetInstruction:Do,ComputeBudgetProgram:$t,Connection:Wo,Ed25519Program:ft,Enum:Us,EpochSchedule:Nr,FeeCalculatorLayout:xr,Keypair:Le,LAMPORTS_PER_SOL:ti,LOOKUP_TABLE_INSTRUCTION_LAYOUTS:ke,Loader:ve,Lockup:Ze,MAX_SEED_LENGTH:Tr,Message:fe,MessageAccountKeys:Ge,MessageV0:Pe,NONCE_ACCOUNT_LENGTH:It,NonceAccount:lt,PACKET_DATA_SIZE:Ie,PUBLIC_KEY_LENGTH:ue,PublicKey:S,SIGNATURE_LENGTH_IN_BYTES:Ke,SOLANA_SCHEMA:$e,STAKE_CONFIG_ID:Gr,STAKE_INSTRUCTION_LAYOUTS:Q,SYSTEM_INSTRUCTION_LAYOUTS:H,SYSVAR_CLOCK_PUBKEY:pe,SYSVAR_EPOCH_SCHEDULE_PUBKEY:Zs,SYSVAR_INSTRUCTIONS_PUBKEY:Qs,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:st,SYSVAR_RENT_PUBKEY:Oe,SYSVAR_REWARDS_PUBKEY:en,SYSVAR_SLOT_HASHES_PUBKEY:tn,SYSVAR_SLOT_HISTORY_PUBKEY:rn,SYSVAR_STAKE_HISTORY_PUBKEY:nt,Secp256k1Program:Ne,SendTransactionError:_t,SolanaJSONRPCError:C,SolanaJSONRPCErrorCode:gn,StakeAuthorizationLayout:Vo,StakeInstruction:Fo,StakeProgram:pt,Struct:Lt,SystemInstruction:on,SystemProgram:te,Transaction:F,TransactionExpiredBlockheightExceededError:Nt,TransactionExpiredNonceInvalidError:xe,TransactionExpiredTimeoutError:Kt,TransactionInstruction:V,TransactionMessage:zt,TransactionStatus:be,VALIDATOR_INFO_KEY:Jr,VERSION_PREFIX_MASK:ct,VOTE_PROGRAM_ID:Yo,ValidatorInfo:Ft,VersionedMessage:Ot,VersionedTransaction:Wt,VoteAccount:Vt,VoteAuthorizationLayout:Go,VoteInit:Yr,VoteInstruction:Ho,VoteProgram:De,clusterApiUrl:Qo,sendAndConfirmRawTransaction:ei,sendAndConfirmTransaction:wt},Symbol.toStringTag,{value:"Module"}));const at=(o,e)=>new Fe(o,e),wi=o=>o===null?null:at(o),Xr={symbol:"SOL",decimals:9},gt=(o,e)=>({basisPoints:at(o),currency:e}),Ii=o=>gt(o,Xr),_i=(o,e=0,t="Token")=>(typeof o!="number"&&(o=at(o).toNumber()),{basisPoints:at(o*Math.pow(10,e)),currency:{symbol:t,decimals:e,namespace:"spl-token"}}),Zr=(o,e)=>("currency"in o&&(o=o.currency),"currency"in e&&(e=e.currency),o.symbol===e.symbol&&o.decimals===e.decimals&&o.namespace===e.namespace);function ri(o,e){if("currency"in o&&(o=o.currency),!Zr(o,e))throw new ys(o,e)}function Ai(o){ri(o,Xr)}function Qr(o,e,t){if("currency"in o&&(o=o.currency),"currency"in e&&(e=e.currency),!Zr(o,e))throw new ms(o,e,t)}const Ri=(o,e)=>(Qr(o,e,"add"),gt(o.basisPoints.add(e.basisPoints),o.currency)),Ei=(o,e)=>(Qr(o,e,"subtract"),gt(o.basisPoints.sub(e.basisPoints),o.currency)),Pi=(o,e)=>gt(o.basisPoints.muln(e),o.currency),vi=o=>{if(o.currency.decimals===0)return`${o.currency.symbol} ${o.basisPoints.toString()}`;const e=new Fe(10).pow(new Fe(o.currency.decimals)),t=o.basisPoints,{div:r,mod:s}=t.divmod(e),n=`${r.toString()}.${s.abs().toString(10,o.currency.decimals)}`;return`${o.currency.symbol} ${n}`};export{li as A,vi as B,Wo as C,ii as D,hi as E,gi as F,ai as I,Le as K,gs as M,bi as N,oi as O,S as P,te as S,F as T,di as U,ni as _,gt as a,Z as b,ci as c,Oe as d,V as e,Ai as f,fi as g,Ri as h,Si as i,Ei as j,ui as k,Ii as l,Pi as m,_i as n,yi as o,Qs as p,wi as q,ki as r,wt as s,at as t,pi as u,Xr as v,Qr as w,pe as x,tn as y,mi as z};
