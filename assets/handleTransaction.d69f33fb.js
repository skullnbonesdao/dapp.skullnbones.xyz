import{cV as r,cU as d,cj as o,co as n,cW as m,P as l,cQ as f}from"./index.76cbbf6e.js";import{v as p}from"./token.6880fb5f.js";const b=async(i,s="Unlabeled transaction")=>{const{sendTransaction:c}=r(),t=d.create({group:!1,timeout:0,spinner:!0,message:s,position:"bottom-right"});try{t({caption:"Waiting for user to sign..."});let a="";if(!o().useSquads)a=await c(i,n().connection);else{console.log(i.instructions);const g=await n().connection.getRecentBlockhash(),h=new m({payerKey:new l(o().vaultPDA),recentBlockhash:g.blockhash,instructions:i.instructions});await o().loadMultisigInfo();const u=p({multisigPda:new l(o().multisigPDA),transactionIndex:o().getNewTransactionIndex,creator:r().publicKey.value,vaultIndex:0,ephemeralSigners:0,transactionMessage:h,memo:s});a=await c(new f().add(u),n().connection)}t({color:"green-5",message:"[1/2] Waiting for confirmation...",caption:`${a}`});const e=await n().connection.getLatestBlockhash();return await n().connection.confirmTransaction({blockhash:e.blockhash,lastValidBlockHeight:e.lastValidBlockHeight,signature:a},"confirmed"),t({color:"green-8",message:"[2/2]  Waiting for finalization...",caption:`${a}`}),await n().connection.confirmTransaction({blockhash:e.blockhash,lastValidBlockHeight:e.lastValidBlockHeight,signature:a},"finalized"),t({color:"positive",timeout:5e3,icon:"done",spinner:!1,message:"Finalized",caption:`${a}`}),0}catch(a){t({progress:!0,spinner:!1,icon:"error",color:"negative",timeout:5e3,caption:`Error handling transaction: ${a.toString()}`})}};export{b as h};
