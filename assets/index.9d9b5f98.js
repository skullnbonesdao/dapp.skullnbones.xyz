import{cQ as ot,cR as D,P as k,cS as Rt,cn as Kt,bW as Ot,cT as Te,cU as ce,cV as ue,cW as Re,cX as Oe,cY as Be,cJ as le,cZ as Ne,c_ as xe}from"./index.8041a8a0.js";import{L as Wt,r as Me,u as de,a as V,s as P,n as j,b as ut,c as At,o as De,d as Ue,e as $e,i as qe}from"./pako.esm.edd8a1b7.js";var Ct;const it={}.ANCHOR_BROWSER||typeof window<"u"&&!(!((Ct=window.process)===null||Ct===void 0)&&Ct.hasOwnProperty("type"));function Ve(r,t){return Array.apply(0,new Array(Math.ceil(r.length/t))).map((e,n)=>r.slice(n*t,(n+1)*t))}const nt=r=>"version"in r;function je(r){return(it?new TextDecoder("utf-8"):new(require("util")).TextDecoder("utf-8")).decode(r)}function ze(r){return(it?new TextEncoder:new(require("util")).TextEncoder("utf-8")).encode(r)}function Gt(r){return ot.encode(r)}function Ht(r){return r.toString("base64")}function fe(r){return D.Buffer.from(r,"base64")}function Fe(r){const t=new Map;return r.errors&&r.errors.forEach(e=>{var n;let o=(n=e.msg)!==null&&n!==void 0?n:e.name;t.set(e.code,o)}),t}function Ke(r,...t){if(r.args.length!=t.length)throw new Error("Invalid argument length");const e={};let n=0;return r.args.forEach(o=>{e[o.name]=t[n],n+=1}),e}function he(r,t={}){r.forEach(e=>{if("accounts"in e)he(e.accounts,t[e.name]);else if(t[e.name]===void 0)throw new Error(`Invalid arguments: ${e.name} not provided.`)})}function N(r){return r instanceof k?r:new k(r)}class We extends TypeError{constructor(t,e){let n;const{message:o,...s}=t,{path:i}=t,c=i.length===0?o:"At path: "+i.join(".")+" -- "+o;super(c),this.value=void 0,this.key=void 0,this.type=void 0,this.refinement=void 0,this.path=void 0,this.branch=void 0,this.failures=void 0,Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>{var l;return(l=n)!=null?l:n=[t,...e()]}}}function Ge(r){return Q(r)&&typeof r[Symbol.iterator]=="function"}function Q(r){return typeof r=="object"&&r!=null}function F(r){return typeof r=="string"?JSON.stringify(r):""+r}function He(r){const{done:t,value:e}=r.next();return t?void 0:e}function Ze(r,t,e,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});const{path:o,branch:s}=t,{type:i}=e,{refinement:c,message:l="Expected a value of type `"+i+"`"+(c?" with refinement `"+c+"`":"")+", but received: `"+F(n)+"`"}=r;return{value:n,type:i,refinement:c,key:o[o.length-1],path:o,branch:s,...r,message:l}}function*Zt(r,t,e,n){Ge(r)||(r=[r]);for(const o of r){const s=Ze(o,t,e,n);s&&(yield s)}}function*$t(r,t,e){e===void 0&&(e={});const{path:n=[],branch:o=[r],coerce:s=!1,mask:i=!1}=e,c={path:n,branch:o};if(s&&(r=t.coercer(r,c),i&&t.type!=="type"&&Q(t.schema)&&Q(r)&&!Array.isArray(r)))for(const d in r)t.schema[d]===void 0&&delete r[d];let l=!0;for(const d of t.validator(r,c))l=!1,yield[d,void 0];for(let[d,f,v]of t.entries(r,c)){const g=$t(f,v,{path:d===void 0?n:[...n,d],branch:d===void 0?o:[...o,f],coerce:s,mask:i});for(const p of g)p[0]?(l=!1,yield[p[0],void 0]):s&&(f=p[1],d===void 0?r=f:r instanceof Map?r.set(d,f):r instanceof Set?r.add(f):Q(r)&&(r[d]=f))}if(l)for(const d of t.refiner(r,c))l=!1,yield[d,void 0];l&&(yield[void 0,r])}class K{constructor(t){this.TYPE=void 0,this.type=void 0,this.schema=void 0,this.coercer=void 0,this.validator=void 0,this.refiner=void 0,this.entries=void 0;const{type:e,schema:n,validator:o,refiner:s,coercer:i=l=>l,entries:c=function*(){}}=t;this.type=e,this.schema=n,this.entries=c,this.coercer=i,o?this.validator=(l,d)=>{const f=o(l,d);return Zt(f,d,this,l)}:this.validator=()=>[],s?this.refiner=(l,d)=>{const f=s(l,d);return Zt(f,d,this,l)}:this.refiner=()=>[]}assert(t){return Je(t,this)}create(t){return qt(t,this)}is(t){return pe(t,this)}mask(t){return Xe(t,this)}validate(t,e){return e===void 0&&(e={}),lt(t,this,e)}}function Je(r,t){const e=lt(r,t);if(e[0])throw e[0]}function qt(r,t){const e=lt(r,t,{coerce:!0});if(e[0])throw e[0];return e[1]}function Xe(r,t){const e=lt(r,t,{coerce:!0,mask:!0});if(e[0])throw e[0];return e[1]}function pe(r,t){return!lt(r,t)[0]}function lt(r,t,e){e===void 0&&(e={});const n=$t(r,t,e),o=He(n);if(o[0])return[new We(o[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0];{const s=o[1];return[void 0,s]}}function dt(r,t){return new K({type:r,schema:null,validator:t})}function Ye(){return dt("any",()=>!0)}function Pt(r){return new K({type:"array",schema:r,*entries(t){if(r&&Array.isArray(t))for(const[e,n]of t.entries())yield[e,n,r]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||"Expected an array value, but received: "+F(t)}})}function Qe(){return dt("boolean",r=>typeof r=="boolean")}function Jt(r){const t=F(r),e=typeof r;return new K({type:"literal",schema:e==="string"||e==="number"||e==="boolean"?r:null,validator(n){return n===r||"Expected the literal `"+t+"`, but received: "+F(n)}})}function pt(r){return new K({...r,validator:(t,e)=>t===null||r.validator(t,e),refiner:(t,e)=>t===null||r.refiner(t,e)})}function yt(){return dt("number",r=>typeof r=="number"&&!isNaN(r)||"Expected a number, but received: "+F(r))}function gt(r){return new K({...r,validator:(t,e)=>t===void 0||r.validator(t,e),refiner:(t,e)=>t===void 0||r.refiner(t,e)})}function G(){return dt("string",r=>typeof r=="string"||"Expected a string, but received: "+F(r))}function z(r){const t=Object.keys(r);return new K({type:"type",schema:r,*entries(e){if(Q(e))for(const n of t)yield[n,e[n],r[n]]},validator(e){return Q(e)||"Expected an object, but received: "+F(e)}})}function me(r){const t=r.map(e=>e.type).join(" | ");return new K({type:"union",schema:null,coercer(e,n){return(r.find(s=>{const[i]=s.validate(e,{coerce:!0});return!i})||Vt()).coercer(e,n)},validator(e,n){const o=[];for(const s of r){const[...i]=$t(e,s,n),[c]=i;if(c[0])for(const[l]of i)l&&o.push(l);else return[]}return["Expected the value to satisfy a union of `"+t+"`, but received: "+F(e),...o]}})}function Vt(){return dt("unknown",()=>!0)}function tn(r,t,e){return new K({...r,coercer:(n,o)=>pe(n,t)?r.coercer(e(n,o),o):r.coercer(n,o)})}const Xt=99;async function en(r,t,e){if(t.length<=Xt)return await Yt(r,t,e);{const n=Ve(t,Xt);return(await Promise.all(n.map(s=>Yt(r,s,e)))).flat()}}async function Yt(r,t,e){const n=e??r.commitment,{value:o,context:s}=await r.getMultipleAccountsInfoAndContext(t,n);return o.map((c,l)=>c===null?null:{publicKey:t[l],account:c,context:s})}async function nn(r,t,e,n,o){var s;e&&e.length>0&&t.sign(...e);const i=t._compile(),c=i.serialize(),d=t._serialize(c).toString("base64"),f={encoding:"base64",commitment:n??r.commitment};if(o){const m=(Array.isArray(o)?o:i.nonProgramIds()).map(b=>b.toBase58());f.accounts={encoding:"base64",addresses:m}}e&&(f.sigVerify=!0);const v=[d,f],g=await r._rpcRequest("simulateTransaction",v),p=qt(g,an);if("error"in p){let m;if("data"in p.error&&(m=(s=p.error.data)===null||s===void 0?void 0:s.logs,m&&Array.isArray(m))){const b=`
    `,L=b+m.join(b);console.error(p.error.message,L)}throw new Rt("failed to simulate transaction: "+p.error.message,m)}return p.result}function rn(r){return tn(ye(r),on,t=>"error"in t?t:{...t,result:qt(t.result,r)})}const on=ye(Vt());function ye(r){return me([z({jsonrpc:Jt("2.0"),id:G(),result:r}),z({jsonrpc:Jt("2.0"),id:G(),error:z({code:Vt(),message:G(),data:gt(Ye())})})])}function sn(r){return rn(z({context:z({slot:yt()}),value:r}))}const an=sn(z({err:pt(me([z({}),G()])),logs:pt(Pt(G())),accounts:gt(pt(Pt(pt(z({executable:Qe(),owner:G(),lamports:yt(),data:Pt(G()),rentEpoch:gt(yt())}))))),unitsConsumed:gt(yt())}));class X{constructor(t,e,n){this.connection=t,this.wallet=e,this.opts=n,this.publicKey=e==null?void 0:e.publicKey}static defaultOptions(){return{preflightCommitment:"processed",commitment:"processed"}}static local(t,e){if(it)throw new Error("Provider local is not available on browser.");e=e??X.defaultOptions();const n=new Kt(t??"http://localhost:8899",e.preflightCommitment),s=require("./nodewallet.js").default.local();return new X(n,s,e)}static env(){if(it)throw new Error("Provider env is not available on browser.");require("process");const t={}.ANCHOR_PROVIDER_URL;if(t===void 0)throw new Error("ANCHOR_PROVIDER_URL is not defined");const e=X.defaultOptions(),n=new Kt(t,e.commitment),s=require("./nodewallet.js").default.local();return new X(n,s,e)}async sendAndConfirm(t,e,n){var o,s,i,c;if(n===void 0&&(n=this.opts),nt(t))e&&t.sign(e);else if(t.feePayer=(o=t.feePayer)!==null&&o!==void 0?o:this.wallet.publicKey,t.recentBlockhash=(await this.connection.getLatestBlockhash(n.preflightCommitment)).blockhash,e)for(const d of e)t.partialSign(d);t=await this.wallet.signTransaction(t);const l=t.serialize();try{return await Qt(this.connection,l,n)}catch(d){if(d instanceof Bt){const f=Gt(nt(t)?((s=t.signatures)===null||s===void 0?void 0:s[0])||new Uint8Array:(i=t.signature)!==null&&i!==void 0?i:new Uint8Array),v=await this.connection.getTransaction(f,{commitment:"confirmed"});if(v){const g=(c=v.meta)===null||c===void 0?void 0:c.logMessages;throw g?new Rt(d.message,g):d}else throw d}else throw d}}async sendAll(t,e){var n,o,s;e===void 0&&(e=this.opts);const i=(await this.connection.getLatestBlockhash(e.preflightCommitment)).blockhash;let c=t.map(f=>{var v,g;if(nt(f.tx)){let p=f.tx;return f.signers&&p.sign(f.signers),p}else{let p=f.tx,m=(v=f.signers)!==null&&v!==void 0?v:[];return p.feePayer=(g=p.feePayer)!==null&&g!==void 0?g:this.wallet.publicKey,p.recentBlockhash=i,m.forEach(b=>{p.partialSign(b)}),p}});const l=await this.wallet.signAllTransactions(c),d=[];for(let f=0;f<c.length;f+=1){const v=l[f],g=v.serialize();try{d.push(await Qt(this.connection,g,e))}catch(p){if(p instanceof Bt){const m=Gt(nt(v)?((n=v.signatures)===null||n===void 0?void 0:n[0])||new Uint8Array:(o=v.signature)!==null&&o!==void 0?o:new Uint8Array),b=await this.connection.getTransaction(m,{commitment:"confirmed"});if(b){const L=(s=b.meta)===null||s===void 0?void 0:s.logMessages;throw L?new Rt(p.message,L):p}else throw p}else throw p}}return d}async simulate(t,e,n,o){let s=(await this.connection.getLatestBlockhash(n??this.connection.commitment)).blockhash,i;if(nt(t)?(e&&(t.sign(e),t=await this.wallet.signTransaction(t)),i=await this.connection.simulateTransaction(t,{commitment:n})):(t.feePayer=t.feePayer||this.wallet.publicKey,t.recentBlockhash=s,e&&(t=await this.wallet.signTransaction(t)),i=await nn(this.connection,t,e,n,o)),i.value.err)throw new cn(i.value);return i.value}}class cn extends Error{constructor(t,e){super(e),this.simulationResponse=t}}async function Qt(r,t,e){const n=e&&{skipPreflight:e.skipPreflight,preflightCommitment:e.preflightCommitment||e.commitment},o=await r.sendRawTransaction(t,n),s=(await r.confirmTransaction(o,e&&e.commitment)).value;if(s.err)throw new Bt(`Raw transaction ${o} failed (${JSON.stringify(s)})`);return o}class Bt extends Error{constructor(t){super(t)}}function Nt(){return X.local()}const un=new Map;function ge(r){return un.get(r)!==void 0}class wt extends Error{constructor(t){super(t),this.name="IdlError"}}class ft{constructor(t){this.stack=t}static parse(t){var e;const n=/^Program (\w*) invoke/,o=/^Program \w* success/,s=[];for(let i=0;i<t.length;i++){if(o.exec(t[i])){s.pop();continue}const c=(e=n.exec(t[i]))===null||e===void 0?void 0:e[1];!c||s.push(new k(c))}return new ft(s)}}class st extends Error{constructor(t,e,n,o,s,i){super(n.join(`
`).replace("Program log: ","")),this.errorLogs=n,this.logs=o,this.error={errorCode:t,errorMessage:e,comparedValues:i,origin:s},this._programErrorStack=ft.parse(o)}static parse(t){if(!t)return null;const e=t.findIndex(g=>g.startsWith("Program log: AnchorError"));if(e===-1)return null;const n=t[e],o=[n];let s;if(e+1<t.length){if(t[e+1]==="Program log: Left:"){const g=/^Program log: (.*)$/,p=g.exec(t[e+2])[1],m=g.exec(t[e+4])[1];s=[new k(p),new k(m)],o.push(...t.slice(e+1,e+5))}else if(t[e+1].startsWith("Program log: Left:")){const g=/^Program log: (Left|Right): (.*)$/,p=g.exec(t[e+1])[2],m=g.exec(t[e+2])[2];o.push(...t.slice(e+1,e+3)),s=[p,m]}}const c=/^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n),d=/^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n),v=/^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n);if(c){const[g,p,m]=c.slice(1,4),b={code:g,number:parseInt(p)};return new st(b,m,o,t,void 0,s)}else if(d){const[g,p,m,b,L]=d.slice(1,6),T={code:m,number:parseInt(b)},$={file:g,line:parseInt(p)};return new st(T,L,o,t,$,s)}else if(v){const[g,p,m,b]=v.slice(1,5),L=g,T={code:p,number:parseInt(m)};return new st(T,b,o,t,L,s)}else return null}get program(){return this._programErrorStack.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){return this._programErrorStack.stack}toString(){return this.message}}class vt extends Error{constructor(t,e,n){super(),this.code=t,this.msg=e,this.logs=n,n&&(this._programErrorStack=ft.parse(n))}static parse(t,e){const n=t.toString();let o;if(n.includes("custom program error:")){let c=n.split("custom program error: ");if(c.length!==2)return null;o=c[1]}else{const c=n.match(/"Custom":([0-9]+)}/g);if(!c||c.length>1)return null;o=c[0].match(/([0-9]+)/g)[0]}let s;try{s=parseInt(o)}catch{return null}let i=e.get(s);return i!==void 0?new vt(s,i,t.logs):(i=ln.get(s),i!==void 0?new vt(s,i,t.logs):null)}get program(){var t;return(t=this._programErrorStack)===null||t===void 0?void 0:t.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){var t;return(t=this._programErrorStack)===null||t===void 0?void 0:t.stack}toString(){return this.msg}}function we(r,t){ge("debug-logs")&&console.log("Translating error:",r);const e=st.parse(r.logs);if(e)return e;const n=vt.parse(r,t);if(n)return n;if(r.logs){const o={get:function(s,i){return i==="programErrorStack"?s.programErrorStack.stack:i==="program"?s.programErrorStack.stack[r.programErrorStack.stack.length-1]:Reflect.get(...arguments)}};return r.programErrorStack=ft.parse(r.logs),new Proxy(r,o)}return r}const w={InstructionMissing:100,InstructionFallbackNotFound:101,InstructionDidNotDeserialize:102,InstructionDidNotSerialize:103,IdlInstructionStub:1e3,IdlInstructionInvalidProgram:1001,ConstraintMut:2e3,ConstraintHasOne:2001,ConstraintSigner:2002,ConstraintRaw:2003,ConstraintOwner:2004,ConstraintRentExempt:2005,ConstraintSeeds:2006,ConstraintExecutable:2007,ConstraintState:2008,ConstraintAssociated:2009,ConstraintAssociatedInit:2010,ConstraintClose:2011,ConstraintAddress:2012,ConstraintZero:2013,ConstraintTokenMint:2014,ConstraintTokenOwner:2015,ConstraintMintMintAuthority:2016,ConstraintMintFreezeAuthority:2017,ConstraintMintDecimals:2018,ConstraintSpace:2019,ConstraintAccountIsNone:2020,RequireViolated:2500,RequireEqViolated:2501,RequireKeysEqViolated:2502,RequireNeqViolated:2503,RequireKeysNeqViolated:2504,RequireGtViolated:2505,RequireGteViolated:2506,AccountDiscriminatorAlreadySet:3e3,AccountDiscriminatorNotFound:3001,AccountDiscriminatorMismatch:3002,AccountDidNotDeserialize:3003,AccountDidNotSerialize:3004,AccountNotEnoughKeys:3005,AccountNotMutable:3006,AccountOwnedByWrongProgram:3007,InvalidProgramId:3008,InvalidProgramExecutable:3009,AccountNotSigner:3010,AccountNotSystemOwned:3011,AccountNotInitialized:3012,AccountNotProgramData:3013,AccountNotAssociatedTokenAccount:3014,AccountSysvarMismatch:3015,AccountReallocExceedsLimit:3016,AccountDuplicateReallocs:3017,DeclaredProgramIdMismatch:4100,Deprecated:5e3},ln=new Map([[w.InstructionMissing,"8 byte instruction identifier not provided"],[w.InstructionFallbackNotFound,"Fallback functions are not supported"],[w.InstructionDidNotDeserialize,"The program could not deserialize the given instruction"],[w.InstructionDidNotSerialize,"The program could not serialize the given instruction"],[w.IdlInstructionStub,"The program was compiled without idl instructions"],[w.IdlInstructionInvalidProgram,"The transaction was given an invalid program for the IDL instruction"],[w.ConstraintMut,"A mut constraint was violated"],[w.ConstraintHasOne,"A has one constraint was violated"],[w.ConstraintSigner,"A signer constraint was violated"],[w.ConstraintRaw,"A raw constraint was violated"],[w.ConstraintOwner,"An owner constraint was violated"],[w.ConstraintRentExempt,"A rent exemption constraint was violated"],[w.ConstraintSeeds,"A seeds constraint was violated"],[w.ConstraintExecutable,"An executable constraint was violated"],[w.ConstraintState,"Deprecated Error, feel free to replace with something else"],[w.ConstraintAssociated,"An associated constraint was violated"],[w.ConstraintAssociatedInit,"An associated init constraint was violated"],[w.ConstraintClose,"A close constraint was violated"],[w.ConstraintAddress,"An address constraint was violated"],[w.ConstraintZero,"Expected zero account discriminant"],[w.ConstraintTokenMint,"A token mint constraint was violated"],[w.ConstraintTokenOwner,"A token owner constraint was violated"],[w.ConstraintMintMintAuthority,"A mint mint authority constraint was violated"],[w.ConstraintMintFreezeAuthority,"A mint freeze authority constraint was violated"],[w.ConstraintMintDecimals,"A mint decimals constraint was violated"],[w.ConstraintSpace,"A space constraint was violated"],[w.ConstraintAccountIsNone,"A required account for the constraint is None"],[w.RequireViolated,"A require expression was violated"],[w.RequireEqViolated,"A require_eq expression was violated"],[w.RequireKeysEqViolated,"A require_keys_eq expression was violated"],[w.RequireNeqViolated,"A require_neq expression was violated"],[w.RequireKeysNeqViolated,"A require_keys_neq expression was violated"],[w.RequireGtViolated,"A require_gt expression was violated"],[w.RequireGteViolated,"A require_gte expression was violated"],[w.AccountDiscriminatorAlreadySet,"The account discriminator was already set on this account"],[w.AccountDiscriminatorNotFound,"No 8 byte discriminator was found on the account"],[w.AccountDiscriminatorMismatch,"8 byte discriminator did not match what was expected"],[w.AccountDidNotDeserialize,"Failed to deserialize the account"],[w.AccountDidNotSerialize,"Failed to serialize the account"],[w.AccountNotEnoughKeys,"Not enough account keys given to the instruction"],[w.AccountNotMutable,"The given account is not mutable"],[w.AccountOwnedByWrongProgram,"The given account is owned by a different program than expected"],[w.InvalidProgramId,"Program ID was not as expected"],[w.InvalidProgramExecutable,"Program account is not executable"],[w.AccountNotSigner,"The given account did not sign"],[w.AccountNotSystemOwned,"The given account is not owned by the system program"],[w.AccountNotInitialized,"The program expected this account to be already initialized"],[w.AccountNotProgramData,"The given account is not a program data account"],[w.AccountNotAssociatedTokenAccount,"The given account is not the associated token account"],[w.AccountSysvarMismatch,"The given public key does not match the required sysvar"],[w.AccountReallocExceedsLimit,"The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"],[w.AccountDuplicateReallocs,"The account was duplicated for more than one reallocation"],[w.DeclaredProgramIdMismatch,"The declared program id does not match the actual program id"],[w.Deprecated,"The API being used is deprecated and should no longer be used"]]);var jt={exports:{}};const dn=/[\p{Lu}]/u,fn=/[\p{Ll}]/u,te=/^[\p{Lu}](?![\p{Lu}])/gu,ve=/([\p{Alpha}\p{N}_]|$)/u,_e=/[_.\- ]+/,hn=new RegExp("^"+_e.source),ee=new RegExp(_e.source+ve.source,"gu"),ne=new RegExp("\\d+"+ve.source,"gu"),pn=(r,t,e)=>{let n=!1,o=!1,s=!1;for(let i=0;i<r.length;i++){const c=r[i];n&&dn.test(c)?(r=r.slice(0,i)+"-"+r.slice(i),n=!1,s=o,o=!0,i++):o&&s&&fn.test(c)?(r=r.slice(0,i-1)+"-"+r.slice(i-1),s=o,o=!1,n=!0):(n=t(c)===c&&e(c)!==c,s=o,o=e(c)===c&&t(c)!==c)}return r},mn=(r,t)=>(te.lastIndex=0,r.replace(te,e=>t(e))),yn=(r,t)=>(ee.lastIndex=0,ne.lastIndex=0,r.replace(ee,(e,n)=>t(n)).replace(ne,e=>t(e))),Ae=(r,t)=>{if(!(typeof r=="string"||Array.isArray(r)))throw new TypeError("Expected the input to be `string | string[]`");if(t={pascalCase:!1,preserveConsecutiveUppercase:!1,...t},Array.isArray(r)?r=r.map(s=>s.trim()).filter(s=>s.length).join("-"):r=r.trim(),r.length===0)return"";const e=t.locale===!1?s=>s.toLowerCase():s=>s.toLocaleLowerCase(t.locale),n=t.locale===!1?s=>s.toUpperCase():s=>s.toLocaleUpperCase(t.locale);return r.length===1?t.pascalCase?n(r):e(r):(r!==e(r)&&(r=pn(r,e,n)),r=r.replace(hn,""),t.preserveConsecutiveUppercase?r=mn(r,e):r=e(r),t.pascalCase&&(r=n(r.charAt(0))+r.slice(1)),yn(r,n))};jt.exports=Ae;jt.exports.default=Ae;var S=jt.exports,xt=function(){return xt=Object.assign||function(t){for(var e,n=1,o=arguments.length;n<o;n++){e=arguments[n];for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s])}return t},xt.apply(this,arguments)};var Mt=function(){return Mt=Object.assign||function(t){for(var e,n=1,o=arguments.length;n<o;n++){e=arguments[n];for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s])}return t},Mt.apply(this,arguments)};function gn(r){return r.toLowerCase()}var wn=[/([a-z0-9])([A-Z])/g,/([A-Z])([A-Z][a-z])/g],vn=/[^A-Z0-9]+/gi;function _n(r,t){t===void 0&&(t={});for(var e=t.splitRegexp,n=e===void 0?wn:e,o=t.stripRegexp,s=o===void 0?vn:o,i=t.transform,c=i===void 0?gn:i,l=t.delimiter,d=l===void 0?" ":l,f=re(re(r,n,"$1\0$2"),s,"\0"),v=0,g=f.length;f.charAt(v)==="\0";)v++;for(;f.charAt(g-1)==="\0";)g--;return f.slice(v,g).split("\0").map(c).join(d)}function re(r,t,e){return t instanceof RegExp?r.replace(t,e):t.reduce(function(n,o){return n.replace(o,e)},r)}function An(r,t){return t===void 0&&(t={}),_n(r,Mt({delimiter:"."},t))}function bn(r,t){return t===void 0&&(t={}),An(r,xt({delimiter:"_"},t))}var A={};(function(r){var t=Ot&&Ot.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(r,"__esModule",{value:!0}),r.map=r.array=r.rustEnum=r.str=r.vecU8=r.tagged=r.vec=r.bool=r.option=r.publicKey=r.i256=r.u256=r.i128=r.u128=r.i64=r.u64=r.struct=r.f64=r.f32=r.i32=r.u32=r.i16=r.u16=r.i8=r.u8=void 0;const e=Wt,n=Me,o=t(Te.exports);var s=Wt;Object.defineProperty(r,"u8",{enumerable:!0,get:function(){return s.u8}}),Object.defineProperty(r,"i8",{enumerable:!0,get:function(){return s.s8}}),Object.defineProperty(r,"u16",{enumerable:!0,get:function(){return s.u16}}),Object.defineProperty(r,"i16",{enumerable:!0,get:function(){return s.s16}}),Object.defineProperty(r,"u32",{enumerable:!0,get:function(){return s.u32}}),Object.defineProperty(r,"i32",{enumerable:!0,get:function(){return s.s32}}),Object.defineProperty(r,"f32",{enumerable:!0,get:function(){return s.f32}}),Object.defineProperty(r,"f64",{enumerable:!0,get:function(){return s.f64}}),Object.defineProperty(r,"struct",{enumerable:!0,get:function(){return s.struct}});class i extends e.Layout{constructor(h,a,u){super(h,u),this.blob=(0,e.blob)(h),this.signed=a}decode(h,a=0){const u=new o.default(this.blob.decode(h,a),10,"le");return this.signed?u.fromTwos(this.span*8).clone():u}encode(h,a,u=0){return this.signed&&(h=h.toTwos(this.span*8)),this.blob.encode(h.toArrayLike(Buffer,"le",this.span),a,u)}}function c(_){return new i(8,!1,_)}r.u64=c;function l(_){return new i(8,!0,_)}r.i64=l;function d(_){return new i(16,!1,_)}r.u128=d;function f(_){return new i(16,!0,_)}r.i128=f;function v(_){return new i(32,!1,_)}r.u256=v;function g(_){return new i(32,!0,_)}r.i256=g;class p extends e.Layout{constructor(h,a,u,y){super(h.span,y),this.layout=h,this.decoder=a,this.encoder=u}decode(h,a){return this.decoder(this.layout.decode(h,a))}encode(h,a,u){return this.layout.encode(this.encoder(h),a,u)}getSpan(h,a){return this.layout.getSpan(h,a)}}function m(_){return new p((0,e.blob)(32),h=>new n.PublicKey(h),h=>h.toBuffer(),_)}r.publicKey=m;class b extends e.Layout{constructor(h,a){super(-1,a),this.layout=h,this.discriminator=(0,e.u8)()}encode(h,a,u=0){return h==null?this.discriminator.encode(0,a,u):(this.discriminator.encode(1,a,u),this.layout.encode(h,a,u+1)+1)}decode(h,a=0){const u=this.discriminator.decode(h,a);if(u===0)return null;if(u===1)return this.layout.decode(h,a+1);throw new Error("Invalid option "+this.property)}getSpan(h,a=0){const u=this.discriminator.decode(h,a);if(u===0)return 1;if(u===1)return this.layout.getSpan(h,a+1)+1;throw new Error("Invalid option "+this.property)}}function L(_,h){return new b(_,h)}r.option=L;function T(_){return new p((0,e.u8)(),$,W,_)}r.bool=T;function $(_){if(_===0)return!1;if(_===1)return!0;throw new Error("Invalid bool: "+_)}function W(_){return _?1:0}function Z(_,h){const a=(0,e.u32)("length"),u=(0,e.struct)([a,(0,e.seq)(_,(0,e.offset)(a,-a.span),"values")]);return new p(u,({values:y})=>y,y=>({values:y}),h)}r.vec=Z;function M(_,h,a){const u=(0,e.struct)([c("tag"),h.replicate("data")]);function y({tag:E,data:C}){if(!E.eq(_))throw new Error("Invalid tag, expected: "+_.toString("hex")+", got: "+E.toString("hex"));return C}return new p(u,y,E=>({tag:_,data:E}),a)}r.tagged=M;function J(_){const h=(0,e.u32)("length"),a=(0,e.struct)([h,(0,e.blob)((0,e.offset)(h,-h.span),"data")]);return new p(a,({data:u})=>u,u=>({data:u}),_)}r.vecU8=J;function tt(_){return new p(J(),h=>h.toString("utf-8"),h=>Buffer.from(h,"utf-8"),_)}r.str=tt;function q(_,h,a){const u=(0,e.union)(a??(0,e.u8)(),h);return _.forEach((y,E)=>u.addVariant(E,y,y.property)),u}r.rustEnum=q;function It(_,h,a){const u=(0,e.struct)([(0,e.seq)(_,h,"values")]);return new p(u,({values:y})=>y,y=>({values:y}),a)}r.array=It;class St extends e.Layout{constructor(h,a,u){super(h.span+a.span,u),this.keyLayout=h,this.valueLayout=a}decode(h,a){a=a||0;const u=this.keyLayout.decode(h,a),y=this.valueLayout.decode(h,a+this.keyLayout.getSpan(h,a));return[u,y]}encode(h,a,u){u=u||0;const y=this.keyLayout.encode(h[0],a,u),E=this.valueLayout.encode(h[1],a,u+y);return y+E}getSpan(h,a){return this.keyLayout.getSpan(h,a)+this.valueLayout.getSpan(h,a)}}function B(_,h,a){const u=(0,e.u32)("length"),y=(0,e.struct)([u,(0,e.seq)(new St(_,h),(0,e.offset)(u,-u.span),"values")]);return new p(y,({values:E})=>new Map(E),E=>({values:Array.from(E.entries())}),a)}r.map=B})(A);class R{static fieldLayout(t,e){const n=t.name!==void 0?S(t.name):void 0;switch(t.type){case"bool":return A.bool(n);case"u8":return A.u8(n);case"i8":return A.i8(n);case"u16":return A.u16(n);case"i16":return A.i16(n);case"u32":return A.u32(n);case"i32":return A.i32(n);case"f32":return A.f32(n);case"u64":return A.u64(n);case"i64":return A.i64(n);case"f64":return A.f64(n);case"u128":return A.u128(n);case"i128":return A.i128(n);case"u256":return A.u256(n);case"i256":return A.i256(n);case"bytes":return A.vecU8(n);case"string":return A.str(n);case"publicKey":return A.publicKey(n);default:{if("vec"in t.type)return A.vec(R.fieldLayout({name:void 0,type:t.type.vec},e),n);if("option"in t.type)return A.option(R.fieldLayout({name:void 0,type:t.type.option},e),n);if("defined"in t.type){if(!e)throw new wt("User defined types not provided");const o=t.type.defined,s=e.filter(i=>i.name===o);if(s.length!==1)throw new wt(`Type not found: ${JSON.stringify(t)}`);return R.typeDefLayout(s[0],e,n)}else if("array"in t.type){let o=t.type.array[0],s=t.type.array[1],i=R.fieldLayout({name:void 0,type:o},e);return A.array(i,s,n)}else throw new Error(`Not yet implemented: ${t}`)}}}static typeDefLayout(t,e=[],n){switch(t.type.kind){case"struct":{const o=t.type.fields.map(s=>R.fieldLayout(s,e));return A.struct(o,n)}case"enum":{let o=t.type.variants.map(s=>{const i=S(s.name);if(!s.fields)return A.struct([],i);const c=s.fields.map((l,d)=>l!=null&&l.name?R.fieldLayout(l,e):R.fieldLayout({type:l,name:d.toString()},e));return A.struct(c,i)});return n!==void 0?A.rustEnum(o).replicate(n):A.rustEnum(o,n)}case"alias":return R.fieldLayout({type:t.type.value,name:t.name},e)}}}const oe="global";class zt{constructor(t){this.idl=t,this.ixLayout=zt.parseIxLayout(t);const e=new Map;t.instructions.forEach(n=>{const o=se(oe,n.name);e.set(ot.encode(o),{layout:this.ixLayout.get(n.name),name:n.name})}),this.sighashLayouts=e}encode(t,e){return this._encode(oe,t,e)}_encode(t,e,n){const o=D.Buffer.alloc(1e3),s=S(e),i=this.ixLayout.get(s);if(!i)throw new Error(`Unknown method: ${s}`);const c=i.encode(n,o),l=o.slice(0,c);return D.Buffer.concat([se(t,e),l])}static parseIxLayout(t){const e=t.instructions.map(n=>{let o=n.args.map(i=>{var c,l;return R.fieldLayout(i,Array.from([...(c=t.accounts)!==null&&c!==void 0?c:[],...(l=t.types)!==null&&l!==void 0?l:[]]))});const s=S(n.name);return[s,A.struct(o,s)]});return new Map(e)}decode(t,e="hex"){typeof t=="string"&&(t=e==="hex"?D.Buffer.from(t,"hex"):ot.decode(t));let n=ot.encode(t.slice(0,8)),o=t.slice(8);const s=this.sighashLayouts.get(n);return s?{data:s.layout.decode(o),name:s.name}:null}format(t,e){return U.format(t,e,this.idl)}}class U{static format(t,e,n){const o=n.instructions.filter(l=>t.name===l.name)[0];if(o===void 0)return console.error("Invalid instruction given"),null;const s=o.args.map(l=>({name:l.name,type:U.formatIdlType(l.type),data:U.formatIdlData(l,t.data[l.name],n.types)})),i=U.flattenIdlAccounts(o.accounts),c=e.map((l,d)=>d<i.length?{name:i[d].name,...l}:{name:void 0,...l});return{args:s,accounts:c}}static formatIdlType(t){if(typeof t=="string")return t;if("vec"in t)return`Vec<${this.formatIdlType(t.vec)}>`;if("option"in t)return`Option<${this.formatIdlType(t.option)}>`;if("defined"in t)return t.defined;if("array"in t)return`Array<${t.array[0]}; ${t.array[1]}>`;throw new Error(`Unknown IDL type: ${t}`)}static formatIdlData(t,e,n){if(typeof t.type=="string")return e.toString();if(t.type.hasOwnProperty("vec"))return"["+e.map(o=>this.formatIdlData({name:"",type:t.type.vec},o)).join(", ")+"]";if(t.type.hasOwnProperty("option"))return e===null?"null":this.formatIdlData({name:"",type:t.type.option},e,n);if(t.type.hasOwnProperty("defined")){if(n===void 0)throw new Error("User defined types not provided");const o=n.filter(s=>s.name===t.type.defined);if(o.length!==1)throw new Error(`Type not found: ${t.type.defined}`);return U.formatIdlDataDefined(o[0],e,n)}return"unknown"}static formatIdlDataDefined(t,e,n){switch(t.type.kind){case"struct":{const o=t.type,s=Object.keys(e).map(i=>{const c=o.fields.find(l=>l.name===i);if(!c)throw new Error("Unable to find type");return i+": "+U.formatIdlData(c,e[i],n)}).join(", ");return"{ "+s+" }"}case"enum":{if(t.type.variants.length===0)return"{}";if(t.type.variants[0].name){const o=t.type.variants,s=Object.keys(e)[0],i=e[s],c=Object.keys(i).map(d=>{var f;const v=i[d],g=(f=o[s])===null||f===void 0?void 0:f.find(p=>p.name===d);if(!g)throw new Error("Unable to find variant");return d+": "+U.formatIdlData(g,v,n)}).join(", "),l=S(s,{pascalCase:!0});return c.length===0?l:`${l} { ${c} }`}else return"Tuple formatting not yet implemented"}case"alias":return U.formatIdlType(t.type.value)}}static flattenIdlAccounts(t,e){return t.map(n=>{const o=En(n.name);if(n.hasOwnProperty("accounts")){const s=e?`${e} > ${o}`:o;return U.flattenIdlAccounts(n.accounts,s)}else return{...n,name:e?`${e} > ${o}`:o}}).flat()}}function En(r){const t=r.replace(/([A-Z])/g," $1");return t.charAt(0).toUpperCase()+t.slice(1)}function se(r,t){let e=bn(t),n=`${r}:${e}`;return D.Buffer.from(ce(n).slice(0,8))}function be(r,t){switch(t.type.kind){case"struct":return t.type.fields.map(e=>H(r,e.type)).reduce((e,n)=>e+n,0);case"enum":{const e=t.type.variants.map(n=>n.fields?n.fields.map(o=>typeof o=="object"&&"name"in o?H(r,o.type):H(r,o)).reduce((o,s)=>o+s,0):0);return Math.max(...e)+1}case"alias":return H(r,t.type.value)}}function H(r,t){var e,n;switch(t){case"bool":return 1;case"u8":return 1;case"i8":return 1;case"i16":return 2;case"u16":return 2;case"u32":return 4;case"i32":return 4;case"f32":return 4;case"u64":return 8;case"i64":return 8;case"f64":return 8;case"u128":return 16;case"i128":return 16;case"u256":return 32;case"i256":return 32;case"bytes":return 1;case"string":return 1;case"publicKey":return 32;default:if("vec"in t)return 1;if("option"in t)return 1+H(r,t.option);if("coption"in t)return 4+H(r,t.coption);if("defined"in t){const o=(n=(e=r.types)===null||e===void 0?void 0:e.filter(i=>i.name===t.defined))!==null&&n!==void 0?n:[];if(o.length!==1)throw new wt(`Type not found: ${JSON.stringify(t)}`);let s=o[0];return be(r,s)}if("array"in t){let o=t.array[0],s=t.array[1];return H(r,o)*s}throw new Error(`Invalid type ${JSON.stringify(t)}`)}}const Dt=8;function Ee(r){return Buffer.from(ce(r).slice(0,Dt))}class Y{constructor(t){if(t.accounts===void 0){this.accountLayouts=new Map;return}const e=t.accounts.map(n=>[n.name,R.typeDefLayout(n,t.types)]);this.accountLayouts=new Map(e),this.idl=t}async encode(t,e){const n=D.Buffer.alloc(1e3),o=this.accountLayouts.get(t);if(!o)throw new Error(`Unknown account: ${t}`);const s=o.encode(e,n);let i=n.slice(0,s),c=Y.accountDiscriminator(t);return D.Buffer.concat([c,i])}decode(t,e){if(Y.accountDiscriminator(t).compare(e.slice(0,8)))throw new Error("Invalid account discriminator");return this.decodeUnchecked(t,e)}decodeAny(t){const e=t.slice(0,8),n=Array.from(this.accountLayouts.keys()).find(o=>Y.accountDiscriminator(o).equals(e));if(!n)throw new Error("Account descriminator not found");return this.decodeUnchecked(n,t)}decodeUnchecked(t,e){const n=e.subarray(Dt),o=this.accountLayouts.get(t);if(!o)throw new Error(`Unknown account: ${t}`);return o.decode(n)}memcmp(t,e){const n=Y.accountDiscriminator(t);return{offset:0,bytes:ot.encode(e?D.Buffer.concat([n,e]):n)}}size(t){var e;return Dt+((e=be(this.idl,t))!==null&&e!==void 0?e:0)}static accountDiscriminator(t){const e=`account:${S(t,{pascalCase:!0,preserveConsecutiveUppercase:!0})}`;return Ee(e)}}class In{constructor(t){if(t.events===void 0){this.layouts=new Map;return}const e=t.events.map(n=>{let o={name:n.name,type:{kind:"struct",fields:n.fields.map(s=>({name:s.name,type:s.type}))}};return[n.name,R.typeDefLayout(o,t.types)]});this.layouts=new Map(e),this.discriminators=new Map(t.events===void 0?[]:t.events.map(n=>[Ht(Sn(n.name)),n.name]))}decode(t){let e;try{e=fe(t)}catch{return null}const n=Ht(e.slice(0,8)),o=this.discriminators.get(n);if(o===void 0)return null;const s=this.layouts.get(o);if(!s)throw new Error(`Unknown event: ${o}`);return{data:s.decode(e.slice(8)),name:o}}}function Sn(r){return Ee(`event:${r}`)}class Ln{constructor(t){if(t.types===void 0){this.typeLayouts=new Map;return}const e=t.types.map(n=>[n.name,R.typeDefLayout(n,t.types)]);this.typeLayouts=new Map(e),this.idl=t}encode(t,e){const n=D.Buffer.alloc(1e3),o=this.typeLayouts.get(t);if(!o)throw new Error(`Unknown type: ${t}`);const s=o.encode(e,n);return n.slice(0,s)}decode(t,e){const n=this.typeLayouts.get(t);if(!n)throw new Error(`Unknown type: ${t}`);return n.decode(e)}}class Ie{constructor(t){this.instruction=new zt(t),this.accounts=new Y(t),this.events=new In(t),this.types=new Ln(t)}}class Cn extends At{constructor(t){super(-1,t),this.property=t,this.layout=P([V("length"),V("lengthPadding"),ut(De(V(),-8),"chars")],this.property)}encode(t,e,n=0){if(t==null)return this.layout.span;const o={chars:Buffer.from(t,"utf8")};return this.layout.encode(o,e,n)}decode(t,e=0){return this.layout.decode(t,e).chars.toString()}getSpan(t,e=0){return V().span+V().span+new ue(new Uint8Array(t).slice(e,e+4),10,"le").toNumber()}}function bt(r){return new Cn(r)}function x(r){return ut(32,r)}const O=de(V("instruction"));O.addVariant(0,P([j("lamports"),j("space"),x("owner")]),"createAccount");O.addVariant(1,P([x("owner")]),"assign");O.addVariant(2,P([j("lamports")]),"transfer");O.addVariant(3,P([x("base"),bt("seed"),j("lamports"),j("space"),x("owner")]),"createAccountWithSeed");O.addVariant(4,P([x("authorized")]),"advanceNonceAccount");O.addVariant(5,P([j("lamports")]),"withdrawNonceAccount");O.addVariant(6,P([x("authorized")]),"initializeNonceAccount");O.addVariant(7,P([x("authorized")]),"authorizeNonceAccount");O.addVariant(8,P([j("space")]),"allocate");O.addVariant(9,P([x("base"),bt("seed"),j("space"),x("owner")]),"allocateWithSeed");O.addVariant(10,P([x("base"),bt("seed"),x("owner")]),"assignWithSeed");O.addVariant(11,P([j("lamports"),bt("seed"),x("owner")]),"transferWithSeed");Math.max(...Object.values(O.registry).map(r=>r.span));class Pn extends At{constructor(t,e,n,o){super(t.span,o),this.layout=t,this.decoder=e,this.encoder=n}decode(t,e){return this.decoder(this.layout.decode(t,e))}encode(t,e,n){return this.layout.encode(this.encoder(t),e,n)}getSpan(t,e){return this.layout.getSpan(t,e)}}function ie(r){return new Pn(ut(32),t=>new k(t),t=>t.toBuffer(),r)}P([V("version"),V("state"),ie("authorizedPubkey"),ie("nonce"),P([Ue("lamportsPerSignature")],"feeCalculator")]);function kn(r,...t){let e=[D.Buffer.from([97,110,99,104,111,114])];t.forEach(o=>{e.push(o instanceof D.Buffer?o:N(o).toBuffer())});const[n]=k.findProgramAddressSync(e,N(r));return n}const Tn=new k("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),Rn=new k("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");var ae={exports:{}};(function(r,t){var e=typeof self<"u"?self:Ot,n=function(){function s(){this.fetch=!1,this.DOMException=e.DOMException}return s.prototype=e,new s}();(function(s){(function(i){var c={searchParams:"URLSearchParams"in s,iterable:"Symbol"in s&&"iterator"in Symbol,blob:"FileReader"in s&&"Blob"in s&&function(){try{return new Blob,!0}catch{return!1}}(),formData:"FormData"in s,arrayBuffer:"ArrayBuffer"in s};function l(a){return a&&DataView.prototype.isPrototypeOf(a)}if(c.arrayBuffer)var d=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],f=ArrayBuffer.isView||function(a){return a&&d.indexOf(Object.prototype.toString.call(a))>-1};function v(a){if(typeof a!="string"&&(a=String(a)),/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(a))throw new TypeError("Invalid character in header field name");return a.toLowerCase()}function g(a){return typeof a!="string"&&(a=String(a)),a}function p(a){var u={next:function(){var y=a.shift();return{done:y===void 0,value:y}}};return c.iterable&&(u[Symbol.iterator]=function(){return u}),u}function m(a){this.map={},a instanceof m?a.forEach(function(u,y){this.append(y,u)},this):Array.isArray(a)?a.forEach(function(u){this.append(u[0],u[1])},this):a&&Object.getOwnPropertyNames(a).forEach(function(u){this.append(u,a[u])},this)}m.prototype.append=function(a,u){a=v(a),u=g(u);var y=this.map[a];this.map[a]=y?y+", "+u:u},m.prototype.delete=function(a){delete this.map[v(a)]},m.prototype.get=function(a){return a=v(a),this.has(a)?this.map[a]:null},m.prototype.has=function(a){return this.map.hasOwnProperty(v(a))},m.prototype.set=function(a,u){this.map[v(a)]=g(u)},m.prototype.forEach=function(a,u){for(var y in this.map)this.map.hasOwnProperty(y)&&a.call(u,this.map[y],y,this)},m.prototype.keys=function(){var a=[];return this.forEach(function(u,y){a.push(y)}),p(a)},m.prototype.values=function(){var a=[];return this.forEach(function(u){a.push(u)}),p(a)},m.prototype.entries=function(){var a=[];return this.forEach(function(u,y){a.push([y,u])}),p(a)},c.iterable&&(m.prototype[Symbol.iterator]=m.prototype.entries);function b(a){if(a.bodyUsed)return Promise.reject(new TypeError("Already read"));a.bodyUsed=!0}function L(a){return new Promise(function(u,y){a.onload=function(){u(a.result)},a.onerror=function(){y(a.error)}})}function T(a){var u=new FileReader,y=L(u);return u.readAsArrayBuffer(a),y}function $(a){var u=new FileReader,y=L(u);return u.readAsText(a),y}function W(a){for(var u=new Uint8Array(a),y=new Array(u.length),E=0;E<u.length;E++)y[E]=String.fromCharCode(u[E]);return y.join("")}function Z(a){if(a.slice)return a.slice(0);var u=new Uint8Array(a.byteLength);return u.set(new Uint8Array(a)),u.buffer}function M(){return this.bodyUsed=!1,this._initBody=function(a){this._bodyInit=a,a?typeof a=="string"?this._bodyText=a:c.blob&&Blob.prototype.isPrototypeOf(a)?this._bodyBlob=a:c.formData&&FormData.prototype.isPrototypeOf(a)?this._bodyFormData=a:c.searchParams&&URLSearchParams.prototype.isPrototypeOf(a)?this._bodyText=a.toString():c.arrayBuffer&&c.blob&&l(a)?(this._bodyArrayBuffer=Z(a.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):c.arrayBuffer&&(ArrayBuffer.prototype.isPrototypeOf(a)||f(a))?this._bodyArrayBuffer=Z(a):this._bodyText=a=Object.prototype.toString.call(a):this._bodyText="",this.headers.get("content-type")||(typeof a=="string"?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):c.searchParams&&URLSearchParams.prototype.isPrototypeOf(a)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},c.blob&&(this.blob=function(){var a=b(this);if(a)return a;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?b(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(T)}),this.text=function(){var a=b(this);if(a)return a;if(this._bodyBlob)return $(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(W(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},c.formData&&(this.formData=function(){return this.text().then(It)}),this.json=function(){return this.text().then(JSON.parse)},this}var J=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function tt(a){var u=a.toUpperCase();return J.indexOf(u)>-1?u:a}function q(a,u){u=u||{};var y=u.body;if(a instanceof q){if(a.bodyUsed)throw new TypeError("Already read");this.url=a.url,this.credentials=a.credentials,u.headers||(this.headers=new m(a.headers)),this.method=a.method,this.mode=a.mode,this.signal=a.signal,!y&&a._bodyInit!=null&&(y=a._bodyInit,a.bodyUsed=!0)}else this.url=String(a);if(this.credentials=u.credentials||this.credentials||"same-origin",(u.headers||!this.headers)&&(this.headers=new m(u.headers)),this.method=tt(u.method||this.method||"GET"),this.mode=u.mode||this.mode||null,this.signal=u.signal||this.signal,this.referrer=null,(this.method==="GET"||this.method==="HEAD")&&y)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(y)}q.prototype.clone=function(){return new q(this,{body:this._bodyInit})};function It(a){var u=new FormData;return a.trim().split("&").forEach(function(y){if(y){var E=y.split("="),C=E.shift().replace(/\+/g," "),I=E.join("=").replace(/\+/g," ");u.append(decodeURIComponent(C),decodeURIComponent(I))}}),u}function St(a){var u=new m,y=a.replace(/\r?\n[\t ]+/g," ");return y.split(/\r?\n/).forEach(function(E){var C=E.split(":"),I=C.shift().trim();if(I){var ht=C.join(":").trim();u.append(I,ht)}}),u}M.call(q.prototype);function B(a,u){u||(u={}),this.type="default",this.status=u.status===void 0?200:u.status,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in u?u.statusText:"OK",this.headers=new m(u.headers),this.url=u.url||"",this._initBody(a)}M.call(B.prototype),B.prototype.clone=function(){return new B(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new m(this.headers),url:this.url})},B.error=function(){var a=new B(null,{status:0,statusText:""});return a.type="error",a};var _=[301,302,303,307,308];B.redirect=function(a,u){if(_.indexOf(u)===-1)throw new RangeError("Invalid status code");return new B(null,{status:u,headers:{location:a}})},i.DOMException=s.DOMException;try{new i.DOMException}catch{i.DOMException=function(u,y){this.message=u,this.name=y;var E=Error(u);this.stack=E.stack},i.DOMException.prototype=Object.create(Error.prototype),i.DOMException.prototype.constructor=i.DOMException}function h(a,u){return new Promise(function(y,E){var C=new q(a,u);if(C.signal&&C.signal.aborted)return E(new i.DOMException("Aborted","AbortError"));var I=new XMLHttpRequest;function ht(){I.abort()}I.onload=function(){var et={status:I.status,statusText:I.statusText,headers:St(I.getAllResponseHeaders()||"")};et.url="responseURL"in I?I.responseURL:et.headers.get("X-Request-URL");var Lt="response"in I?I.response:I.responseText;y(new B(Lt,et))},I.onerror=function(){E(new TypeError("Network request failed"))},I.ontimeout=function(){E(new TypeError("Network request failed"))},I.onabort=function(){E(new i.DOMException("Aborted","AbortError"))},I.open(C.method,C.url,!0),C.credentials==="include"?I.withCredentials=!0:C.credentials==="omit"&&(I.withCredentials=!1),"responseType"in I&&c.blob&&(I.responseType="blob"),C.headers.forEach(function(et,Lt){I.setRequestHeader(Lt,et)}),C.signal&&(C.signal.addEventListener("abort",ht),I.onreadystatechange=function(){I.readyState===4&&C.signal.removeEventListener("abort",ht)}),I.send(typeof C._bodyInit>"u"?null:C._bodyInit)})}return h.polyfill=!0,s.fetch||(s.fetch=h,s.Headers=m,s.Request=q,s.Response=B),i.Headers=m,i.Request=q,i.Response=B,i.fetch=h,Object.defineProperty(i,"__esModule",{value:!0}),i})({})})(n),n.fetch.ponyfill=!0,delete n.fetch.polyfill;var o=n;t=o.fetch,t.default=o.fetch,t.fetch=o.fetch,t.Headers=o.Headers,t.Request=o.Request,t.Response=o.Response,r.exports=t})(ae,ae.exports);A.rustEnum([A.struct([],"uninitialized"),A.struct([A.option(A.publicKey(),"authorityAddress")],"buffer"),A.struct([A.publicKey("programdataAddress")],"program"),A.struct([A.u64("slot"),A.option(A.publicKey(),"upgradeAuthorityAddress")],"programData")],void 0,A.u32());function On(r){return"accounts"in r}async function Bn(r){const t=(await k.findProgramAddress([],r))[0];return await k.createWithSeed(t,Nn(),r)}function Nn(){return"anchor:idl"}const xn=A.struct([A.publicKey("authority"),A.vecU8("data")]);function Mn(r){return xn.decode(r)}function Et(r,t){var e,n;let o={};const s=r.args?r.args.length:0;if(t.length>s){if(t.length!==s+1)throw new Error(`provided too many arguments ${t} to instruction ${r==null?void 0:r.name} expecting: ${(n=(e=r.args)===null||e===void 0?void 0:e.map(i=>i.name))!==null&&n!==void 0?n:[]}`);o=t.pop()}return[t,o]}class _t{static build(t,e,n){if(t.name==="_inner")throw new wt("the _inner name is reserved");const o=(...s)=>{const[i,c]=Et(t,[...s]);he(t.accounts,c.accounts),Dn(t,...s);const l=o.accounts(c.accounts);return c.remainingAccounts!==void 0&&l.push(...c.remainingAccounts),ge("debug-logs")&&console.log("Outgoing account metas:",l),new Re({keys:l,programId:n,data:e(t.name,Ke(t,...i))})};return o.accounts=s=>_t.accountsArray(s,t.accounts,n,t.name),o}static accountsArray(t,e,n,o){return t?e.map(s=>{if(("accounts"in s?s.accounts:void 0)!==void 0){const c=t[s.name];return _t.accountsArray(c,s.accounts,n,o).flat()}else{const c=s;let l;try{l=N(t[s.name])}catch{throw new Error(`Wrong input type for account "${s.name}" in the instruction accounts object${o!==void 0?' for instruction "'+o+'"':""}. Expected PublicKey or string.`)}const d=c.isOptional&&l.equals(n),f=c.isMut&&!d,v=c.isSigner&&!d;return{pubkey:l,isWritable:f,isSigner:v}}}).flat():[]}}function Dn(r,...t){}class Un{static build(t,e){return(...o)=>{var s,i,c;const[,l]=Et(t,[...o]),d=new Oe;if(l.preInstructions&&l.instructions)throw new Error("instructions is deprecated, use preInstructions");return(s=l.preInstructions)===null||s===void 0||s.forEach(f=>d.add(f)),(i=l.instructions)===null||i===void 0||i.forEach(f=>d.add(f)),d.add(e(...o)),(c=l.postInstructions)===null||c===void 0||c.forEach(f=>d.add(f)),d}}}class $n{static build(t,e,n,o){return async(...i)=>{var c;const l=e(...i),[,d]=Et(t,[...i]);if(o.sendAndConfirm===void 0)throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");try{return await o.sendAndConfirm(l,(c=d.signers)!==null&&c!==void 0?c:[],d.options)}catch(f){throw we(f,n)}}}}class qn{static build(t,e,n,o){var s;const i={};return(s=t.accounts)===null||s===void 0||s.forEach(c=>{const l=S(c.name);i[l]=new Vn(t,c,n,o,e)}),i}}class Vn{get size(){return this._size}get programId(){return this._programId}get provider(){return this._provider}get coder(){return this._coder}get idlAccount(){return this._idlAccount}constructor(t,e,n,o,s){this._idlAccount=e,this._programId=n,this._provider=o??Nt(),this._coder=s??new Ie(t),this._size=this._coder.accounts.size(e)}async fetchNullable(t,e){const{data:n}=await this.fetchNullableAndContext(t,e);return n}async fetchNullableAndContext(t,e){const n=await this.getAccountInfoAndContext(t,e),{value:o,context:s}=n;return{data:o&&o.data.length!==0?this._coder.accounts.decode(this._idlAccount.name,o.data):null,context:s}}async fetch(t,e){const{data:n}=await this.fetchNullableAndContext(t,e);if(n===null)throw new Error(`Account does not exist or has no data ${t.toString()}`);return n}async fetchAndContext(t,e){const{data:n,context:o}=await this.fetchNullableAndContext(t,e);if(n===null)throw new Error(`Account does not exist ${t.toString()}`);return{data:n,context:o}}async fetchMultiple(t,e){return(await this.fetchMultipleAndContext(t,e)).map(o=>o?o.data:null)}async fetchMultipleAndContext(t,e){return(await en(this._provider.connection,t.map(o=>N(o)),e)).map(o=>{if(o==null)return null;const{account:s,context:i}=o;return{data:this._coder.accounts.decode(this._idlAccount.name,s.data),context:i}})}async all(t){const e=this.coder.accounts.memcmp(this._idlAccount.name,t instanceof Buffer?t:void 0),n=[];return(e==null?void 0:e.offset)!=null&&(e==null?void 0:e.bytes)!=null&&n.push({memcmp:{offset:e.offset,bytes:e.bytes}}),(e==null?void 0:e.dataSize)!=null&&n.push({dataSize:e.dataSize}),(await this._provider.connection.getProgramAccounts(this._programId,{commitment:this._provider.connection.commitment,filters:[...n,...Array.isArray(t)?t:[]]})).map(({pubkey:s,account:i})=>({publicKey:s,account:this._coder.accounts.decode(this._idlAccount.name,i.data)}))}subscribe(t,e){const n=rt.get(t.toString());if(n)return n.ee;const o=new Be;t=N(t);const s=this._provider.connection.onAccountChange(t,i=>{const c=this._coder.accounts.decode(this._idlAccount.name,i.data);o.emit("change",c)},e);return rt.set(t.toString(),{ee:o,listener:s}),o}async unsubscribe(t){let e=rt.get(t.toString());if(!e){console.warn("Address is not subscribed");return}rt&&await this._provider.connection.removeAccountChangeListener(e.listener).then(()=>{rt.delete(t.toString())}).catch(console.error)}async createInstruction(t,e){const n=this.size;if(this._provider.publicKey===void 0)throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");return le.createAccount({fromPubkey:this._provider.publicKey,newAccountPubkey:t.publicKey,space:e??n,lamports:await this._provider.connection.getMinimumBalanceForRentExemption(e??n),programId:this._programId})}async associated(...t){const e=await this.associatedAddress(...t);return await this.fetch(e)}async associatedAddress(...t){return await kn(this._programId,...t)}async getAccountInfo(t,e){return await this._provider.connection.getAccountInfo(N(t),e)}async getAccountInfoAndContext(t,e){return await this._provider.connection.getAccountInfoAndContext(N(t),e)}}const rt=new Map,Ut="Program log: ",Se="Program data: ",jn=Ut.length,zn=Se.length;class Fn{constructor(t,e,n){this._programId=t,this._provider=e,this._eventParser=new Le(t,n),this._eventCallbacks=new Map,this._eventListeners=new Map,this._listenerIdCount=0}addEventListener(t,e){var n;let o=this._listenerIdCount;return this._listenerIdCount+=1,this._eventListeners.has(t)||this._eventListeners.set(t,[]),this._eventListeners.set(t,((n=this._eventListeners.get(t))!==null&&n!==void 0?n:[]).concat(o)),this._eventCallbacks.set(o,[t,e]),this._onLogsSubscriptionId!==void 0||(this._onLogsSubscriptionId=this._provider.connection.onLogs(this._programId,(s,i)=>{if(!s.err)for(const c of this._eventParser.parseLogs(s.logs)){const l=this._eventListeners.get(c.name);l&&l.forEach(d=>{const f=this._eventCallbacks.get(d);if(f){const[,v]=f;v(c.data,i.slot,s.signature)}})}})),o}async removeEventListener(t){const e=this._eventCallbacks.get(t);if(!e)throw new Error(`Event listener ${t} doesn't exist!`);const[n]=e;let o=this._eventListeners.get(n);if(!o)throw new Error(`Event listeners don't exist for ${n}!`);if(this._eventCallbacks.delete(t),o=o.filter(s=>s!==t),this._eventListeners.set(n,o),o.length===0&&this._eventListeners.delete(n),this._eventCallbacks.size===0){if(this._eventListeners.size!==0)throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);this._onLogsSubscriptionId!==void 0&&(await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId),this._onLogsSubscriptionId=void 0)}}}class Le{constructor(t,e){this.coder=e,this.programId=t}*parseLogs(t,e=!1){const n=new Wn(t),o=new Kn;let s=n.next();for(;s!==null;){let[i,c,l]=this.handleLog(o,s,e);i&&(yield i),c&&o.push(c),l&&o.pop(),s=n.next()}}handleLog(t,e,n){return t.stack.length>0&&t.program()===this.programId.toString()?this.handleProgramLog(e,n):[null,...this.handleSystemLog(e)]}handleProgramLog(t,e){if(t.startsWith(Ut)||t.startsWith(Se)){const n=t.startsWith(Ut)?t.slice(jn):t.slice(zn),o=this.coder.events.decode(n);if(e&&o===null)throw new Error(`Unable to decode event ${n}`);return[o,null,!1]}else return[null,...this.handleSystemLog(t)]}handleSystemLog(t){const e=t.split(":")[0];return e.match(/^Program (.*) success/g)!==null?[null,!0]:e.startsWith(`Program ${this.programId.toString()} invoke`)?[this.programId.toString(),!1]:e.includes("invoke")?["cpi",!1]:[null,!1]}}class Kn{constructor(){this.stack=[]}program(){if(!this.stack.length)throw new Error("Expected the stack to have elements");return this.stack[this.stack.length-1]}push(t){this.stack.push(t)}pop(){if(!this.stack.length)throw new Error("Expected the stack to have elements");this.stack.pop()}}class Wn{constructor(t){this.logs=t}next(){if(this.logs.length===0)return null;let t=this.logs[0];return this.logs=this.logs.slice(1),t}}class Gn{static build(t,e,n,o,s,i,c){return async(...d)=>{var f;const v=e(...d),[,g]=Et(t,[...d]);let p;if(o.simulate===void 0)throw new Error("This function requires 'Provider.simulate' to be implemented.");try{p=await o.simulate(v,g.signers,(f=g.options)===null||f===void 0?void 0:f.commitment)}catch(L){throw we(L,n)}if(p===void 0)throw new Error("Unable to simulate transaction");const m=p.logs;if(!m)throw new Error("Simulated logs not found");const b=[];if(c.events){let L=new Le(i,s);for(const T of L.parseLogs(m))b.push(T)}return{events:b,raw:m}}}}function kt(r){return new Ce(ut(8),t=>Ft.fromBuffer(t),t=>t.toBuffer(),r)}function mt(r){return new Ce(ut(32),t=>new k(t),t=>t.toBuffer(),r)}function Tt(r,t){return new Hn(r,t)}class Ce extends At{constructor(t,e,n,o){super(t.span,o),this.layout=t,this.decoder=e,this.encoder=n}decode(t,e){return this.decoder(this.layout.decode(t,e))}encode(t,e,n){return this.layout.encode(this.encoder(t),e,n)}getSpan(t,e){return this.layout.getSpan(t,e)}}class Hn extends At{constructor(t,e){super(-1,e),this.layout=t,this.discriminator=V()}encode(t,e,n=0){return t==null?this.layout.span+this.discriminator.encode(0,e,n):(this.discriminator.encode(1,e,n),this.layout.encode(t,e,n+4)+4)}decode(t,e=0){const n=this.discriminator.decode(t,e);if(n===0)return null;if(n===1)return this.layout.decode(t,e+4);throw new Error("Invalid coption "+this.layout.property)}getSpan(t,e=0){return this.layout.getSpan(t,e+4)+4}}class Ft extends ue{toBuffer(){const t=super.toArray().reverse(),e=Buffer.from(t);if(e.length===8)return e;if(e.length>=8)throw new Error("u64 too large");const n=Buffer.alloc(8);return e.copy(n),n}static fromBuffer(t){if(t.length!==8)throw new Error(`Invalid buffer length: ${t.length}`);return new Ft([...t].reverse().map(e=>`00${e.toString(16)}`.slice(-2)).join(""),16)}}const Zn=P([mt("mint"),mt("owner"),kt("amount"),Tt(mt(),"delegate"),(r=>{const t=de($e("discriminator"),null,r);return t.addVariant(0,P([]),"uninitialized"),t.addVariant(1,P([]),"initialized"),t.addVariant(2,P([]),"frozen"),t})("state"),Tt(kt(),"isNative"),kt("delegatedAmount"),Tt(mt(),"closeAuthority")]);function Jn(r){return Zn.decode(r)}class at{constructor(t,e,n,o,s,i,c,l){this._accounts=e,this._provider=n,this._programId=o,this._idlIx=s,this._idlTypes=c,this._customResolver=l,this._args=t,this._accountStore=new Xn(n,i,this._programId)}args(t){this._args=t}async resolve(){for(await this.resolveConst(this._idlIx.accounts),this._resolveEventCpi(this._idlIx.accounts);await this.resolvePdas(this._idlIx.accounts)+await this.resolveRelations(this._idlIx.accounts)+await this.resolveCustom()>0;);}async resolveCustom(){if(this._customResolver){const{accounts:t,resolved:e}=await this._customResolver({args:this._args,accounts:this._accounts,provider:this._provider,programId:this._programId,idlIx:this._idlIx});return this._accounts=t,e}return 0}resolveOptionalsHelper(t,e){const n={};for(const o of e){const s=o.name,i=t[s];i!==void 0&&(Pe(i)?On(o)?n[s]=this.resolveOptionalsHelper(i,o.accounts):n[s]=ke(i,!0):i!==null?n[s]=N(i):o.isOptional&&(n[s]=this._programId))}return n}resolveOptionals(t){Object.assign(this._accounts,this.resolveOptionalsHelper(t,this._idlIx.accounts))}get(t){const e=t.reduce((n,o)=>n&&n[o],this._accounts);if(e&&e.toBase58)return e}set(t,e){let n=this._accounts;t.forEach((o,s)=>{s==t.length-1&&(n[o]=e),n[o]=n[o]||{},n=n[o]})}async resolveConst(t,e=[]){for(let n=0;n<t.length;n+=1){const o=t[n],s=o.accounts;s&&await this.resolveConst(s,[...e,S(o.name)]);const i=o,c=S(o.name);if(i.isSigner&&!this.get([...e,c])){if(this._provider.wallet===void 0)throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");this.set([...e,c],this._provider.wallet.publicKey)}Reflect.has(at.CONST_ACCOUNTS,c)&&!this.get([...e,c])&&this.set([...e,c],at.CONST_ACCOUNTS[c])}}_resolveEventCpi(t,e=[]){for(const n in t){const o=t[n],s=o.accounts;s&&this._resolveEventCpi(s,[...e,S(o.name)]);const i=+n+1;if(i===t.length)return;const c=S(t[n].name),l=S(t[i].name);if(c==="eventAuthority"&&l==="program"){const d=[...e,c],f=[...e,l];this.get(d)||this.set(d,k.findProgramAddressSync([Buffer.from("__event_authority")],this._programId)[0]),this.get(f)||this.set(f,this._programId);return}}}async resolvePdas(t,e=[]){let n=0;for(let o=0;o<t.length;o+=1){const s=t[o],i=s.accounts;i&&(n+=await this.resolvePdas(i,[...e,S(s.name)]));const c=s,l=S(s.name);c.pda&&c.pda.seeds.length>0&&!this.get([...e,l])&&Boolean(await this.autoPopulatePda(c,e))&&(n+=1)}return n}async resolveRelations(t,e=[]){let n=0;for(let o=0;o<t.length;o+=1){const s=t[o],i=s.accounts;i&&(n+=await this.resolveRelations(i,[...e,S(s.name)]));const c=s.relations||[],l=S(s.name),d=[...e,l],f=this.get(d);if(f){const v=c.filter(g=>!this.get([...e,S(g)]));if(n+=v.length,v.length>0){const g=await this._accountStore.fetchAccount({publicKey:f});await Promise.all(v.map(async p=>{const m=S(p);return this.set([...e,m],g[m]),g[m]}))}}}return n}async autoPopulatePda(t,e=[]){if(!t.pda||!t.pda.seeds)throw new Error("Must have seeds");const n=await Promise.all(t.pda.seeds.map(i=>this.toBuffer(i,e)));if(n.some(i=>typeof i>"u"))return;const o=await this.parseProgramId(t,e);if(!o)return;const[s]=await k.findProgramAddress(n,o);this.set([...e,S(t.name)],s)}async parseProgramId(t,e=[]){var n;if(!(!((n=t.pda)===null||n===void 0)&&n.programId))return this._programId;switch(t.pda.programId.kind){case"const":return new k(this.toBufferConst(t.pda.programId.value));case"arg":return this.argValue(t.pda.programId);case"account":return await this.accountValue(t.pda.programId,e);default:throw new Error(`Unexpected program seed kind: ${t.pda.programId.kind}`)}}async toBuffer(t,e=[]){switch(t.kind){case"const":return this.toBufferConst(t);case"arg":return await this.toBufferArg(t);case"account":return await this.toBufferAccount(t,e);default:throw new Error(`Unexpected seed kind: ${t.kind}`)}}getType(t,e=[]){if(e.length>0&&t.defined){const n=this._idlTypes.find(i=>i.name===t.defined);if(!n)throw new Error(`Cannot find type ${t.defined}`);const s=n.type.fields.find(i=>i.name===e[0]);return this.getType(s.type,e.slice(1))}return t}toBufferConst(t){return this.toBufferValue(this.getType(t.type,(t.path||"").split(".").slice(1)),t.value)}async toBufferArg(t){const e=this.argValue(t);if(!(typeof e>"u"))return this.toBufferValue(this.getType(t.type,(t.path||"").split(".").slice(1)),e)}argValue(t){const e=t.path.split("."),n=S(e[0]),o=this._idlIx.args.findIndex(s=>s.name===n);if(o===-1)throw new Error(`Unable to find argument for seed: ${n}`);return e.slice(1).reduce((s,i)=>(s||{})[i],this._args[o])}async toBufferAccount(t,e=[]){const n=await this.accountValue(t,e);if(!!n)return this.toBufferValue(t.type,n)}async accountValue(t,e=[]){const n=t.path.split("."),o=n[0],s=this.get([...e,S(o)]);if(s===null)throw new Error("fieldPubkey is null");if(n.length===1)return s;const i=await this._accountStore.fetchAccount({publicKey:s,name:t.account});return this.parseAccountValue(i,n.slice(1))}parseAccountValue(t,e){let n;for(;e.length>0;)n=t[S(e[0])],e=e.slice(1);return n}toBufferValue(t,e){switch(t){case"u8":return Buffer.from([e]);case"u16":let n=Buffer.alloc(2);return n.writeUInt16LE(e),n;case"u32":let o=Buffer.alloc(4);return o.writeUInt32LE(e),o;case"u64":let s=Buffer.alloc(8);return s.writeBigUInt64LE(BigInt(e)),s;case"string":return Buffer.from(ze(e));case"publicKey":return e.toBuffer();default:if(t.array)return Buffer.from(e);throw new Error(`Unexpected seed type: ${t}`)}}}at.CONST_ACCOUNTS={associatedTokenProgram:Rn,rent:Ne,systemProgram:le.programId,tokenProgram:Tn,clock:xe};class Xn{constructor(t,e,n){this._provider=t,this._programId=n,this._cache=new Map,this._idls={},this._idls[n.toBase58()]=e}async ensureIdl(t){if(!this._idls[t.toBase58()]){const e=await ct.fetchIdl(t,this._provider);if(e){const n=new ct(e,t,this._provider);this._idls[t.toBase58()]=n.account}}return this._idls[t.toBase58()]}async fetchAccount({publicKey:t,name:e,programId:n=this._programId}){const o=t.toString();if(!this._cache.has(o))if(e==="TokenAccount"){const s=await this._provider.connection.getAccountInfo(t);if(s===null)throw new Error(`invalid account info for ${o}`);const i=Jn(s.data);this._cache.set(o,i)}else if(e){const s=await this.ensureIdl(n);if(s){const i=s[S(e)];if(i){const c=await i.fetch(t);this._cache.set(o,c)}}}else{const s=await this._provider.connection.getAccountInfo(t);if(s===null)throw new Error(`invalid account info for ${o}`);const i=s.data,c=await this.ensureIdl(s.owner);if(c){const l=Object.values(c)[0];if(!l)throw new Error("No accounts for this program");const d=l.coder.accounts.decodeAny(i);this._cache.set(o,d)}}return this._cache.get(o)}}class Yn{static build(t,e,n,o,s,i,c,l,d,f,v){return(...g)=>new Qn(g,o,s,i,c,l,t,e,n,d,f,v)}}function Pe(r){return typeof r=="object"&&r!==null&&!("_bn"in r)}function ke(r,t){const e={};for(const n in r){const o=r[n];if(o===null){if(t)throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");continue}e[n]=Pe(o)?ke(o,!0):N(o)}return e}class Qn{constructor(t,e,n,o,s,i,c,l,d,f,v,g){this._ixFn=e,this._txFn=n,this._rpcFn=o,this._simulateFn=s,this._viewFn=i,this._programId=l,this._accounts={},this._remainingAccounts=[],this._signers=[],this._preInstructions=[],this._postInstructions=[],this._autoResolveAccounts=!0,this._args=t,this._accountsResolver=new at(t,this._accounts,c,l,d,f,v,g)}args(t){this._args=t,this._accountsResolver.args(t)}async pubkeys(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._accounts}accounts(t){return this._autoResolveAccounts=!0,this._accountsResolver.resolveOptionals(t),this}accountsStrict(t){return this._autoResolveAccounts=!1,this._accountsResolver.resolveOptionals(t),this}signers(t){return this._signers=this._signers.concat(t),this}remainingAccounts(t){return this._remainingAccounts=this._remainingAccounts.concat(t),this}preInstructions(t){return this._preInstructions=this._preInstructions.concat(t),this}postInstructions(t){return this._postInstructions=this._postInstructions.concat(t),this}async rpc(t){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._rpcFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async rpcAndKeys(t){return{pubkeys:await this.pubkeys(),signature:await this.rpc(t)}}async view(t){if(this._autoResolveAccounts&&await this._accountsResolver.resolve(),!this._viewFn)throw new Error("Method does not support views");return this._viewFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async simulate(t){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._simulateFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async instruction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._ixFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}async prepare(){return{instruction:await this.instruction(),pubkeys:await this.pubkeys(),signers:await this._signers}}async transaction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._txFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}}class tr{static build(t,e,n,o){const s=e.accounts.find(l=>l.isMut),i=!!e.returns;return s||!i?void 0:async(...l)=>{var d,f;let v=await n(...l);const g=`Program return: ${t} `;let p=v.raw.find(T=>T.startsWith(g));if(!p)throw new Error("View expected return log");let m=fe(p.slice(g.length)),b=e.returns;if(!b)throw new Error("View expected return type");return R.fieldLayout({type:b},Array.from([...(d=o.accounts)!==null&&d!==void 0?d:[],...(f=o.types)!==null&&f!==void 0?f:[]])).decode(m)}}}class er{static build(t,e,n,o,s){const i={},c={},l={},d={},f={},v={},g=Fe(t),p=t.accounts?qn.build(t,e,n,o):{};return t.instructions.forEach(m=>{const b=_t.build(m,(J,tt)=>e.instruction.encode(J,tt),n),L=Un.build(m,b),T=$n.build(m,L,g,o),$=Gn.build(m,L,g,o,e,n,t),W=tr.build(n,m,$,t),Z=Yn.build(o,n,m,b,L,T,$,W,p,t.types||[],s&&s(m)),M=S(m.name);c[M]=b,l[M]=L,i[M]=T,d[M]=$,f[M]=Z,W&&(v[M]=W)}),[i,c,l,p,d,f,v]}}class ct{get programId(){return this._programId}get idl(){return this._idl}get coder(){return this._coder}get provider(){return this._provider}constructor(t,e,n,o,s){e=N(e),n||(n=Nt()),this._idl=t,this._provider=n,this._programId=e,this._coder=o??new Ie(t),this._events=new Fn(this._programId,n,this._coder);const[i,c,l,d,f,v,g]=er.build(t,this._coder,e,n,s??(()=>{}));this.rpc=i,this.instruction=c,this.transaction=l,this.account=d,this.simulate=f,this.methods=v,this.views=g}static async at(t,e){const n=N(t),o=await ct.fetchIdl(n,e);if(!o)throw new Error(`IDL not found for program: ${t.toString()}`);return new ct(o,n,e)}static async fetchIdl(t,e){e=e??Nt();const n=N(t),o=await Bn(n),s=await e.connection.getAccountInfo(o);if(!s)return null;let i=Mn(s.data.slice(8));const c=qe(i.data);return JSON.parse(je(c))}addEventListener(t,e){return this._events.addEventListener(t,e)}async removeEventListener(t){return await this._events.removeEventListener(t)}}new k("11111111111111111111111111111111");it||(exports.workspace=require("./workspace.js").default,exports.Wallet=require("./nodewallet.js").default);export{X as A,ct as P,ze as e};
