import{aF as Be,bZ as Ia,du as Ra,dv as va,bX as N,d7 as nr,c$ as ge,dw as Mr,d6 as x,d8 as Zt,cR as D,cS as Ie,cT as U,cU as z,cV as Fe,cW as ne,cX as Re,cY as Bt,dx as bn,dy as v,dz as Dr,dA as $r,dB as le,dC as mn,dD as R,dE as y,dF as O,dG as B,dH as $,dI as Xe,dJ as qs,dK as Le,dL as E,cZ as Ve,dM as Fr,c_ as ue,d0 as vs,dN as Ts,dO as Ta,dP as Qt,d4 as Ea,d5 as Ys,dQ as Es,dR as Pa,dS as Ba,dT as Oa,dU as Ca,bW as Na,P as js,cM as La,cp as Ka,cn,cN as Vn,dg as xa,a as Ua}from"./index.7cdf8e9f.js";import{b as za}from"./assert.f25cfba1.js";import{c as Wa}from"./index.c6289244.js";const Ma=[Be("rect",{x:"0",y:"0",width:"100",height:"100",fill:"none"}),Be("g",{transform:"translate(25 25)"},[Be("rect",{x:"-20",y:"-20",width:"40",height:"40",fill:"currentColor",opacity:"0.9"},[Be("animateTransform",{attributeName:"transform",type:"scale",from:"1.5",to:"1",repeatCount:"indefinite",begin:"0s",dur:"1s",calcMode:"spline",keySplines:"0.2 0.8 0.2 0.8",keyTimes:"0;1"})])]),Be("g",{transform:"translate(75 25)"},[Be("rect",{x:"-20",y:"-20",width:"40",height:"40",fill:"currentColor",opacity:"0.8"},[Be("animateTransform",{attributeName:"transform",type:"scale",from:"1.5",to:"1",repeatCount:"indefinite",begin:"0.1s",dur:"1s",calcMode:"spline",keySplines:"0.2 0.8 0.2 0.8",keyTimes:"0;1"})])]),Be("g",{transform:"translate(25 75)"},[Be("rect",{x:"-20",y:"-20",width:"40",height:"40",fill:"currentColor",opacity:"0.7"},[Be("animateTransform",{attributeName:"transform",type:"scale",from:"1.5",to:"1",repeatCount:"indefinite",begin:"0.3s",dur:"1s",calcMode:"spline",keySplines:"0.2 0.8 0.2 0.8",keyTimes:"0;1"})])]),Be("g",{transform:"translate(75 75)"},[Be("rect",{x:"-20",y:"-20",width:"40",height:"40",fill:"currentColor",opacity:"0.6"},[Be("animateTransform",{attributeName:"transform",type:"scale",from:"1.5",to:"1",repeatCount:"indefinite",begin:"0.2s",dur:"1s",calcMode:"spline",keySplines:"0.2 0.8 0.2 0.8",keyTimes:"0;1"})])])];var Vd=Ia({name:"QSpinnerCube",props:Ra,setup(i){const{cSize:e,classes:t}=va(i);return()=>Be("svg",{class:t.value,width:e.value,height:e.value,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 100 100",preserveAspectRatio:"xMidYMid"},Ma)}}),Js={},Xs={},Ps=1/0,Zs=9007199254740991,Da=17976931348623157e292,Bs=0/0,$a="[object Function]",Fa="[object GeneratorFunction]",Ha="[object Symbol]",Va=/^\s+|\s+$/g,Ga=/^[-+]0x[0-9a-f]+$/i,qa=/^0b[01]+$/i,Ya=/^0o[0-7]+$/i,ja=/^(?:0|[1-9]\d*)$/,Ja=parseInt,Xa=Object.prototype,Qs=Xa.toString,Za=Math.ceil,Qa=Math.max;function ec(i,e,t){var n=-1,r=i.length;e<0&&(e=-e>r?0:r+e),t=t>r?r:t,t<0&&(t+=r),r=e>t?0:t-e>>>0,e>>>=0;for(var s=Array(r);++n<r;)s[n]=i[n+e];return s}function tc(i,e){return e=e??Zs,!!e&&(typeof i=="number"||ja.test(i))&&i>-1&&i%1==0&&i<e}function nc(i,e,t){if(!jn(t))return!1;var n=typeof e;return(n=="number"?ic(t)&&tc(e,t.length):n=="string"&&e in t)?sc(t[e],i):!1}function rc(i,e,t){(t?nc(i,e,t):e===void 0)?e=1:e=Qa(dc(e),0);var n=i?i.length:0;if(!n||e<1)return[];for(var r=0,s=0,o=Array(Za(n/e));r<n;)o[s++]=ec(i,r,r+=e);return o}function sc(i,e){return i===e||i!==i&&e!==e}function ic(i){return i!=null&&ac(i.length)&&!oc(i)}function oc(i){var e=jn(i)?Qs.call(i):"";return e==$a||e==Fa}function ac(i){return typeof i=="number"&&i>-1&&i%1==0&&i<=Zs}function jn(i){var e=typeof i;return!!i&&(e=="object"||e=="function")}function cc(i){return!!i&&typeof i=="object"}function uc(i){return typeof i=="symbol"||cc(i)&&Qs.call(i)==Ha}function lc(i){if(!i)return i===0?i:0;if(i=fc(i),i===Ps||i===-Ps){var e=i<0?-1:1;return e*Da}return i===i?i:0}function dc(i){var e=lc(i),t=e%1;return e===e?t?e-t:e:0}function fc(i){if(typeof i=="number")return i;if(uc(i))return Bs;if(jn(i)){var e=typeof i.valueOf=="function"?i.valueOf():i;i=jn(e)?e+"":e}if(typeof i!="string")return i===0?i:+i;i=i.replace(Va,"");var t=qa.test(i);return t||Ya.test(i)?Ja(i.slice(2),t?2:8):Ga.test(i)?Bs:+i}var hc=rc,Or={exports:{}};(function(i,e){var t=200,n="Expected a function",r="__lodash_hash_undefined__",s=1,o=2,c=1/0,u=9007199254740991,d="[object Arguments]",g="[object Array]",m="[object Boolean]",_="[object Date]",f="[object Error]",b="[object Function]",w="[object GeneratorFunction]",A="[object Map]",h="[object Number]",k="[object Object]",S="[object Promise]",C="[object RegExp]",K="[object Set]",L="[object String]",q="[object Symbol]",j="[object WeakMap]",ee="[object ArrayBuffer]",H="[object DataView]",Ae="[object Float32Array]",kt="[object Float64Array]",Sn="[object Int8Array]",An="[object Int16Array]",xt="[object Int32Array]",In="[object Uint8Array]",Rn="[object Uint8ClampedArray]",vn="[object Uint16Array]",Tn="[object Uint32Array]",qe=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,En=/^\w*$/,nn=/^\./,Pn=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,_t=/[\\^$.*+?()[\]{}|]/g,fe=/\\(\\)?/g,me=/^\[object .+?Constructor\]$/,st=/^(?:0|[1-9]\d*)$/,X={};X[Ae]=X[kt]=X[Sn]=X[An]=X[xt]=X[In]=X[Rn]=X[vn]=X[Tn]=!0,X[d]=X[g]=X[ee]=X[m]=X[H]=X[_]=X[f]=X[b]=X[A]=X[h]=X[k]=X[C]=X[K]=X[L]=X[j]=!1;var Ye=typeof N=="object"&&N&&N.Object===Object&&N,St=typeof self=="object"&&self&&self.Object===Object&&self,Me=Ye||St||Function("return this")(),Ut=e&&!e.nodeType&&e,zt=Ut&&!0&&i&&!i.nodeType&&i,rn=zt&&zt.exports===Ut,Wt=rn&&Ye.process,Bn=function(){try{return Wt&&Wt.binding("util")}catch{}}(),On=Bn&&Bn.isTypedArray;function cs(a,l){for(var p=-1,I=a?a.length:0,M=Array(I);++p<I;)M[p]=l(a[p],p,a);return M}function Qi(a,l){for(var p=-1,I=a?a.length:0;++p<I;)if(l(a[p],p,a))return!0;return!1}function eo(a){return function(l){return l==null?void 0:l[a]}}function to(a,l){var p=a.length;for(a.sort(l);p--;)a[p]=a[p].value;return a}function no(a,l){for(var p=-1,I=Array(a);++p<a;)I[p]=l(p);return I}function us(a){return function(l){return a(l)}}function ro(a,l){return a==null?void 0:a[l]}function fr(a){var l=!1;if(a!=null&&typeof a.toString!="function")try{l=!!(a+"")}catch{}return l}function so(a){var l=-1,p=Array(a.size);return a.forEach(function(I,M){p[++l]=[M,I]}),p}function io(a,l){return function(p){return a(l(p))}}function oo(a){var l=-1,p=Array(a.size);return a.forEach(function(I){p[++l]=I}),p}var ao=Array.prototype,co=Function.prototype,Cn=Object.prototype,hr=Me["__core-js_shared__"],ls=function(){var a=/[^.]+$/.exec(hr&&hr.keys&&hr.keys.IE_PROTO||"");return a?"Symbol(src)_1."+a:""}(),ds=co.toString,it=Cn.hasOwnProperty,Mt=Cn.toString,uo=RegExp("^"+ds.call(it).replace(_t,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),fs=Me.Symbol,hs=Me.Uint8Array,lo=Cn.propertyIsEnumerable,fo=ao.splice,ho=io(Object.keys,Object),gr=Dt(Me,"DataView"),sn=Dt(Me,"Map"),yr=Dt(Me,"Promise"),pr=Dt(Me,"Set"),br=Dt(Me,"WeakMap"),on=Dt(Object,"create"),go=It(gr),yo=It(sn),po=It(yr),bo=It(pr),mo=It(br),Nn=fs?fs.prototype:void 0,mr=Nn?Nn.valueOf:void 0,gs=Nn?Nn.toString:void 0;function At(a){var l=-1,p=a?a.length:0;for(this.clear();++l<p;){var I=a[l];this.set(I[0],I[1])}}function wo(){this.__data__=on?on(null):{}}function ko(a){return this.has(a)&&delete this.__data__[a]}function _o(a){var l=this.__data__;if(on){var p=l[a];return p===r?void 0:p}return it.call(l,a)?l[a]:void 0}function So(a){var l=this.__data__;return on?l[a]!==void 0:it.call(l,a)}function Ao(a,l){var p=this.__data__;return p[a]=on&&l===void 0?r:l,this}At.prototype.clear=wo,At.prototype.delete=ko,At.prototype.get=_o,At.prototype.has=So,At.prototype.set=Ao;function ot(a){var l=-1,p=a?a.length:0;for(this.clear();++l<p;){var I=a[l];this.set(I[0],I[1])}}function Io(){this.__data__=[]}function Ro(a){var l=this.__data__,p=Kn(l,a);if(p<0)return!1;var I=l.length-1;return p==I?l.pop():fo.call(l,p,1),!0}function vo(a){var l=this.__data__,p=Kn(l,a);return p<0?void 0:l[p][1]}function To(a){return Kn(this.__data__,a)>-1}function Eo(a,l){var p=this.__data__,I=Kn(p,a);return I<0?p.push([a,l]):p[I][1]=l,this}ot.prototype.clear=Io,ot.prototype.delete=Ro,ot.prototype.get=vo,ot.prototype.has=To,ot.prototype.set=Eo;function at(a){var l=-1,p=a?a.length:0;for(this.clear();++l<p;){var I=a[l];this.set(I[0],I[1])}}function Po(){this.__data__={hash:new At,map:new(sn||ot),string:new At}}function Bo(a){return xn(this,a).delete(a)}function Oo(a){return xn(this,a).get(a)}function Co(a){return xn(this,a).has(a)}function No(a,l){return xn(this,a).set(a,l),this}at.prototype.clear=Po,at.prototype.delete=Bo,at.prototype.get=Oo,at.prototype.has=Co,at.prototype.set=No;function Ln(a){var l=-1,p=a?a.length:0;for(this.__data__=new at;++l<p;)this.add(a[l])}function Lo(a){return this.__data__.set(a,r),this}function Ko(a){return this.__data__.has(a)}Ln.prototype.add=Ln.prototype.push=Lo,Ln.prototype.has=Ko;function ct(a){this.__data__=new ot(a)}function xo(){this.__data__=new ot}function Uo(a){return this.__data__.delete(a)}function zo(a){return this.__data__.get(a)}function Wo(a){return this.__data__.has(a)}function Mo(a,l){var p=this.__data__;if(p instanceof ot){var I=p.__data__;if(!sn||I.length<t-1)return I.push([a,l]),this;p=this.__data__=new at(I)}return p.set(a,l),this}ct.prototype.clear=xo,ct.prototype.delete=Uo,ct.prototype.get=zo,ct.prototype.has=Wo,ct.prototype.set=Mo;function Do(a,l){var p=ut(a)||Ss(a)?no(a.length,String):[],I=p.length,M=!!I;for(var P in a)(l||it.call(a,P))&&!(M&&(P=="length"||ms(P,I)))&&p.push(P);return p}function Kn(a,l){for(var p=a.length;p--;)if(_s(a[p][0],l))return p;return-1}var $o=aa(Ho),Fo=ca();function Ho(a,l){return a&&Fo(a,l,$n)}function ys(a,l){l=Un(l,a)?[l]:ps(l);for(var p=0,I=l.length;a!=null&&p<I;)a=a[zn(l[p++])];return p&&p==I?a:void 0}function Vo(a){return Mt.call(a)}function Go(a,l){return a!=null&&l in Object(a)}function wr(a,l,p,I,M){return a===l?!0:a==null||l==null||!Mn(a)&&!Dn(l)?a!==a&&l!==l:qo(a,l,wr,p,I,M)}function qo(a,l,p,I,M,P){var F=ut(a),Z=ut(l),J=g,ie=g;F||(J=gt(a),J=J==d?k:J),Z||(ie=gt(l),ie=ie==d?k:ie);var ve=J==k&&!fr(a),Pe=ie==k&&!fr(l),we=J==ie;if(we&&!ve)return P||(P=new ct),F||wa(a)?bs(a,l,p,I,M,P):ua(a,l,J,p,I,M,P);if(!(M&o)){var De=ve&&it.call(a,"__wrapped__"),$e=Pe&&it.call(l,"__wrapped__");if(De||$e){var yt=De?a.value():a,lt=$e?l.value():l;return P||(P=new ct),p(yt,lt,I,M,P)}}return we?(P||(P=new ct),la(a,l,p,I,M,P)):!1}function Yo(a,l,p,I){var M=p.length,P=M,F=!I;if(a==null)return!P;for(a=Object(a);M--;){var Z=p[M];if(F&&Z[2]?Z[1]!==a[Z[0]]:!(Z[0]in a))return!1}for(;++M<P;){Z=p[M];var J=Z[0],ie=a[J],ve=Z[1];if(F&&Z[2]){if(ie===void 0&&!(J in a))return!1}else{var Pe=new ct;if(I)var we=I(ie,ve,J,a,l,Pe);if(!(we===void 0?wr(ve,ie,I,s|o,Pe):we))return!1}}return!0}function jo(a){if(!Mn(a)||ga(a))return!1;var l=As(a)||fr(a)?uo:me;return l.test(It(a))}function Jo(a){return Dn(a)&&_r(a.length)&&!!X[Mt.call(a)]}function Xo(a){return typeof a=="function"?a:a==null?Is:typeof a=="object"?ut(a)?ta(a[0],a[1]):ea(a):Aa(a)}function Zo(a){if(!ya(a))return ho(a);var l=[];for(var p in Object(a))it.call(a,p)&&p!="constructor"&&l.push(p);return l}function Qo(a,l){var p=-1,I=Wn(a)?Array(a.length):[];return $o(a,function(M,P,F){I[++p]=l(M,P,F)}),I}function ea(a){var l=da(a);return l.length==1&&l[0][2]?ks(l[0][0],l[0][1]):function(p){return p===a||Yo(p,a,l)}}function ta(a,l){return Un(a)&&ws(l)?ks(zn(a),l):function(p){var I=_a(p,a);return I===void 0&&I===l?Sa(p,a):wr(l,I,void 0,s|o)}}function na(a,l,p){var I=-1;l=cs(l.length?l:[Is],us(Xo));var M=Qo(a,function(P,F,Z){var J=cs(l,function(ie){return ie(P)});return{criteria:J,index:++I,value:P}});return to(M,function(P,F){return oa(P,F,p)})}function ra(a){return function(l){return ys(l,a)}}function sa(a){if(typeof a=="string")return a;if(an(a))return gs?gs.call(a):"";var l=a+"";return l=="0"&&1/a==-c?"-0":l}function ps(a){return ut(a)?a:pa(a)}function ia(a,l){if(a!==l){var p=a!==void 0,I=a===null,M=a===a,P=an(a),F=l!==void 0,Z=l===null,J=l===l,ie=an(l);if(!Z&&!ie&&!P&&a>l||P&&F&&J&&!Z&&!ie||I&&F&&J||!p&&J||!M)return 1;if(!I&&!P&&!ie&&a<l||ie&&p&&M&&!I&&!P||Z&&p&&M||!F&&M||!J)return-1}return 0}function oa(a,l,p){for(var I=-1,M=a.criteria,P=l.criteria,F=M.length,Z=p.length;++I<F;){var J=ia(M[I],P[I]);if(J){if(I>=Z)return J;var ie=p[I];return J*(ie=="desc"?-1:1)}}return a.index-l.index}function aa(a,l){return function(p,I){if(p==null)return p;if(!Wn(p))return a(p,I);for(var M=p.length,P=l?M:-1,F=Object(p);(l?P--:++P<M)&&I(F[P],P,F)!==!1;);return p}}function ca(a){return function(l,p,I){for(var M=-1,P=Object(l),F=I(l),Z=F.length;Z--;){var J=F[a?Z:++M];if(p(P[J],J,P)===!1)break}return l}}function bs(a,l,p,I,M,P){var F=M&o,Z=a.length,J=l.length;if(Z!=J&&!(F&&J>Z))return!1;var ie=P.get(a);if(ie&&P.get(l))return ie==l;var ve=-1,Pe=!0,we=M&s?new Ln:void 0;for(P.set(a,l),P.set(l,a);++ve<Z;){var De=a[ve],$e=l[ve];if(I)var yt=F?I($e,De,ve,l,a,P):I(De,$e,ve,a,l,P);if(yt!==void 0){if(yt)continue;Pe=!1;break}if(we){if(!Qi(l,function(lt,Rt){if(!we.has(Rt)&&(De===lt||p(De,lt,I,M,P)))return we.add(Rt)})){Pe=!1;break}}else if(!(De===$e||p(De,$e,I,M,P))){Pe=!1;break}}return P.delete(a),P.delete(l),Pe}function ua(a,l,p,I,M,P,F){switch(p){case H:if(a.byteLength!=l.byteLength||a.byteOffset!=l.byteOffset)return!1;a=a.buffer,l=l.buffer;case ee:return!(a.byteLength!=l.byteLength||!I(new hs(a),new hs(l)));case m:case _:case h:return _s(+a,+l);case f:return a.name==l.name&&a.message==l.message;case C:case L:return a==l+"";case A:var Z=so;case K:var J=P&o;if(Z||(Z=oo),a.size!=l.size&&!J)return!1;var ie=F.get(a);if(ie)return ie==l;P|=s,F.set(a,l);var ve=bs(Z(a),Z(l),I,M,P,F);return F.delete(a),ve;case q:if(mr)return mr.call(a)==mr.call(l)}return!1}function la(a,l,p,I,M,P){var F=M&o,Z=$n(a),J=Z.length,ie=$n(l),ve=ie.length;if(J!=ve&&!F)return!1;for(var Pe=J;Pe--;){var we=Z[Pe];if(!(F?we in l:it.call(l,we)))return!1}var De=P.get(a);if(De&&P.get(l))return De==l;var $e=!0;P.set(a,l),P.set(l,a);for(var yt=F;++Pe<J;){we=Z[Pe];var lt=a[we],Rt=l[we];if(I)var Rs=F?I(Rt,lt,we,l,a,P):I(lt,Rt,we,a,l,P);if(!(Rs===void 0?lt===Rt||p(lt,Rt,I,M,P):Rs)){$e=!1;break}yt||(yt=we=="constructor")}if($e&&!yt){var Fn=a.constructor,Hn=l.constructor;Fn!=Hn&&"constructor"in a&&"constructor"in l&&!(typeof Fn=="function"&&Fn instanceof Fn&&typeof Hn=="function"&&Hn instanceof Hn)&&($e=!1)}return P.delete(a),P.delete(l),$e}function xn(a,l){var p=a.__data__;return ha(l)?p[typeof l=="string"?"string":"hash"]:p.map}function da(a){for(var l=$n(a),p=l.length;p--;){var I=l[p],M=a[I];l[p]=[I,M,ws(M)]}return l}function Dt(a,l){var p=ro(a,l);return jo(p)?p:void 0}var gt=Vo;(gr&&gt(new gr(new ArrayBuffer(1)))!=H||sn&&gt(new sn)!=A||yr&&gt(yr.resolve())!=S||pr&&gt(new pr)!=K||br&&gt(new br)!=j)&&(gt=function(a){var l=Mt.call(a),p=l==k?a.constructor:void 0,I=p?It(p):void 0;if(I)switch(I){case go:return H;case yo:return A;case po:return S;case bo:return K;case mo:return j}return l});function fa(a,l,p){l=Un(l,a)?[l]:ps(l);for(var I,M=-1,F=l.length;++M<F;){var P=zn(l[M]);if(!(I=a!=null&&p(a,P)))break;a=a[P]}if(I)return I;var F=a?a.length:0;return!!F&&_r(F)&&ms(P,F)&&(ut(a)||Ss(a))}function ms(a,l){return l=l??u,!!l&&(typeof a=="number"||st.test(a))&&a>-1&&a%1==0&&a<l}function Un(a,l){if(ut(a))return!1;var p=typeof a;return p=="number"||p=="symbol"||p=="boolean"||a==null||an(a)?!0:En.test(a)||!qe.test(a)||l!=null&&a in Object(l)}function ha(a){var l=typeof a;return l=="string"||l=="number"||l=="symbol"||l=="boolean"?a!=="__proto__":a===null}function ga(a){return!!ls&&ls in a}function ya(a){var l=a&&a.constructor,p=typeof l=="function"&&l.prototype||Cn;return a===p}function ws(a){return a===a&&!Mn(a)}function ks(a,l){return function(p){return p==null?!1:p[a]===l&&(l!==void 0||a in Object(p))}}var pa=kr(function(a){a=ka(a);var l=[];return nn.test(a)&&l.push(""),a.replace(Pn,function(p,I,M,P){l.push(M?P.replace(fe,"$1"):I||p)}),l});function zn(a){if(typeof a=="string"||an(a))return a;var l=a+"";return l=="0"&&1/a==-c?"-0":l}function It(a){if(a!=null){try{return ds.call(a)}catch{}try{return a+""}catch{}}return""}function ba(a,l,p,I){return a==null?[]:(ut(l)||(l=l==null?[]:[l]),p=I?void 0:p,ut(p)||(p=p==null?[]:[p]),na(a,l,p))}function kr(a,l){if(typeof a!="function"||l&&typeof l!="function")throw new TypeError(n);var p=function(){var I=arguments,M=l?l.apply(this,I):I[0],P=p.cache;if(P.has(M))return P.get(M);var F=a.apply(this,I);return p.cache=P.set(M,F),F};return p.cache=new(kr.Cache||at),p}kr.Cache=at;function _s(a,l){return a===l||a!==a&&l!==l}function Ss(a){return ma(a)&&it.call(a,"callee")&&(!lo.call(a,"callee")||Mt.call(a)==d)}var ut=Array.isArray;function Wn(a){return a!=null&&_r(a.length)&&!As(a)}function ma(a){return Dn(a)&&Wn(a)}function As(a){var l=Mn(a)?Mt.call(a):"";return l==b||l==w}function _r(a){return typeof a=="number"&&a>-1&&a%1==0&&a<=u}function Mn(a){var l=typeof a;return!!a&&(l=="object"||l=="function")}function Dn(a){return!!a&&typeof a=="object"}function an(a){return typeof a=="symbol"||Dn(a)&&Mt.call(a)==q}var wa=On?us(On):Jo;function ka(a){return a==null?"":sa(a)}function _a(a,l,p){var I=a==null?void 0:ys(a,l);return I===void 0?p:I}function Sa(a,l){return a!=null&&fa(a,l,Go)}function $n(a){return Wn(a)?Do(a):Zo(a)}function Is(a){return a}function Aa(a){return Un(a)?eo(zn(a)):ra(a)}i.exports=ba})(Or,Or.exports);var Ce={},pe={},gc=N&&N.__createBinding||(Object.create?function(i,e,t,n){n===void 0&&(n=t),Object.defineProperty(i,n,{enumerable:!0,get:function(){return e[t]}})}:function(i,e,t,n){n===void 0&&(n=t),i[n]=e[t]}),yc=N&&N.__setModuleDefault||(Object.create?function(i,e){Object.defineProperty(i,"default",{enumerable:!0,value:e})}:function(i,e){i.default=e}),Ze=N&&N.__decorate||function(i,e,t,n){var r=arguments.length,s=r<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(i,e,t,n);else for(var c=i.length-1;c>=0;c--)(o=i[c])&&(s=(r<3?o(s):r>3?o(e,t,s):o(e,t))||s);return r>3&&s&&Object.defineProperty(e,t,s),s},pc=N&&N.__importStar||function(i){if(i&&i.__esModule)return i;var e={};if(i!=null)for(var t in i)t!=="default"&&Object.hasOwnProperty.call(i,t)&&gc(e,i,t);return yc(e,i),e},ei=N&&N.__importDefault||function(i){return i&&i.__esModule?i:{default:i}};Object.defineProperty(pe,"__esModule",{value:!0});pe.deserializeUnchecked=pe.deserialize=pe.serialize=pe.BinaryReader=pe.BinaryWriter=pe.BorshError=pe.baseDecode=pe.baseEncode=void 0;const pt=ei(nr.exports),ti=ei(ge),bc=pc(Mr),mc=typeof N.TextDecoder!="function"?bc.TextDecoder:N.TextDecoder,wc=new mc("utf-8",{fatal:!0});function kc(i){return typeof i=="string"&&(i=x.Buffer.from(i,"utf8")),ti.default.encode(x.Buffer.from(i))}pe.baseEncode=kc;function _c(i){return x.Buffer.from(ti.default.decode(i))}pe.baseDecode=_c;const Sr=1024;class Te extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}pe.BorshError=Te;class ni{constructor(){this.buf=x.Buffer.alloc(Sr),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=x.Buffer.concat([this.buf,x.Buffer.alloc(Sr)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new pt.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new pt.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new pt.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new pt.default(e).toArray("le",64)))}writeBuffer(e){this.buf=x.Buffer.concat([x.Buffer.from(this.buf.subarray(0,this.length)),e,x.Buffer.alloc(Sr)]),this.length+=e.length}writeString(e){this.maybeResize();const t=x.Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(x.Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}}pe.BinaryWriter=ni;function Qe(i,e,t){const n=t.value;t.value=function(...r){try{return n.apply(this,r)}catch(s){if(s instanceof RangeError){const o=s.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(o)>=0)throw new Te("Reached the end of buffer when deserializing")}throw s}}}class Ue{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new pt.default(e,"le")}readU128(){const e=this.readBuffer(16);return new pt.default(e,"le")}readU256(){const e=this.readBuffer(32);return new pt.default(e,"le")}readU512(){const e=this.readBuffer(64);return new pt.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new Te(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return wc.decode(t)}catch(n){throw new Te(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let r=0;r<t;++r)n.push(e());return n}}Ze([Qe],Ue.prototype,"readU8",null);Ze([Qe],Ue.prototype,"readU16",null);Ze([Qe],Ue.prototype,"readU32",null);Ze([Qe],Ue.prototype,"readU64",null);Ze([Qe],Ue.prototype,"readU128",null);Ze([Qe],Ue.prototype,"readU256",null);Ze([Qe],Ue.prototype,"readU512",null);Ze([Qe],Ue.prototype,"readString",null);Ze([Qe],Ue.prototype,"readFixedArray",null);Ze([Qe],Ue.prototype,"readArray",null);pe.BinaryReader=Ue;function ri(i){return i.charAt(0).toUpperCase()+i.slice(1)}function dn(i,e,t,n,r){try{if(typeof n=="string")r[`write${ri(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new Te(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);r.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new Te(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let s=0;s<n[1];s++)dn(i,null,t[s],n[0],r)}else r.writeArray(t,s=>{dn(i,e,s,n[0],r)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?r.writeU8(0):(r.writeU8(1),dn(i,e,t,n.type,r));break}default:throw new Te(`FieldType ${n} unrecognized`)}else si(i,t,r)}catch(s){throw s instanceof Te&&s.addToFieldPath(e),s}}function si(i,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const n=i.get(e.constructor);if(!n)throw new Te(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([r,s])=>{dn(i,r,e[r],s,t)});else if(n.kind==="enum"){const r=e[n.field];for(let s=0;s<n.values.length;++s){const[o,c]=n.values[s];if(o===r){t.writeU8(s),dn(i,o,e[o],c,t);break}}}else throw new Te(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Sc(i,e,t=ni){const n=new t;return si(i,e,n),n.toArray()}pe.serialize=Sc;function fn(i,e,t,n){try{if(typeof t=="string")return n[`read${ri(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){const r=[];for(let s=0;s<t[1];s++)r.push(fn(i,null,t[0],n));return r}else return n.readArray(()=>fn(i,e,t[0],n))}return t.kind==="option"?n.readU8()?fn(i,e,t.type,n):void 0:Hr(i,t,n)}catch(r){throw r instanceof Te&&r.addToFieldPath(e),r}}function Hr(i,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const n=i.get(e);if(!n)throw new Te(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const r={};for(const[s,o]of i.get(e).fields)r[s]=fn(i,s,o,t);return new e(r)}if(n.kind==="enum"){const r=t.readU8();if(r>=n.values.length)throw new Te(`Enum index: ${r} is out of range`);const[s,o]=n.values[r],c=fn(i,s,o,t);return new e({[s]:c})}throw new Te(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Ac(i,e,t,n=Ue){const r=new n(t),s=Hr(i,e,r);if(r.offset<t.length)throw new Te(`Unexpected ${t.length-r.offset} bytes after deserialized data`);return s}pe.deserialize=Ac;function Ic(i,e,t,n=Ue){const r=new n(t);return Hr(i,e,r)}pe.deserializeUnchecked=Ic;var Vr={};(function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.Metadata=i.METADATA_PROGRAM=i.METADATA_PREFIX=i.METADATA_SCHEMA=i.Data=i.Creator=i.MetadataKey=void 0;var e="metadata";i.METADATA_PREFIX=e;var t="metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";i.METADATA_PROGRAM=t;var n;(function(u){u[u.Uninitialized=0]="Uninitialized",u[u.MetadataV1=4]="MetadataV1",u[u.EditionV1=1]="EditionV1",u[u.MasterEditionV1=2]="MasterEditionV1",u[u.MasterEditionV2=6]="MasterEditionV2",u[u.EditionMarker=7]="EditionMarker"})(n=i.MetadataKey||(i.MetadataKey={}));var r=function(){function u(d){this.address=d.address,this.verified=d.verified,this.share=d.share}return u}();i.Creator=r;var s=function(){function u(d){var g;this.key=n.MetadataV1,this.updateAuthority=d.updateAuthority,this.mint=d.mint,this.data=d.data,this.primarySaleHappened=d.primarySaleHappened,this.isMutable=d.isMutable,this.editionNonce=(g=d.editionNonce)!==null&&g!==void 0?g:null}return u}();i.Metadata=s;var o=function(){function u(d){this.name=d.name,this.symbol=d.symbol,this.uri=d.uri,this.sellerFeeBasisPoints=d.sellerFeeBasisPoints,this.creators=d.creators}return u}();i.Data=o;var c=new Map([[o,{kind:"struct",fields:[["name","string"],["symbol","string"],["uri","string"],["sellerFeeBasisPoints","u16"],["creators",{kind:"option",type:[r]}]]}],[s,{kind:"struct",fields:[["key","u8"],["updateAuthority","pubkey"],["mint","pubkey"],["data",o],["primarySaleHappened","u8"],["isMutable","u8"]]}],[r,{kind:"struct",fields:[["address","pubkey"],["verified","u8"],["share","u8"]]}]]);i.METADATA_SCHEMA=c})(Vr);var ii={};(function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.extendBorsh=void 0;var e=Zt,t=pe,n=function(){t.BinaryReader.prototype.readPubkey=function(){var r=this,s=r.readFixedArray(32);return new e.PublicKey(s)},t.BinaryWriter.prototype.writePubkey=function(r){var s=this;s.writeFixedArray(r.toBuffer())}};i.extendBorsh=n,(0,i.extendBorsh)()})(ii);var oi=N&&N.__awaiter||function(i,e,t,n){function r(s){return s instanceof t?s:new t(function(o){o(s)})}return new(t||(t=Promise))(function(s,o){function c(g){try{d(n.next(g))}catch(m){o(m)}}function u(g){try{d(n.throw(g))}catch(m){o(m)}}function d(g){g.done?s(g.value):r(g.value).then(c,u)}d((n=n.apply(i,e||[])).next())})},ai=N&&N.__generator||function(i,e){var t={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},n,r,s,o;return o={next:c(0),throw:c(1),return:c(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function c(d){return function(g){return u([d,g])}}function u(d){if(n)throw new TypeError("Generator is already executing.");for(;t;)try{if(n=1,r&&(s=d[0]&2?r.return:d[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,d[1])).done)return s;switch(r=0,s&&(d=[d[0]&2,s.value]),d[0]){case 0:case 1:s=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,r=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(s=t.trys,!(s=s.length>0&&s[s.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!s||d[1]>s[0]&&d[1]<s[3])){t.label=d[1];break}if(d[0]===6&&t.label<s[1]){t.label=s[1],s=d;break}if(s&&t.label<s[2]){t.label=s[2],t.ops.push(d);break}s[2]&&t.ops.pop(),t.trys.pop();continue}d=e.call(i,t)}catch(g){d=[6,g],r=0}finally{n=s=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}};Object.defineProperty(Ce,"__esModule",{value:!0});Ce.createConnectionConfig=Ce.isValidSolanaAddress=Ce.getSolanaMetadataAddress=Ce.decodeTokenMetadata=void 0;var Rc=pe,qt=Zt,gn=Vr,vc=ii;(0,vc.extendBorsh)();var Tc=new qt.PublicKey(gn.METADATA_PROGRAM),Ec=Tc.toBuffer(),Pc=new TextEncoder().encode(gn.METADATA_PREFIX),Bc=function(i){return oi(void 0,void 0,void 0,function(){return ai(this,function(e){return[2,(0,Rc.deserializeUnchecked)(gn.METADATA_SCHEMA,gn.Metadata,i)]})})};Ce.decodeTokenMetadata=Bc;function Oc(i){return oi(this,void 0,void 0,function(){var e;return ai(this,function(t){switch(t.label){case 0:return e=new qt.PublicKey(gn.METADATA_PROGRAM),[4,qt.PublicKey.findProgramAddress([Pc,Ec,i.toBuffer()],e)];case 1:return[2,t.sent()[0]]}})})}Ce.getSolanaMetadataAddress=Oc;var Cc=function(i){try{return new qt.PublicKey(i),!0}catch{return!1}};Ce.isValidSolanaAddress=Cc;var Nc=function(i,e){return i===void 0&&(i=(0,qt.clusterApiUrl)("mainnet-beta")),e===void 0&&(e="confirmed"),new qt.Connection(i,e)};Ce.createConnectionConfig=Nc;var wn={};Object.defineProperty(wn,"__esModule",{value:!0});wn.TOKEN_PROGRAM=void 0;wn.TOKEN_PROGRAM="TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";(function(i){var e=N&&N.__assign||function(){return e=Object.assign||function(h){for(var k,S=1,C=arguments.length;S<C;S++){k=arguments[S];for(var K in k)Object.prototype.hasOwnProperty.call(k,K)&&(h[K]=k[K])}return h},e.apply(this,arguments)},t=N&&N.__awaiter||function(h,k,S,C){function K(L){return L instanceof S?L:new S(function(q){q(L)})}return new(S||(S=Promise))(function(L,q){function j(Ae){try{H(C.next(Ae))}catch(kt){q(kt)}}function ee(Ae){try{H(C.throw(Ae))}catch(kt){q(kt)}}function H(Ae){Ae.done?L(Ae.value):K(Ae.value).then(j,ee)}H((C=C.apply(h,k||[])).next())})},n=N&&N.__generator||function(h,k){var S={label:0,sent:function(){if(L[0]&1)throw L[1];return L[1]},trys:[],ops:[]},C,K,L,q;return q={next:j(0),throw:j(1),return:j(2)},typeof Symbol=="function"&&(q[Symbol.iterator]=function(){return this}),q;function j(H){return function(Ae){return ee([H,Ae])}}function ee(H){if(C)throw new TypeError("Generator is already executing.");for(;S;)try{if(C=1,K&&(L=H[0]&2?K.return:H[0]?K.throw||((L=K.return)&&L.call(K),0):K.next)&&!(L=L.call(K,H[1])).done)return L;switch(K=0,L&&(H=[H[0]&2,L.value]),H[0]){case 0:case 1:L=H;break;case 4:return S.label++,{value:H[1],done:!1};case 5:S.label++,K=H[1],H=[0];continue;case 7:H=S.ops.pop(),S.trys.pop();continue;default:if(L=S.trys,!(L=L.length>0&&L[L.length-1])&&(H[0]===6||H[0]===2)){S=0;continue}if(H[0]===3&&(!L||H[1]>L[0]&&H[1]<L[3])){S.label=H[1];break}if(H[0]===6&&S.label<L[1]){S.label=L[1],L=H;break}if(L&&S.label<L[2]){S.label=L[2],S.ops.push(H);break}L[2]&&S.ops.pop(),S.trys.pop();continue}H=k.call(h,S)}catch(Ae){H=[6,Ae],K=0}finally{C=L=0}if(H[0]&5)throw H[1];return{value:H[0]?H[1]:void 0,done:!0}}},r=N&&N.__importDefault||function(h){return h&&h.__esModule?h:{default:h}};Object.defineProperty(i,"__esModule",{value:!0}),i.sanitizeMetaStrings=i.getParsedNftAccountsByOwner=void 0;var s=Zt,o=r(hc),c=r(Or.exports),u=Ce,d=wn,g;(function(h){h.updateAuthority="updateAuthority"})(g||(g={}));var m=function(h){var k=h.publicAddress,S=h.connection,C=S===void 0?(0,u.createConnectionConfig)():S,K=h.sanitize,L=K===void 0?!0:K,q=h.stringifyPubKeys,j=q===void 0?!0:q,ee=h.sort,H=ee===void 0?!0:ee,Ae=h.limit,kt=Ae===void 0?5e3:Ae;return t(void 0,void 0,void 0,function(){var Sn,An,xt,In,Rn,vn,Tn,qe,En,nn,Pn;return n(this,function(_t){switch(_t.label){case 0:return Sn=(0,u.isValidSolanaAddress)(k),Sn?[4,C.getParsedTokenAccountsByOwner(new s.PublicKey(k),{programId:new s.PublicKey(d.TOKEN_PROGRAM)})]:[2,[]];case 1:return An=_t.sent().value,xt=An.filter(function(fe){var me,st,X,Ye,St,Me,Ut,zt,rn,Wt,Bn=(St=(Ye=(X=(st=(me=fe.account)===null||me===void 0?void 0:me.data)===null||st===void 0?void 0:st.parsed)===null||X===void 0?void 0:X.info)===null||Ye===void 0?void 0:Ye.tokenAmount)===null||St===void 0?void 0:St.uiAmount,On=(Wt=(rn=(zt=(Ut=(Me=fe.account)===null||Me===void 0?void 0:Me.data)===null||Ut===void 0?void 0:Ut.parsed)===null||zt===void 0?void 0:zt.info)===null||rn===void 0?void 0:rn.tokenAmount)===null||Wt===void 0?void 0:Wt.decimals;return On===0&&Bn>=1}).map(function(fe){var me,st,X,Ye,St=(Ye=(X=(st=(me=fe.account)===null||me===void 0?void 0:me.data)===null||st===void 0?void 0:st.parsed)===null||X===void 0?void 0:X.info)===null||Ye===void 0?void 0:Ye.mint;return new s.PublicKey(St)}),In=xt==null?void 0:xt.slice(0,kt),[4,Promise.allSettled(In.map(u.getSolanaMetadataAddress))];case 2:return Rn=_t.sent(),vn=Rn.filter(w).map(function(fe){return fe.value}),[4,Promise.allSettled((0,o.default)(vn,99).map(function(fe){return C.getMultipleAccountsInfo(fe)}))];case 3:return Tn=_t.sent(),qe=Tn.filter(function(fe){var me=fe.status;return me==="fulfilled"}).flatMap(function(fe){return fe.value}),!(qe!=null&&qe.length)||(qe==null?void 0:qe.length)===0?[2,[]]:[4,Promise.allSettled(qe.map(function(fe){var me;return(0,u.decodeTokenMetadata)((me=fe)===null||me===void 0?void 0:me.data)}))];case 4:return En=_t.sent(),nn=En.filter(w).filter(A).map(function(fe){var me=fe.value;return L?_(me):me}).map(function(fe){return j?f(fe):fe}),j&&H?(Pn=(0,c.default)(nn,[g.updateAuthority],["asc"]),[2,Pn]):[2,nn]}})})};i.getParsedNftAccountsByOwner=m;var _=function(h){var k,S,C;return e(e({},h),{data:e(e({},h==null?void 0:h.data),{name:(0,i.sanitizeMetaStrings)((k=h==null?void 0:h.data)===null||k===void 0?void 0:k.name),symbol:(0,i.sanitizeMetaStrings)((S=h==null?void 0:h.data)===null||S===void 0?void 0:S.symbol),uri:(0,i.sanitizeMetaStrings)((C=h==null?void 0:h.data)===null||C===void 0?void 0:C.uri)})})},f=function(h){var k,S,C,K,L,q;return e(e({},h),{mint:(S=(k=h==null?void 0:h.mint)===null||k===void 0?void 0:k.toString)===null||S===void 0?void 0:S.call(k),updateAuthority:(K=(C=h==null?void 0:h.updateAuthority)===null||C===void 0?void 0:C.toString)===null||K===void 0?void 0:K.call(C),data:e(e({},h==null?void 0:h.data),{creators:(q=(L=h==null?void 0:h.data)===null||L===void 0?void 0:L.creators)===null||q===void 0?void 0:q.map(function(j){var ee,H;return e(e({},j),{address:(H=(ee=new s.PublicKey(j==null?void 0:j.address))===null||ee===void 0?void 0:ee.toString)===null||H===void 0?void 0:H.call(ee)})})})})},b=function(h){return h.replace(/\0/g,"")};i.sanitizeMetaStrings=b;var w=function(h){return h&&h.status==="fulfilled"},A=function(h){var k,S,C,K=(C=(S=(k=h.value.data)===null||k===void 0?void 0:k.uri)===null||S===void 0?void 0:S.replace)===null||C===void 0?void 0:C.call(S,/\0/g,"");return K!==""&&K!==void 0}})(Xs);var ci={};(function(i){var e=N&&N.__awaiter||function(u,d,g,m){function _(f){return f instanceof g?f:new g(function(b){b(f)})}return new(g||(g=Promise))(function(f,b){function w(k){try{h(m.next(k))}catch(S){b(S)}}function A(k){try{h(m.throw(k))}catch(S){b(S)}}function h(k){k.done?f(k.value):_(k.value).then(w,A)}h((m=m.apply(u,d||[])).next())})},t=N&&N.__generator||function(u,d){var g={label:0,sent:function(){if(f[0]&1)throw f[1];return f[1]},trys:[],ops:[]},m,_,f,b;return b={next:w(0),throw:w(1),return:w(2)},typeof Symbol=="function"&&(b[Symbol.iterator]=function(){return this}),b;function w(h){return function(k){return A([h,k])}}function A(h){if(m)throw new TypeError("Generator is already executing.");for(;g;)try{if(m=1,_&&(f=h[0]&2?_.return:h[0]?_.throw||((f=_.return)&&f.call(_),0):_.next)&&!(f=f.call(_,h[1])).done)return f;switch(_=0,f&&(h=[h[0]&2,f.value]),h[0]){case 0:case 1:f=h;break;case 4:return g.label++,{value:h[1],done:!1};case 5:g.label++,_=h[1],h=[0];continue;case 7:h=g.ops.pop(),g.trys.pop();continue;default:if(f=g.trys,!(f=f.length>0&&f[f.length-1])&&(h[0]===6||h[0]===2)){g=0;continue}if(h[0]===3&&(!f||h[1]>f[0]&&h[1]<f[3])){g.label=h[1];break}if(h[0]===6&&g.label<f[1]){g.label=f[1],f=h;break}if(f&&g.label<f[2]){g.label=f[2],g.ops.push(h);break}f[2]&&g.ops.pop(),g.trys.pop();continue}h=d.call(u,g)}catch(k){h=[6,k],_=0}finally{m=f=0}if(h[0]&5)throw h[1];return{value:h[0]?h[1]:void 0,done:!0}}};Object.defineProperty(i,"__esModule",{value:!0}),i.getParsedNftAccountsByUpdateAuthority=i.createConnectionConfig=void 0;var n=Zt,r=Vr,s=Ce,o=function(u,d){return u===void 0&&(u=(0,n.clusterApiUrl)("mainnet-beta")),d===void 0&&(d="confirmed"),new n.Connection(u,d)};i.createConnectionConfig=o;var c=function(u){var d=u.updateAuthority,g=u.connection,m=g===void 0?(0,i.createConnectionConfig)():g;return e(void 0,void 0,void 0,function(){var _,f,b;return t(this,function(w){switch(w.label){case 0:return w.trys.push([0,3,,4]),[4,m.getProgramAccounts(new n.PublicKey(r.METADATA_PROGRAM),{encoding:"base64",filters:[{memcmp:{offset:1,bytes:d}}]})];case 1:return _=w.sent(),[4,Promise.all(_.map(function(A){return(0,s.decodeTokenMetadata)(A.account.data)}))];case 2:return f=w.sent(),[2,f];case 3:return b=w.sent(),console.error(b),[2,[]];case 4:return[2]}})})};i.getParsedNftAccountsByUpdateAuthority=c})(ci);var rr={},$t=N&&N.__assign||function(){return $t=Object.assign||function(i){for(var e,t=1,n=arguments.length;t<n;t++){e=arguments[t];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(i[r]=e[r])}return i},$t.apply(this,arguments)},Lc=N&&N.__awaiter||function(i,e,t,n){function r(s){return s instanceof t?s:new t(function(o){o(s)})}return new(t||(t=Promise))(function(s,o){function c(g){try{d(n.next(g))}catch(m){o(m)}}function u(g){try{d(n.throw(g))}catch(m){o(m)}}function d(g){g.done?s(g.value):r(g.value).then(c,u)}d((n=n.apply(i,e||[])).next())})},Kc=N&&N.__generator||function(i,e){var t={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},n,r,s,o;return o={next:c(0),throw:c(1),return:c(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function c(d){return function(g){return u([d,g])}}function u(d){if(n)throw new TypeError("Generator is already executing.");for(;t;)try{if(n=1,r&&(s=d[0]&2?r.return:d[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,d[1])).done)return s;switch(r=0,s&&(d=[d[0]&2,s.value]),d[0]){case 0:case 1:s=d;break;case 4:return t.label++,{value:d[1],done:!1};case 5:t.label++,r=d[1],d=[0];continue;case 7:d=t.ops.pop(),t.trys.pop();continue;default:if(s=t.trys,!(s=s.length>0&&s[s.length-1])&&(d[0]===6||d[0]===2)){t=0;continue}if(d[0]===3&&(!s||d[1]>s[0]&&d[1]<s[3])){t.label=d[1];break}if(d[0]===6&&t.label<s[1]){t.label=s[1],s=d;break}if(s&&t.label<s[2]){t.label=s[2],t.ops.push(d);break}s[2]&&t.ops.pop(),t.trys.pop();continue}d=e.call(i,t)}catch(g){d=[6,g],r=0}finally{n=s=0}if(d[0]&5)throw d[1];return{value:d[0]?d[1]:void 0,done:!0}}};Object.defineProperty(rr,"__esModule",{value:!0});rr.getParsedAccountByMint=void 0;var Cr=Zt,xc=wn,Uc=Ce;function zc(i){return(i==null?void 0:i.parsed)!==void 0}var Wc=function(i){var e=i.mintAddress,t=i.connection,n=t===void 0?(0,Uc.createConnectionConfig)():t,r=i.stringifyPubKeys,s=r===void 0?!0:r;return Lc(void 0,void 0,void 0,function(){var o,c,u;return Kc(this,function(d){switch(d.label){case 0:return[4,n.getParsedProgramAccounts(new Cr.PublicKey(xc.TOKEN_PROGRAM),{filters:[{dataSize:165},{memcmp:{offset:0,bytes:e}}]})];case 1:return o=d.sent(),o!=null&&o.length?(c=o==null?void 0:o.find(function(g){var m,_,f,b=g.account,w=b.data;if(zc(w)){var A=+((f=(_=(m=w==null?void 0:w.parsed)===null||m===void 0?void 0:m.info)===null||_===void 0?void 0:_.tokenAmount)===null||f===void 0?void 0:f.amount);return A}return!1}),u=s?Mc(c):c,[2,u]):[2,void 0]}})})};rr.getParsedAccountByMint=Wc;var Mc=function(i){var e,t,n,r;return $t($t({},i),{account:$t($t({},i==null?void 0:i.account),{owner:(t=(e=new Cr.PublicKey(i==null?void 0:i.account.owner))===null||e===void 0?void 0:e.toString)===null||t===void 0?void 0:t.call(e)}),pubkey:(r=(n=new Cr.PublicKey(i==null?void 0:i.pubkey))===null||n===void 0?void 0:n.toString)===null||r===void 0?void 0:r.call(n)})},ui={},li={},sr={},_e={},Dc=N&&N.__createBinding||(Object.create?function(i,e,t,n){n===void 0&&(n=t),Object.defineProperty(i,n,{enumerable:!0,get:function(){return e[t]}})}:function(i,e,t,n){n===void 0&&(n=t),i[n]=e[t]}),$c=N&&N.__setModuleDefault||(Object.create?function(i,e){Object.defineProperty(i,"default",{enumerable:!0,value:e})}:function(i,e){i.default=e}),et=N&&N.__decorate||function(i,e,t,n){var r=arguments.length,s=r<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(i,e,t,n);else for(var c=i.length-1;c>=0;c--)(o=i[c])&&(s=(r<3?o(s):r>3?o(e,t,s):o(e,t))||s);return r>3&&s&&Object.defineProperty(e,t,s),s},Fc=N&&N.__importStar||function(i){if(i&&i.__esModule)return i;var e={};if(i!=null)for(var t in i)t!=="default"&&Object.hasOwnProperty.call(i,t)&&Dc(e,i,t);return $c(e,i),e},di=N&&N.__importDefault||function(i){return i&&i.__esModule?i:{default:i}};Object.defineProperty(_e,"__esModule",{value:!0});var fi=_e.deserializeUnchecked=mi=_e.deserialize=bi=_e.serialize=_e.BinaryReader=_e.BinaryWriter=_e.BorshError=_e.baseDecode=_e.baseEncode=void 0;const bt=di(nr.exports),hi=di(ge),Hc=Fc(Mr),Vc=typeof TextDecoder!="function"?Hc.TextDecoder:TextDecoder,Gc=new Vc("utf-8",{fatal:!0});function qc(i){return typeof i=="string"&&(i=x.Buffer.from(i,"utf8")),hi.default.encode(x.Buffer.from(i))}_e.baseEncode=qc;function Yc(i){return x.Buffer.from(hi.default.decode(i))}_e.baseDecode=Yc;const Ar=1024;class Ee extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}_e.BorshError=Ee;class gi{constructor(){this.buf=x.Buffer.alloc(Ar),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=x.Buffer.concat([this.buf,x.Buffer.alloc(Ar)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new bt.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new bt.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new bt.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new bt.default(e).toArray("le",64)))}writeBuffer(e){this.buf=x.Buffer.concat([x.Buffer.from(this.buf.subarray(0,this.length)),e,x.Buffer.alloc(Ar)]),this.length+=e.length}writeString(e){this.maybeResize();const t=x.Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(x.Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}}_e.BinaryWriter=gi;function tt(i,e,t){const n=t.value;t.value=function(...r){try{return n.apply(this,r)}catch(s){if(s instanceof RangeError){const o=s.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(o)>=0)throw new Ee("Reached the end of buffer when deserializing")}throw s}}}class ze{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new bt.default(e,"le")}readU128(){const e=this.readBuffer(16);return new bt.default(e,"le")}readU256(){const e=this.readBuffer(32);return new bt.default(e,"le")}readU512(){const e=this.readBuffer(64);return new bt.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new Ee(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return Gc.decode(t)}catch(n){throw new Ee(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let r=0;r<t;++r)n.push(e());return n}}et([tt],ze.prototype,"readU8",null);et([tt],ze.prototype,"readU16",null);et([tt],ze.prototype,"readU32",null);et([tt],ze.prototype,"readU64",null);et([tt],ze.prototype,"readU128",null);et([tt],ze.prototype,"readU256",null);et([tt],ze.prototype,"readU512",null);et([tt],ze.prototype,"readString",null);et([tt],ze.prototype,"readFixedArray",null);et([tt],ze.prototype,"readArray",null);_e.BinaryReader=ze;function yi(i){return i.charAt(0).toUpperCase()+i.slice(1)}function vt(i,e,t,n,r){try{if(typeof n=="string")r[`write${yi(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new Ee(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);r.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new Ee(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let s=0;s<n[1];s++)vt(i,null,t[s],n[0],r)}else r.writeArray(t,s=>{vt(i,e,s,n[0],r)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?r.writeU8(0):(r.writeU8(1),vt(i,e,t,n.type,r));break}case"map":{r.writeU32(t.size),t.forEach((s,o)=>{vt(i,e,o,n.key,r),vt(i,e,s,n.value,r)});break}default:throw new Ee(`FieldType ${n} unrecognized`)}else pi(i,t,r)}catch(s){throw s instanceof Ee&&s.addToFieldPath(e),s}}function pi(i,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const n=i.get(e.constructor);if(!n)throw new Ee(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([r,s])=>{vt(i,r,e[r],s,t)});else if(n.kind==="enum"){const r=e[n.field];for(let s=0;s<n.values.length;++s){const[o,c]=n.values[s];if(o===r){t.writeU8(s),vt(i,o,e[o],c,t);break}}}else throw new Ee(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function jc(i,e,t=gi){const n=new t;return pi(i,e,n),n.toArray()}var bi=_e.serialize=jc;function Tt(i,e,t,n){try{if(typeof t=="string")return n[`read${yi(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){const r=[];for(let s=0;s<t[1];s++)r.push(Tt(i,null,t[0],n));return r}else return n.readArray(()=>Tt(i,e,t[0],n))}if(t.kind==="option")return n.readU8()?Tt(i,e,t.type,n):void 0;if(t.kind==="map"){let r=new Map;const s=n.readU32();for(let o=0;o<s;o++){const c=Tt(i,e,t.key,n),u=Tt(i,e,t.value,n);r.set(c,u)}return r}return Gr(i,t,n)}catch(r){throw r instanceof Ee&&r.addToFieldPath(e),r}}function Gr(i,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const n=i.get(e);if(!n)throw new Ee(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const r={};for(const[s,o]of i.get(e).fields)r[s]=Tt(i,s,o,t);return new e(r)}if(n.kind==="enum"){const r=t.readU8();if(r>=n.values.length)throw new Ee(`Enum index: ${r} is out of range`);const[s,o]=n.values[r],c=Tt(i,s,o,t);return new e({[s]:c})}throw new Ee(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Jc(i,e,t,n=ze){const r=new n(t),s=Gr(i,e,r);if(r.offset<t.length)throw new Ee(`Unexpected ${t.length-r.offset} bytes after deserialized data`);return s}var mi=_e.deserialize=Jc;function Xc(i,e,t,n=ze){const r=new n(t);return Gr(i,e,r)}fi=_e.deserializeUnchecked=Xc;const Zc=Qt.utils.randomPrivateKey,Os=()=>{const i=Qt.utils.randomPrivateKey(),e=Jn(i),t=new Uint8Array(64);return t.set(i),t.set(e,32),{publicKey:e,secretKey:t}},Jn=Qt.getPublicKey;function Cs(i){try{return Qt.ExtendedPoint.fromHex(i),!0}catch{return!1}}const qr=(i,e)=>Qt.sign(i,e.slice(0,32)),Qc=Qt.verify,G=i=>D.Buffer.isBuffer(i)?i:i instanceof Uint8Array?D.Buffer.from(i.buffer,i.byteOffset,i.byteLength):D.Buffer.from(i);class Yr{constructor(e){Object.assign(this,e)}encode(){return D.Buffer.from(bi(hn,this))}static decode(e){return mi(hn,this,e)}static decodeUnchecked(e){return fi(hn,this,e)}}class eu extends Yr{constructor(e){if(super(e),this.enum="",Object.keys(e).length!==1)throw new Error("Enum can only take single value");Object.keys(e).map(t=>{this.enum=t})}}const hn=new Map;var wi;let ki;const _i=32,xe=32;function tu(i){return i._bn!==void 0}let Ns=1;ki=Symbol.toStringTag;class T extends Yr{constructor(e){if(super({}),this._bn=void 0,tu(e))this._bn=e._bn;else{if(typeof e=="string"){const t=ge.decode(e);if(t.length!=xe)throw new Error("Invalid public key input");this._bn=new vs(t)}else this._bn=new vs(e);if(this._bn.byteLength()>xe)throw new Error("Invalid public key input")}}static unique(){const e=new T(Ns);return Ns+=1,new T(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return ge.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(D.Buffer);if(e.length===xe)return e;const t=D.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[ki](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const r=D.Buffer.concat([e.toBuffer(),D.Buffer.from(t),n.toBuffer()]),s=Ts(r);return new T(s)}static createProgramAddressSync(e,t){let n=D.Buffer.alloc(0);e.forEach(function(s){if(s.length>_i)throw new TypeError("Max seed length exceeded");n=D.Buffer.concat([n,G(s)])}),n=D.Buffer.concat([n,t.toBuffer(),D.Buffer.from("ProgramDerivedAddress")]);const r=Ts(n);if(Cs(r))throw new Error("Invalid seeds, address must fall off the curve");return new T(r)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,r;for(;n!=0;){try{const s=e.concat(D.Buffer.from([n]));r=this.createProgramAddressSync(s,t)}catch(s){if(s instanceof TypeError)throw s;n--;continue}return[r,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new T(e);return Cs(t.toBytes())}}wi=T;T.default=new wi("11111111111111111111111111111111");hn.set(T,{kind:"struct",fields:[["_bn","u256"]]});class nu{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=G(e);if(e.length!==64)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=G(Zc()),this._publicKey=G(Jn(this._secretKey))}get publicKey(){return new T(this._publicKey)}get secretKey(){return D.Buffer.concat([this._secretKey,this._publicKey],64)}}const ru=new T("BPFLoader1111111111111111111111111111111111"),wt=1280-40-8,ir=127,Yt=64;class jr extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(jr.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class Jr extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Jr.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Ft extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Ft.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class yn{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((s,o)=>{n.set(s.toBase58(),o)});const r=s=>{const o=n.get(s.toBase58());if(o===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return o};return e.map(s=>({programIdIndex:r(s.programId),accountKeyIndexes:s.keys.map(o=>r(o.pubkey)),data:s.data}))}}const Y=(i="publicKey")=>ue(32,i),su=(i="signature")=>ue(64,i),Pt=(i="string")=>{const e=U([z("length"),z("lengthPadding"),ue(Bt(z(),-8),"chars")],i),t=e.decode.bind(e),n=e.encode.bind(e),r=e;return r.decode=(s,o)=>t(s,o).chars.toString(),r.encode=(s,o,c)=>{const u={chars:D.Buffer.from(s,"utf8")};return n(u,o,c)},r.alloc=s=>z().span+z().span+D.Buffer.from(s,"utf8").length,r},iu=(i="authorized")=>U([Y("staker"),Y("withdrawer")],i),ou=(i="lockup")=>U([Fe("unixTimestamp"),Fe("epoch"),Y("custodian")],i),au=(i="voteInit")=>U([Y("nodePubkey"),Y("authorizedVoter"),Y("authorizedWithdrawer"),ne("commission")],i),cu=(i="voteAuthorizeWithSeedArgs")=>U([z("voteAuthorizationType"),Y("currentAuthorityDerivedKeyOwnerPubkey"),Pt("currentAuthorityDerivedKeySeed"),Y("newAuthorized")],i);function Si(i,e){const t=r=>{if(r.span>=0)return r.span;if(typeof r.alloc=="function")return r.alloc(e[r.property]);if("count"in r&&"elementLayout"in r){const s=e[r.property];if(Array.isArray(s))return s.length*t(r.elementLayout)}else if("fields"in r)return Si({layout:r},e[r.property]);return 0};let n=0;return i.layout.fields.forEach(r=>{n+=t(r)}),n}function Oe(i){let e=0,t=0;for(;;){let n=i.shift();if(e|=(n&127)<<t*7,t+=1,(n&128)===0)break}return e}function Ke(i,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){i.push(n);break}else n|=128,i.push(n)}}function te(i,e){if(!i)throw new Error(e||"Assertion failed")}class or{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,r=o=>{const c=o.toBase58();let u=n.get(c);return u===void 0&&(u={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(c,u)),u},s=r(t);s.isSigner=!0,s.isWritable=!0;for(const o of e){r(o.programId).isInvoked=!0;for(const c of o.keys){const u=r(c.pubkey);u.isSigner||=c.isSigner,u.isWritable||=c.isWritable}}return new or(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];te(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,u])=>u.isSigner&&u.isWritable),n=e.filter(([,u])=>u.isSigner&&!u.isWritable),r=e.filter(([,u])=>!u.isSigner&&u.isWritable),s=e.filter(([,u])=>!u.isSigner&&!u.isWritable),o={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:s.length};{te(t.length>0,"Expected at least one writable signer key");const[u]=t[0];te(u===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const c=[...t.map(([u])=>new T(u)),...n.map(([u])=>new T(u)),...r.map(([u])=>new T(u)),...s.map(([u])=>new T(u))];return[o,c]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&o.isWritable),[r,s]=this.drainKeysFoundInLookupTable(e.state.addresses,o=>!o.isSigner&&!o.isInvoked&&!o.isWritable);if(!(t.length===0&&r.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:r},{writable:n,readonly:s}]}drainKeysFoundInLookupTable(e,t){const n=new Array,r=new Array;for(const[s,o]of this.keyMetaMap.entries())if(t(o)){const c=new T(s),u=e.findIndex(d=>d.equals(c));u>=0&&(te(u<256,"Max lookup table index exceeded"),n.push(u),r.push(c),this.keyMetaMap.delete(s))}return[n,r]}}class Ge{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new T(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:ge.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new yn(this.staticAccountKeys)}static compile(e){const t=or.compile(e.instructions,e.payerKey),[n,r]=t.getMessageComponents(),o=new yn(r).compileInstructions(e.instructions).map(c=>({programIdIndex:c.programIdIndex,accounts:c.accountKeyIndexes,data:ge.encode(c.data)}));return new Ge({header:n,accountKeys:r,recentBlockhash:e.recentBlockhash,instructions:o})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,s=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<s}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Ke(t,e);const n=this.instructions.map(m=>{const{accounts:_,programIdIndex:f}=m,b=Array.from(ge.decode(m.data));let w=[];Ke(w,_.length);let A=[];return Ke(A,b.length),{programIdIndex:f,keyIndicesCount:D.Buffer.from(w),keyIndices:_,dataLength:D.Buffer.from(A),data:b}});let r=[];Ke(r,n.length);let s=D.Buffer.alloc(wt);D.Buffer.from(r).copy(s);let o=r.length;n.forEach(m=>{o+=U([ne("programIdIndex"),ue(m.keyIndicesCount.length,"keyIndicesCount"),Re(ne("keyIndex"),m.keyIndices.length,"keyIndices"),ue(m.dataLength.length,"dataLength"),Re(ne("userdatum"),m.data.length,"data")]).encode(m,s,o)}),s=s.slice(0,o);const c=U([ue(1,"numRequiredSignatures"),ue(1,"numReadonlySignedAccounts"),ue(1,"numReadonlyUnsignedAccounts"),ue(t.length,"keyCount"),Re(Y("key"),e,"keys"),Y("recentBlockhash")]),u={numRequiredSignatures:D.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:D.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:D.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:D.Buffer.from(t),keys:this.accountKeys.map(m=>G(m.toBytes())),recentBlockhash:ge.decode(this.recentBlockhash)};let d=D.Buffer.alloc(2048);const g=c.encode(u,d);return s.copy(d,g),d.slice(0,g+s.length)}static from(e){let t=[...e];const n=t.shift();if(n!==(n&ir))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const r=t.shift(),s=t.shift(),o=Oe(t);let c=[];for(let _=0;_<o;_++){const f=t.slice(0,xe);t=t.slice(xe),c.push(new T(D.Buffer.from(f)))}const u=t.slice(0,xe);t=t.slice(xe);const d=Oe(t);let g=[];for(let _=0;_<d;_++){const f=t.shift(),b=Oe(t),w=t.slice(0,b);t=t.slice(b);const A=Oe(t),h=t.slice(0,A),k=ge.encode(D.Buffer.from(h));t=t.slice(A),g.push({programIdIndex:f,accounts:w,data:k})}const m={header:{numRequiredSignatures:n,numReadonlySignedAccounts:r,numReadonlyUnsignedAccounts:s},recentBlockhash:ge.encode(D.Buffer.from(u)),accountKeys:c,instructions:g};return new Ge(m)}}class Ot{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new yn(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const r=e-n,s=this.addressTableLookups.reduce((o,c)=>o+c.writableIndexes.length,0);return r<s}else if(e>=this.header.numRequiredSignatures){const r=e-t,o=n-t-this.header.numReadonlyUnsignedAccounts;return r<o}else{const r=t-this.header.numReadonlySignedAccounts;return e<r}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const r=e.find(s=>s.key.equals(n.accountKey));if(!r)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const s of n.writableIndexes)if(s<r.state.addresses.length)t.writable.push(r.state.addresses[s]);else throw new Error(`Failed to find address for index ${s} in address lookup table ${n.accountKey.toBase58()}`);for(const s of n.readonlyIndexes)if(s<r.state.addresses.length)t.readonly.push(r.state.addresses[s]);else throw new Error(`Failed to find address for index ${s} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=or.compile(e.instructions,e.payerKey),n=new Array,r={writable:new Array,readonly:new Array},s=e.addressLookupTableAccounts||[];for(const g of s){const m=t.extractTableLookup(g);if(m!==void 0){const[_,{writable:f,readonly:b}]=m;n.push(_),r.writable.push(...f),r.readonly.push(...b)}}const[o,c]=t.getMessageComponents(),d=new yn(c,r).compileInstructions(e.instructions);return new Ot({header:o,staticAccountKeys:c,recentBlockhash:e.recentBlockhash,compiledInstructions:d,addressTableLookups:n})}serialize(){const e=Array();Ke(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Ke(n,this.compiledInstructions.length);const r=this.serializeAddressTableLookups(),s=Array();Ke(s,this.addressTableLookups.length);const o=U([ne("prefix"),U([ne("numRequiredSignatures"),ne("numReadonlySignedAccounts"),ne("numReadonlyUnsignedAccounts")],"header"),ue(e.length,"staticAccountKeysLength"),Re(Y(),this.staticAccountKeys.length,"staticAccountKeys"),Y("recentBlockhash"),ue(n.length,"instructionsLength"),ue(t.length,"serializedInstructions"),ue(s.length,"addressTableLookupsLength"),ue(r.length,"serializedAddressTableLookups")]),c=new Uint8Array(wt),u=1<<7,d=o.encode({prefix:u,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(g=>g.toBytes()),recentBlockhash:ge.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(s),serializedAddressTableLookups:r},c);return c.slice(0,d)}serializeInstructions(){let e=0;const t=new Uint8Array(wt);for(const n of this.compiledInstructions){const r=Array();Ke(r,n.accountKeyIndexes.length);const s=Array();Ke(s,n.data.length),e+=U([ne("programIdIndex"),ue(r.length,"encodedAccountKeyIndexesLength"),Re(ne(),n.accountKeyIndexes.length,"accountKeyIndexes"),ue(s.length,"encodedDataLength"),ue(n.data.length,"data")]).encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(r),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(s),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(wt);for(const n of this.addressTableLookups){const r=Array();Ke(r,n.writableIndexes.length);const s=Array();Ke(s,n.readonlyIndexes.length),e+=U([Y("accountKey"),ue(r.length,"encodedWritableIndexesLength"),Re(ne(),n.writableIndexes.length,"writableIndexes"),ue(s.length,"encodedReadonlyIndexesLength"),Re(ne(),n.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(r),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(s),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=t.shift(),r=n&ir;te(n!==r,"Expected versioned message but received legacy message");const s=r;te(s===0,`Expected versioned message with version 0 but found version ${s}`);const o={numRequiredSignatures:t.shift(),numReadonlySignedAccounts:t.shift(),numReadonlyUnsignedAccounts:t.shift()},c=[],u=Oe(t);for(let b=0;b<u;b++)c.push(new T(t.splice(0,xe)));const d=ge.encode(t.splice(0,xe)),g=Oe(t),m=[];for(let b=0;b<g;b++){const w=t.shift(),A=Oe(t),h=t.splice(0,A),k=Oe(t),S=new Uint8Array(t.splice(0,k));m.push({programIdIndex:w,accountKeyIndexes:h,data:S})}const _=Oe(t),f=[];for(let b=0;b<_;b++){const w=new T(t.splice(0,xe)),A=Oe(t),h=t.splice(0,A),k=Oe(t),S=t.splice(0,k);f.push({accountKey:w,writableIndexes:h,readonlyIndexes:S})}return new Ot({header:o,staticAccountKeys:c,recentBlockhash:d,compiledInstructions:m,addressTableLookups:f})}}const Xr={deserializeMessageVersion(i){const e=i[0],t=e&ir;return t===e?"legacy":t},deserialize:i=>{const e=Xr.deserializeMessageVersion(i);if(e==="legacy")return Ge.from(i);if(e===0)return Ot.deserialize(i);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let dt=function(i){return i[i.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",i[i.PROCESSED=1]="PROCESSED",i[i.TIMED_OUT=2]="TIMED_OUT",i[i.NONCE_INVALID=3]="NONCE_INVALID",i}({});const uu=D.Buffer.alloc(Yt).fill(0);class oe{constructor(e){this.keys=void 0,this.programId=void 0,this.data=D.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class se{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new oe(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let w=0;w<t.length;w++)if(t[w].programId===void 0)throw new Error(`Transaction instruction index ${w} has undefined program id`);const r=[],s=[];t.forEach(w=>{w.keys.forEach(h=>{s.push({...h})});const A=w.programId.toString();r.includes(A)||r.push(A)}),r.forEach(w=>{s.push({pubkey:new T(w),isSigner:!1,isWritable:!1})});const o=[];s.forEach(w=>{const A=w.pubkey.toString(),h=o.findIndex(k=>k.pubkey.toString()===A);h>-1?(o[h].isWritable=o[h].isWritable||w.isWritable,o[h].isSigner=o[h].isSigner||w.isSigner):o.push(w)}),o.sort(function(w,A){if(w.isSigner!==A.isSigner)return w.isSigner?-1:1;if(w.isWritable!==A.isWritable)return w.isWritable?-1:1;const h={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return w.pubkey.toBase58().localeCompare(A.pubkey.toBase58(),"en",h)});const c=o.findIndex(w=>w.pubkey.equals(n));if(c>-1){const[w]=o.splice(c,1);w.isSigner=!0,w.isWritable=!0,o.unshift(w)}else o.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const w of this.signatures){const A=o.findIndex(h=>h.pubkey.equals(w.publicKey));if(A>-1)o[A].isSigner||(o[A].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${w.publicKey.toString()}`)}let u=0,d=0,g=0;const m=[],_=[];o.forEach(({pubkey:w,isSigner:A,isWritable:h})=>{A?(m.push(w.toString()),u+=1,h||(d+=1)):(_.push(w.toString()),h||(g+=1))});const f=m.concat(_),b=t.map(w=>{const{data:A,programId:h}=w;return{programIdIndex:f.indexOf(h.toString()),accounts:w.keys.map(k=>f.indexOf(k.pubkey.toString())),data:ge.encode(A)}});return b.forEach(w=>{te(w.programIdIndex>=0),w.accounts.forEach(A=>te(A>=0))}),new Ge({header:{numRequiredSignatures:u,numReadonlySignedAccounts:d,numReadonlyUnsignedAccounts:g},accountKeys:f,recentBlockhash:e,instructions:b})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((r,s)=>t[s].equals(r.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const r=n.toString();return t.has(r)?!1:(t.add(r),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const s of e){const o=s.publicKey.toString();t.has(o)||(t.add(o),n.push(s))}this.signatures=n.map(s=>({signature:null,publicKey:s.publicKey}));const r=this._compile();this._partialSign(r,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const s of e){const o=s.publicKey.toString();t.has(o)||(t.add(o),n.push(s))}const r=this._compile();this._partialSign(r,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(r=>{const s=qr(n,r.secretKey);this._addSignature(r.publicKey,G(s))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){te(t.length===64);const n=this.signatures.findIndex(r=>e.equals(r.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=D.Buffer.from(t)}verifySignatures(e){return this._verifySignatures(this.serializeMessage(),e===void 0?!0:e)}_verifySignatures(e,t){for(const{signature:n,publicKey:r}of this.signatures)if(n===null){if(t)return!1}else if(!Qc(n,e,r.toBytes()))return!1;return!0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),r=this.serializeMessage();if(n&&!this._verifySignatures(r,t))throw new Error("Signature verification failed");return this._serialize(r)}_serialize(e){const{signatures:t}=this,n=[];Ke(n,t.length);const r=n.length+t.length*64+e.length,s=D.Buffer.alloc(r);return te(t.length<256),D.Buffer.from(n).copy(s,0),t.forEach(({signature:o},c)=>{o!==null&&(te(o.length===64,"signature has invalid length"),D.Buffer.from(o).copy(s,n.length+c*64))}),e.copy(s,n.length+t.length*64),te(s.length<=wt,`Transaction too large: ${s.length} > ${wt}`),s}get keys(){return te(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return te(this.instructions.length===1),this.instructions[0].programId}get data(){return te(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=Oe(t);let r=[];for(let s=0;s<n;s++){const o=t.slice(0,Yt);t=t.slice(Yt),r.push(ge.encode(D.Buffer.from(o)))}return se.populate(Ge.from(t),r)}static populate(e,t=[]){const n=new se;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((r,s)=>{const o={signature:r==ge.encode(uu)?null:ge.decode(r),publicKey:e.accountKeys[s]};n.signatures.push(o)}),e.instructions.forEach(r=>{const s=r.accounts.map(o=>{const c=e.accountKeys[o];return{pubkey:c,isSigner:n.signatures.some(u=>u.publicKey.toString()===c.toString())||e.isAccountSigner(o),isWritable:e.isAccountWritable(o)}});n.instructions.push(new oe({keys:s,programId:e.accountKeys[r.programIdIndex],data:ge.decode(r.data)}))}),n._message=e,n._json=n.toJSON(),n}}class Zr{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:n,compiledInstructions:r,recentBlockhash:s}=e,{numRequiredSignatures:o,numReadonlySignedAccounts:c,numReadonlyUnsignedAccounts:u}=n,d=o-c;te(d>0,"Message header is invalid");const g=e.staticAccountKeys.length-o-u;te(g>=0,"Message header is invalid");const m=e.getAccountKeys(t),_=m.get(0);if(_===void 0)throw new Error("Failed to decompile message because no account keys were found");const f=[];for(const b of r){const w=[];for(const h of b.accountKeyIndexes){const k=m.get(h);if(k===void 0)throw new Error(`Failed to find key for account key index ${h}`);const S=h<o;let C;S?C=h<d:h<m.staticAccountKeys.length?C=h-o<g:C=h-m.staticAccountKeys.length<m.accountKeysFromLookups.writable.length,w.push({pubkey:k,isSigner:h<n.numRequiredSignatures,isWritable:C})}const A=m.get(b.programIdIndex);if(A===void 0)throw new Error(`Failed to find program id for program id index ${b.programIdIndex}`);f.push(new oe({programId:A,data:G(b.data),keys:w}))}return new Zr({payerKey:_,instructions:f,recentBlockhash:s})}compileToLegacyMessage(){return Ge.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return Ot.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class Qr{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)te(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const n=[];for(let r=0;r<e.header.numRequiredSignatures;r++)n.push(new Uint8Array(Yt));this.signatures=n}this.message=e}serialize(){const e=this.message.serialize(),t=Array();Ke(t,this.signatures.length);const n=U([ue(t.length,"encodedSignaturesLength"),Re(su(),this.signatures.length,"signatures"),ue(e.length,"serializedMessage")]),r=new Uint8Array(2048),s=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},r);return r.slice(0,s)}static deserialize(e){let t=[...e];const n=[],r=Oe(t);for(let o=0;o<r;o++)n.push(new Uint8Array(t.splice(0,Yt)));const s=Xr.deserialize(new Uint8Array(t));return new Qr(s,n)}sign(e){const t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const r of e){const s=n.findIndex(o=>o.equals(r.publicKey));te(s>=0,`Cannot sign with non signer key ${r.publicKey.toBase58()}`),this.signatures[s]=qr(t,r.secretKey)}}addSignature(e,t){te(t.byteLength===64,"Signature must be 64 bytes long");const r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(s=>s.equals(e));te(r>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=t}}const lu=160,du=64,fu=lu/du,Ai=1e3/fu,je=new T("SysvarC1ock11111111111111111111111111111111"),hu=new T("SysvarEpochSchedu1e111111111111111111111111"),gu=new T("Sysvar1nstructions1111111111111111111111111"),qn=new T("SysvarRecentB1ockHashes11111111111111111111"),jt=new T("SysvarRent111111111111111111111111111111111"),yu=new T("SysvarRewards111111111111111111111111111111"),pu=new T("SysvarS1otHashes111111111111111111111111111"),bu=new T("SysvarS1otHistory11111111111111111111111111"),Yn=new T("SysvarStakeHistory1111111111111111111111111");async function Nr(i,e,t,n){const r=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},s=await i.sendTransaction(e,t,r);let o;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)o=(await i.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,signature:s,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},n&&n.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){const{nonceInstruction:c}=e.nonceInfo,u=c.keys[0].pubkey;o=(await i.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:u,nonceValue:e.nonceInfo.nonce,signature:s},n&&n.commitment)).value}else(n==null?void 0:n.abortSignal)!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),o=(await i.confirmTransaction(s,n&&n.commitment)).value;if(o.err)throw new Error(`Transaction ${s} failed (${JSON.stringify(o)})`);return s}function Et(i){return new Promise(e=>setTimeout(e,i))}function Q(i,e){const t=i.layout.span>=0?i.layout.span:Si(i,e),n=D.Buffer.alloc(t),r=Object.assign({instruction:i.index},e);return i.layout.encode(r,n),n}function re(i,e){let t;try{t=i.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.instruction!==i.index)throw new Error(`invalid instruction; instruction index mismatch ${t.instruction} != ${i.index}`);return t}const Ii=Ie("lamportsPerSignature"),Ri=U([z("version"),z("state"),Y("authorizedPubkey"),Y("nonce"),U([Ii],"feeCalculator")]),Lr=Ri.span;class ar{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=Ri.decode(G(e),0);return new ar({authorizedPubkey:new T(t.authorizedPubkey),nonce:new T(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const mu=i=>{const e=i.decode.bind(i),t=i.encode.bind(i);return{decode:e,encode:t}},wu=i=>e=>{const t=ue(i,e),{encode:n,decode:r}=mu(t),s=t;return s.decode=(o,c)=>{const u=r(o,c);return Ea(D.Buffer.from(u))},s.encode=(o,c,u)=>{const d=Ys(o,i);return n(d,c,u)},s},Jt=wu(8);class ku{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=z("instruction").decode(e.data);let r;for(const[s,o]of Object.entries(ae))if(o.index==n){r=s;break}if(!r)throw new Error("Instruction type incorrect; not a SystemInstruction");return r}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:n,programId:r}=re(ae.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:n,programId:new T(r)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=re(ae.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:n,programId:r}=re(ae.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:n,programId:new T(r)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=re(ae.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,space:r,programId:s}=re(ae.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new T(t),seed:n,space:r,programId:new T(s)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=re(ae.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new T(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,programId:r}=re(ae.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new T(t),seed:n,programId:new T(r)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:n,lamports:r,space:s,programId:o}=re(ae.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new T(t),seed:n,lamports:r,space:s,programId:new T(o)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=re(ae.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new T(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),re(ae.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=re(ae.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=re(ae.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new T(t)}}static checkProgramId(e){if(!e.equals(Se.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const ae=Object.freeze({Create:{index:0,layout:U([z("instruction"),Fe("lamports"),Fe("space"),Y("programId")])},Assign:{index:1,layout:U([z("instruction"),Y("programId")])},Transfer:{index:2,layout:U([z("instruction"),Jt("lamports")])},CreateWithSeed:{index:3,layout:U([z("instruction"),Y("base"),Pt("seed"),Fe("lamports"),Fe("space"),Y("programId")])},AdvanceNonceAccount:{index:4,layout:U([z("instruction")])},WithdrawNonceAccount:{index:5,layout:U([z("instruction"),Fe("lamports")])},InitializeNonceAccount:{index:6,layout:U([z("instruction"),Y("authorized")])},AuthorizeNonceAccount:{index:7,layout:U([z("instruction"),Y("authorized")])},Allocate:{index:8,layout:U([z("instruction"),Fe("space")])},AllocateWithSeed:{index:9,layout:U([z("instruction"),Y("base"),Pt("seed"),Fe("space"),Y("programId")])},AssignWithSeed:{index:10,layout:U([z("instruction"),Y("base"),Pt("seed"),Y("programId")])},TransferWithSeed:{index:11,layout:U([z("instruction"),Jt("lamports"),Pt("seed"),Y("programId")])},UpgradeNonceAccount:{index:12,layout:U([z("instruction")])}});class Se{constructor(){}static createAccount(e){const t=ae.Create,n=Q(t,{lamports:e.lamports,space:e.space,programId:G(e.programId.toBuffer())});return new oe({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){const r=ae.TransferWithSeed;t=Q(r,{lamports:BigInt(e.lamports),seed:e.seed,programId:G(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const r=ae.Transfer;t=Q(r,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new oe({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){const r=ae.AssignWithSeed;t=Q(r,{base:G(e.basePubkey.toBuffer()),seed:e.seed,programId:G(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=ae.Assign;t=Q(r,{programId:G(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new oe({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=ae.CreateWithSeed,n=Q(t,{base:G(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:G(e.programId.toBuffer())});let r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey!=e.fromPubkey&&r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new oe({keys:r,programId:this.programId,data:n})}static createNonceAccount(e){const t=new se;"basePubkey"in e&&"seed"in e?t.add(Se.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Lr,programId:this.programId})):t.add(Se.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Lr,programId:this.programId}));const n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){const t=ae.InitializeNonceAccount,n=Q(t,{authorized:G(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:qn,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new oe(r)}static nonceAdvance(e){const t=ae.AdvanceNonceAccount,n=Q(t),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:qn,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new oe(r)}static nonceWithdraw(e){const t=ae.WithdrawNonceAccount,n=Q(t,{lamports:e.lamports});return new oe({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:qn,isSigner:!1,isWritable:!1},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){const t=ae.AuthorizeNonceAccount,n=Q(t,{authorized:G(e.newAuthorizedPubkey.toBuffer())});return new oe({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){const r=ae.AllocateWithSeed;t=Q(r,{base:G(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:G(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=ae.Allocate;t=Q(r,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new oe({keys:n,programId:this.programId,data:t})}}Se.programId=new T("11111111111111111111111111111111");const _u=wt-300;class Ct{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Ct.chunkSize)+1+1)}static async load(e,t,n,r,s){{const m=await e.getMinimumBalanceForRentExemption(s.length),_=await e.getAccountInfo(n.publicKey,"confirmed");let f=null;if(_!==null){if(_.executable)return console.error("Program load failed, account is already executable"),!1;_.data.length!==s.length&&(f=f||new se,f.add(Se.allocate({accountPubkey:n.publicKey,space:s.length}))),_.owner.equals(r)||(f=f||new se,f.add(Se.assign({accountPubkey:n.publicKey,programId:r}))),_.lamports<m&&(f=f||new se,f.add(Se.transfer({fromPubkey:t.publicKey,toPubkey:n.publicKey,lamports:m-_.lamports})))}else f=new se().add(Se.createAccount({fromPubkey:t.publicKey,newAccountPubkey:n.publicKey,lamports:m>0?m:1,space:s.length,programId:r}));f!==null&&await Nr(e,f,[t,n],{commitment:"confirmed"})}const o=U([z("instruction"),z("offset"),z("bytesLength"),z("bytesLengthPadding"),Re(ne("byte"),Bt(z(),-8),"bytes")]),c=Ct.chunkSize;let u=0,d=s,g=[];for(;d.length>0;){const m=d.slice(0,c),_=D.Buffer.alloc(c+16);o.encode({instruction:0,offset:u,bytes:m,bytesLength:0,bytesLengthPadding:0},_);const f=new se().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0}],programId:r,data:_});g.push(Nr(e,f,[t,n],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await Et(1e3/4),u+=c,d=d.slice(c)}await Promise.all(g);{const m=U([z("instruction")]),_=D.Buffer.alloc(m.span);m.encode({instruction:1},_);const f=new se().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0},{pubkey:jt,isSigner:!1,isWritable:!1}],programId:r,data:_}),b="processed",w=await e.sendTransaction(f,[t,n],{preflightCommitment:b}),{context:A,value:h}=await e.confirmTransaction({signature:w,lastValidBlockHeight:f.lastValidBlockHeight,blockhash:f.recentBlockhash},b);if(h.err)throw new Error(`Transaction ${w} failed (${JSON.stringify(h)})`);for(;;){try{if(await e.getSlot({commitment:b})>A.slot)break}catch{}await new Promise(k=>setTimeout(k,Math.round(Ai/2)))}}return!0}}Ct.chunkSize=_u;const Su=new T("BPFLoader2111111111111111111111111111111111");class Au{static getMinNumSignatures(e){return Ct.getMinNumSignatures(e)}static load(e,t,n,r,s){return Ct.load(e,t,n,s,r)}}function Iu(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var Ru=Object.prototype.toString,vu=Object.keys||function(i){var e=[];for(var t in i)e.push(t);return e};function ln(i,e){var t,n,r,s,o,c,u;if(i===!0)return"true";if(i===!1)return"false";switch(typeof i){case"object":if(i===null)return null;if(i.toJSON&&typeof i.toJSON=="function")return ln(i.toJSON(),e);if(u=Ru.call(i),u==="[object Array]"){for(r="[",n=i.length-1,t=0;t<n;t++)r+=ln(i[t],!0)+",";return n>-1&&(r+=ln(i[t],!0)),r+"]"}else if(u==="[object Object]"){for(s=vu(i).sort(),n=s.length,r="",t=0;t<n;)o=s[t],c=ln(i[o],!1),c!==void 0&&(r&&(r+=","),r+=JSON.stringify(o)+":"+c),t++;return"{"+r+"}"}else return JSON.stringify(i);case"function":case"undefined":return e?null:void 0;case"string":return JSON.stringify(i);default:return isFinite(i)?i:null}}var Tu=function(i){var e=ln(i,!1);if(e!==void 0)return""+e},Ls=Iu(Tu);const un=32;function Ir(i){let e=0;for(;i>1;)i/=2,e++;return e}function Eu(i){return i===0?1:(i--,i|=i>>1,i|=i>>2,i|=i>>4,i|=i>>8,i|=i>>16,i|=i>>32,i+1)}class vi{constructor(e,t,n,r,s){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=r,this.firstNormalSlot=s}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Ir(Eu(e+un+1))-Ir(un)-1,n=this.getSlotsInEpoch(t),r=e-(n-un);return[t,r]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),r=this.firstNormalEpoch+n,s=t%this.slotsPerEpoch;return[r,s]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*un:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Ir(un)):this.slotsPerEpoch}}class Kr extends Error{constructor(e,t){super(e),this.logs=void 0,this.logs=t}}const Pu={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class W extends Error{constructor({code:e,message:t,data:n},r){super(r!=null?`${r}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}var Bu=globalThis.fetch;class Ou extends Pa{constructor(e,t,n){const r=s=>{const o=Ca(s,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in o?this.underlyingSocket=o.socket:this.underlyingSocket=o,o};super(r,e,t,n),this.underlyingSocket=void 0}call(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function Cu(i,e){let t;try{t=i.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==i.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${i.index}`);return t}const Ks=56;class xr{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=Cu(Nu,e),n=e.length-Ks;te(n>=0,"lookup table is invalid"),te(n%32===0,"lookup table is invalid");const r=n/32,{addresses:s}=U([Re(Y(),r,"addresses")]).decode(e.slice(Ks));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new T(t.authority[0]):void 0,addresses:s.map(o=>new T(o))}}}const Nu={index:1,layout:U([z("typeIndex"),Jt("deactivationSlot"),Ie("lastExtendedSlot"),ne("lastExtendedStartIndex"),ne(),Re(Y(),Bt(ne(),-1),"authority")])},Lu=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Ku(i){const e=i.match(Lu);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${i}\``);const[t,n,r,s]=e,o=i.startsWith("https:")?"wss:":"ws:",c=r==null?null:parseInt(r.slice(1),10),u=c==null?"":`:${c+1}`;return`${o}//${n}${u}${s}`}const ye=bn(Dr(T),v(),i=>new T(i)),Ti=$r([v(),le("base64")]),es=bn(Dr(D.Buffer),Ti,i=>D.Buffer.from(i[0],"base64")),Ei=30*1e3;function xu(i){if(/^https?:/.test(i)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return i}function ce(i){let e,t;if(typeof i=="string")e=i;else if(i){const{commitment:n,...r}=i;e=n,t=r}return{commitment:e,config:t}}function Pi(i){return Le([R({jsonrpc:le("2.0"),id:v(),result:i}),R({jsonrpc:le("2.0"),id:v(),error:R({code:mn(),message:v(),data:$(Ta())})})])}const Uu=Pi(mn());function V(i){return bn(Pi(i),Uu,e=>"error"in e?e:{...e,result:E(e.result,i)})}function de(i){return V(R({context:R({slot:y()}),value:i}))}function cr(i){return R({context:R({slot:y()}),value:i})}function Rr(i,e){return i===0?new Ot({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new T(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:ge.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new Ge(e)}const zu=R({foundation:y(),foundationTerm:y(),initial:y(),taper:y(),terminal:y()}),Wu=V(O(B(R({epoch:y(),effectiveSlot:y(),amount:y(),postBalance:y(),commission:$(B(y()))})))),Mu=O(R({slot:y(),prioritizationFee:y()})),Du=R({total:y(),validator:y(),foundation:y(),epoch:y()}),$u=R({epoch:y(),slotIndex:y(),slotsInEpoch:y(),absoluteSlot:y(),blockHeight:$(y()),transactionCount:$(y())}),Fu=R({slotsPerEpoch:y(),leaderScheduleSlotOffset:y(),warmup:Xe(),firstNormalEpoch:y(),firstNormalSlot:y()}),Hu=qs(v(),O(y())),Nt=B(Le([R({}),v()])),Vu=R({err:Nt}),Gu=le("receivedSignature"),qu=R({"solana-core":v(),"feature-set":$(y())}),xs=de(R({err:B(Le([R({}),v()])),logs:B(O(v())),accounts:$(B(O(B(R({executable:Xe(),owner:v(),lamports:y(),data:O(v()),rentEpoch:$(y())}))))),unitsConsumed:$(y()),returnData:$(B(R({programId:v(),data:$r([v(),le("base64")])})))})),Yu=de(R({byIdentity:qs(v(),O(y())),range:R({firstSlot:y(),lastSlot:y()})}));function ju(i,e,t,n,r,s){const o=t||Bu;let c;s!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let u;return n&&(u=async(g,m)=>{const _=await new Promise((f,b)=>{try{n(g,m,(w,A)=>f([w,A]))}catch(w){b(w)}});return await o(..._)}),new Ba(async(g,m)=>{const _={method:"POST",body:g,agent:c,headers:Object.assign({"Content-Type":"application/json"},e||{},Jl)};try{let f=5,b,w=500;for(;u?b=await u(i,_):b=await o(i,_),!(b.status!==429||r===!0||(f-=1,f===0));)console.log(`Server responded with ${b.status} ${b.statusText}.  Retrying after ${w}ms delay...`),await Et(w),w*=2;const A=await b.text();b.ok?m(null,A):m(new Error(`${b.status} ${b.statusText}: ${A}`))}catch(f){f instanceof Error&&m(f)}},{})}function Ju(i){return(e,t)=>new Promise((n,r)=>{i.request(e,t,(s,o)=>{if(s){r(s);return}n(o)})})}function Xu(i){return e=>new Promise((t,n)=>{e.length===0&&t([]);const r=e.map(s=>i.request(s.methodName,s.args));i.request(r,(s,o)=>{if(s){n(s);return}t(o)})})}const Zu=V(zu),Qu=V(Du),el=V(Mu),tl=V($u),nl=V(Fu),rl=V(Hu),sl=V(y()),il=de(R({total:y(),circulating:y(),nonCirculating:y(),nonCirculatingAccounts:O(ye)})),Ur=R({amount:v(),uiAmount:B(y()),decimals:y(),uiAmountString:$(v())}),ol=de(O(R({address:ye,amount:v(),uiAmount:B(y()),decimals:y(),uiAmountString:$(v())}))),al=de(O(R({pubkey:ye,account:R({executable:Xe(),owner:ye,lamports:y(),data:es,rentEpoch:y()})}))),zr=R({program:v(),parsed:mn(),space:y()}),cl=de(O(R({pubkey:ye,account:R({executable:Xe(),owner:ye,lamports:y(),data:zr,rentEpoch:y()})}))),ul=de(O(R({lamports:y(),address:ye}))),pn=R({executable:Xe(),owner:ye,lamports:y(),data:es,rentEpoch:y()}),ll=R({pubkey:ye,account:pn}),dl=bn(Le([Dr(D.Buffer),zr]),Le([Ti,zr]),i=>Array.isArray(i)?E(i,es):i),Wr=R({executable:Xe(),owner:ye,lamports:y(),data:dl,rentEpoch:y()}),fl=R({pubkey:ye,account:Wr}),hl=R({state:Le([le("active"),le("inactive"),le("activating"),le("deactivating")]),active:y(),inactive:y()}),gl=V(O(R({signature:v(),slot:y(),err:Nt,memo:B(v()),blockTime:$(B(y()))}))),yl=V(O(R({signature:v(),slot:y(),err:Nt,memo:B(v()),blockTime:$(B(y()))}))),pl=R({subscription:y(),result:cr(pn)}),bl=R({pubkey:ye,account:pn}),ml=R({subscription:y(),result:cr(bl)}),wl=R({parent:y(),slot:y(),root:y()}),kl=R({subscription:y(),result:wl}),_l=Le([R({type:Le([le("firstShredReceived"),le("completed"),le("optimisticConfirmation"),le("root")]),slot:y(),timestamp:y()}),R({type:le("createdBank"),parent:y(),slot:y(),timestamp:y()}),R({type:le("frozen"),slot:y(),timestamp:y(),stats:R({numTransactionEntries:y(),numSuccessfulTransactions:y(),numFailedTransactions:y(),maxTransactionsPerEntry:y()})}),R({type:le("dead"),slot:y(),timestamp:y(),err:v()})]),Sl=R({subscription:y(),result:_l}),Al=R({subscription:y(),result:cr(Le([Vu,Gu]))}),Il=R({subscription:y(),result:y()}),Rl=R({pubkey:v(),gossip:B(v()),tpu:B(v()),rpc:B(v()),version:B(v())}),Us=R({votePubkey:v(),nodePubkey:v(),activatedStake:y(),epochVoteAccount:Xe(),epochCredits:O($r([y(),y(),y()])),commission:y(),lastVote:y(),rootSlot:B(y())}),vl=V(R({current:O(Us),delinquent:O(Us)})),Tl=Le([le("processed"),le("confirmed"),le("finalized")]),El=R({slot:y(),confirmations:B(y()),err:Nt,confirmationStatus:$(Tl)}),Pl=de(O(B(El))),Bl=V(y()),Bi=R({accountKey:ye,writableIndexes:O(y()),readonlyIndexes:O(y())}),ts=R({signatures:O(v()),message:R({accountKeys:O(v()),header:R({numRequiredSignatures:y(),numReadonlySignedAccounts:y(),numReadonlyUnsignedAccounts:y()}),instructions:O(R({accounts:O(y()),data:v(),programIdIndex:y()})),recentBlockhash:v(),addressTableLookups:$(O(Bi))})}),Oi=R({pubkey:ye,signer:Xe(),writable:Xe(),source:$(Le([le("transaction"),le("lookupTable")]))}),Ci=R({accountKeys:O(Oi),signatures:O(v())}),Ni=R({parsed:mn(),program:v(),programId:ye}),Li=R({accounts:O(ye),data:v(),programId:ye}),Ol=Le([Li,Ni]),Cl=Le([R({parsed:mn(),program:v(),programId:v()}),R({accounts:O(v()),data:v(),programId:v()})]),Ki=bn(Ol,Cl,i=>"accounts"in i?E(i,Li):E(i,Ni)),xi=R({signatures:O(v()),message:R({accountKeys:O(Oi),instructions:O(Ki),recentBlockhash:v(),addressTableLookups:$(B(O(Bi)))})}),Xn=R({accountIndex:y(),mint:v(),owner:$(v()),uiTokenAmount:Ur}),Ui=R({writable:O(ye),readonly:O(ye)}),ur=R({err:Nt,fee:y(),innerInstructions:$(B(O(R({index:y(),instructions:O(R({accounts:O(y()),data:v(),programIdIndex:y()}))})))),preBalances:O(y()),postBalances:O(y()),logMessages:$(B(O(v()))),preTokenBalances:$(B(O(Xn))),postTokenBalances:$(B(O(Xn))),loadedAddresses:$(Ui),computeUnitsConsumed:$(y())}),ns=R({err:Nt,fee:y(),innerInstructions:$(B(O(R({index:y(),instructions:O(Ki)})))),preBalances:O(y()),postBalances:O(y()),logMessages:$(B(O(v()))),preTokenBalances:$(B(O(Xn))),postTokenBalances:$(B(O(Xn))),loadedAddresses:$(Ui),computeUnitsConsumed:$(y())}),en=Le([le(0),le("legacy")]),Lt=R({pubkey:v(),lamports:y(),postBalance:B(y()),rewardType:B(v()),commission:$(B(y()))}),Nl=V(B(R({blockhash:v(),previousBlockhash:v(),parentSlot:y(),transactions:O(R({transaction:ts,meta:B(ur),version:$(en)})),rewards:$(O(Lt)),blockTime:B(y()),blockHeight:B(y())}))),Ll=V(B(R({blockhash:v(),previousBlockhash:v(),parentSlot:y(),rewards:$(O(Lt)),blockTime:B(y()),blockHeight:B(y())}))),Kl=V(B(R({blockhash:v(),previousBlockhash:v(),parentSlot:y(),transactions:O(R({transaction:Ci,meta:B(ur),version:$(en)})),rewards:$(O(Lt)),blockTime:B(y()),blockHeight:B(y())}))),xl=V(B(R({blockhash:v(),previousBlockhash:v(),parentSlot:y(),transactions:O(R({transaction:xi,meta:B(ns),version:$(en)})),rewards:$(O(Lt)),blockTime:B(y()),blockHeight:B(y())}))),Ul=V(B(R({blockhash:v(),previousBlockhash:v(),parentSlot:y(),transactions:O(R({transaction:Ci,meta:B(ns),version:$(en)})),rewards:$(O(Lt)),blockTime:B(y()),blockHeight:B(y())}))),zl=V(B(R({blockhash:v(),previousBlockhash:v(),parentSlot:y(),rewards:$(O(Lt)),blockTime:B(y()),blockHeight:B(y())}))),Wl=V(B(R({blockhash:v(),previousBlockhash:v(),parentSlot:y(),transactions:O(R({transaction:ts,meta:B(ur)})),rewards:$(O(Lt)),blockTime:B(y())}))),zs=V(B(R({blockhash:v(),previousBlockhash:v(),parentSlot:y(),signatures:O(v()),blockTime:B(y())}))),vr=V(B(R({slot:y(),meta:B(ur),blockTime:$(B(y())),transaction:ts,version:$(en)}))),Gn=V(B(R({slot:y(),transaction:xi,meta:B(ns),blockTime:$(B(y())),version:$(en)}))),Ml=de(R({blockhash:v(),feeCalculator:R({lamportsPerSignature:y()})})),Dl=de(R({blockhash:v(),lastValidBlockHeight:y()})),$l=de(Xe()),Fl=R({slot:y(),numTransactions:y(),numSlots:y(),samplePeriodSecs:y()}),Hl=V(O(Fl)),Vl=de(B(R({feeCalculator:R({lamportsPerSignature:y()})}))),Gl=V(v()),ql=V(v()),Yl=R({err:Nt,logs:O(v()),signature:v()}),jl=R({result:cr(Yl),subscription:y()}),Jl={"solana-client":"js/0.0.0-development"};class Xl{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const d={};return async g=>{const{commitment:m,config:_}=ce(g),f=this._buildArgs([],m,void 0,_),b=Ls(f);return d[b]=d[b]??(async()=>{try{const w=await this._rpcRequest("getBlockHeight",f),A=E(w,V(y()));if("error"in A)throw new W(A.error,"failed to get block height information");return A.result}finally{delete d[b]}})(),await d[b]}})();let n,r,s,o,c,u;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,r=t.httpHeaders,s=t.fetch,o=t.fetchMiddleware,c=t.disableRetryOnRateLimit,u=t.httpAgent),this._rpcEndpoint=xu(e),this._rpcWsEndpoint=n||Ku(e),this._rpcClient=ju(e,r,s,o,c,u),this._rpcRequest=Ju(this._rpcClient),this._rpcBatchRequest=Xu(this._rpcClient),this._rpcWebSocket=new Ou(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:r}=ce(t),s=this._buildArgs([e.toBase58()],n,void 0,r),o=await this._rpcRequest("getBalance",s),c=E(o,de(y()));if("error"in c)throw new W(c.error,`failed to get balance for ${e.toBase58()}`);return c.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=E(t,V(B(y())));if("error"in n)throw new W(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=E(e,V(y()));if("error"in t)throw new W(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=E(e,sl);if("error"in t)throw new W(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),r=E(n,il);if("error"in r)throw new W(r.error,"failed to get supply");return r.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenSupply",n),s=E(r,de(Ur));if("error"in s)throw new W(s.error,"failed to get token supply");return s.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenAccountBalance",n),s=E(r,de(Ur));if("error"in s)throw new W(s.error,"failed to get token account balance");return s.result}async getTokenAccountsByOwner(e,t,n){const{commitment:r,config:s}=ce(n);let o=[e.toBase58()];"mint"in t?o.push({mint:t.mint.toBase58()}):o.push({programId:t.programId.toBase58()});const c=this._buildArgs(o,r,"base64",s),u=await this._rpcRequest("getTokenAccountsByOwner",c),d=E(u,al);if("error"in d)throw new W(d.error,`failed to get token accounts owned by account ${e.toBase58()}`);return d.result}async getParsedTokenAccountsByOwner(e,t,n){let r=[e.toBase58()];"mint"in t?r.push({mint:t.mint.toBase58()}):r.push({programId:t.programId.toBase58()});const s=this._buildArgs(r,n,"jsonParsed"),o=await this._rpcRequest("getTokenAccountsByOwner",s),c=E(o,cl);if("error"in c)throw new W(c.error,`failed to get token accounts owned by account ${e.toBase58()}`);return c.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],r=await this._rpcRequest("getLargestAccounts",n),s=E(r,ul);if("error"in s)throw new W(s.error,"failed to get largest accounts");return s.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenLargestAccounts",n),s=E(r,ol);if("error"in s)throw new W(s.error,"failed to get token largest accounts");return s.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:r}=ce(t),s=this._buildArgs([e.toBase58()],n,"base64",r),o=await this._rpcRequest("getAccountInfo",s),c=E(o,de(B(pn)));if("error"in c)throw new W(c.error,`failed to get info about account ${e.toBase58()}`);return c.result}async getParsedAccountInfo(e,t){const{commitment:n,config:r}=ce(t),s=this._buildArgs([e.toBase58()],n,"jsonParsed",r),o=await this._rpcRequest("getAccountInfo",s),c=E(o,de(B(Wr)));if("error"in c)throw new W(c.error,`failed to get info about account ${e.toBase58()}`);return c.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:r}=ce(t),s=e.map(d=>d.toBase58()),o=this._buildArgs([s],n,"jsonParsed",r),c=await this._rpcRequest("getMultipleAccounts",o),u=E(c,de(O(B(Wr))));if("error"in u)throw new W(u.error,`failed to get info for accounts ${s}`);return u.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:r}=ce(t),s=e.map(d=>d.toBase58()),o=this._buildArgs([s],n,"base64",r),c=await this._rpcRequest("getMultipleAccounts",o),u=E(c,de(O(B(pn))));if("error"in u)throw new W(u.error,`failed to get info for accounts ${s}`);return u.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:r,config:s}=ce(t),o=this._buildArgs([e.toBase58()],r,void 0,{...s,epoch:n??(s==null?void 0:s.epoch)}),c=await this._rpcRequest("getStakeActivation",o),u=E(c,V(hl));if("error"in u)throw new W(u.error,`failed to get Stake Activation ${e.toBase58()}`);return u.result}async getProgramAccounts(e,t){const{commitment:n,config:r}=ce(t),{encoding:s,...o}=r||{},c=this._buildArgs([e.toBase58()],n,s||"base64",o),u=await this._rpcRequest("getProgramAccounts",c),d=O(ll),g=o.withContext===!0?E(u,de(d)):E(u,V(d));if("error"in g)throw new W(g.error,`failed to get accounts owned by program ${e.toBase58()}`);return g.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:r}=ce(t),s=this._buildArgs([e.toBase58()],n,"jsonParsed",r),o=await this._rpcRequest("getProgramAccounts",s),c=E(o,V(O(fl)));if("error"in c)throw new W(c.error,`failed to get accounts owned by program ${e.toBase58()}`);return c.result}async confirmTransaction(e,t){var s;let n;if(typeof e=="string")n=e;else{const o=e;if((s=o.abortSignal)!=null&&s.aborted)return Promise.reject(o.abortSignal.reason);n=o.signature}let r;try{r=ge.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return te(r.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,r,s=!1;const o=new Promise((u,d)=>{try{n=this.onSignature(t,(m,_)=>{n=void 0;const f={context:_,value:m};u({__type:dt.PROCESSED,response:f})},e);const g=new Promise(m=>{n==null?m():r=this._onSubscriptionStateChange(n,_=>{_==="subscribed"&&m()})});(async()=>{if(await g,s)return;const m=await this.getSignatureStatus(t);if(s||m==null)return;const{context:_,value:f}=m;if(f!=null)if(f!=null&&f.err)d(f.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(f.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(f.confirmationStatus==="processed"||f.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}s=!0,u({__type:dt.PROCESSED,response:{context:_,value:f}})}})()}catch(g){d(g)}});return{abortConfirmation:()=>{r&&(r(),r=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:o}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:r}}){let s=!1;const o=new Promise(m=>{const _=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let f=await _();if(!s){for(;f<=n;)if(await Et(1e3),s||(f=await _(),s))return;m({__type:dt.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:c,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:e,signature:r}),d=this.getCancellationPromise(t);let g;try{const m=await Promise.race([d,u,o]);if(m.__type===dt.PROCESSED)g=m.response;else throw new jr(r)}finally{s=!0,c()}return g}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:r,nonceValue:s,signature:o}}){let c=!1;const u=new Promise(f=>{let b=s,w=null;const A=async()=>{try{const{context:h,value:k}=await this.getNonceAndContext(r,{commitment:e,minContextSlot:n});return w=h.slot,k==null?void 0:k.nonce}catch{return b}};(async()=>{if(b=await A(),!c)for(;;){if(s!==b){f({__type:dt.NONCE_INVALID,slotInWhichNonceDidAdvance:w});return}if(await Et(2e3),c||(b=await A(),c))return}})()}),{abortConfirmation:d,confirmationPromise:g}=this.getTransactionConfirmationPromise({commitment:e,signature:o}),m=this.getCancellationPromise(t);let _;try{const f=await Promise.race([m,g,u]);if(f.__type===dt.PROCESSED)_=f.response;else{let b;for(;;){const w=await this.getSignatureStatus(o);if(w==null)break;if(w.context.slot<(f.slotInWhichNonceDidAdvance??n)){await Et(400);continue}b=w;break}if(b!=null&&b.value){const w=e||"finalized",{confirmationStatus:A}=b.value;switch(w){case"processed":case"recent":if(A!=="processed"&&A!=="confirmed"&&A!=="finalized")throw new Ft(o);break;case"confirmed":case"single":case"singleGossip":if(A!=="confirmed"&&A!=="finalized")throw new Ft(o);break;case"finalized":case"max":case"root":if(A!=="finalized")throw new Ft(o);break;default:(h=>{})(w)}_={context:b.context,value:{err:b.value.err}}}else throw new Ft(o)}}finally{c=!0,d()}return _}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const r=new Promise(u=>{let d=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{d=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>u({__type:dt.TIMED_OUT,timeoutMs:d}),d)}),{abortConfirmation:s,confirmationPromise:o}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let c;try{const u=await Promise.race([o,r]);if(u.__type===dt.PROCESSED)c=u.response;else throw new Jr(t,u.timeoutMs/1e3)}finally{clearTimeout(n),s()}return c}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=E(e,V(O(Rl)));if("error"in t)throw new W(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),r=E(n,vl);if("error"in r)throw new W(r.error,"failed to get vote accounts");return r.result}async getSlot(e){const{commitment:t,config:n}=ce(e),r=this._buildArgs([],t,void 0,n),s=await this._rpcRequest("getSlot",r),o=E(s,V(y()));if("error"in o)throw new W(o.error,"failed to get slot");return o.result}async getSlotLeader(e){const{commitment:t,config:n}=ce(e),r=this._buildArgs([],t,void 0,n),s=await this._rpcRequest("getSlotLeader",r),o=E(s,V(v()));if("error"in o)throw new W(o.error,"failed to get slot leader");return o.result}async getSlotLeaders(e,t){const n=[e,t],r=await this._rpcRequest("getSlotLeaders",n),s=E(r,V(O(ye)));if("error"in s)throw new W(s.error,"failed to get slot leaders");return s.result}async getSignatureStatus(e,t){const{context:n,value:r}=await this.getSignatureStatuses([e],t);te(r.length===1);const s=r[0];return{context:n,value:s}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const r=await this._rpcRequest("getSignatureStatuses",n),s=E(r,Pl);if("error"in s)throw new W(s.error,"failed to get signature status");return s.result}async getTransactionCount(e){const{commitment:t,config:n}=ce(e),r=this._buildArgs([],t,void 0,n),s=await this._rpcRequest("getTransactionCount",r),o=E(s,V(y()));if("error"in o)throw new W(o.error,"failed to get transaction count");return o.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),r=E(n,Zu);if("error"in r)throw new W(r.error,"failed to get inflation");return r.result}async getInflationReward(e,t,n){const{commitment:r,config:s}=ce(n),o=this._buildArgs([e.map(d=>d.toBase58())],r,void 0,{...s,epoch:t??(s==null?void 0:s.epoch)}),c=await this._rpcRequest("getInflationReward",o),u=E(c,Wu);if("error"in u)throw new W(u.error,"failed to get inflation reward");return u.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=E(e,Qu);if("error"in t)throw new W(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=ce(e),r=this._buildArgs([],t,void 0,n),s=await this._rpcRequest("getEpochInfo",r),o=E(s,tl);if("error"in o)throw new W(o.error,"failed to get epoch info");return o.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=E(e,nl);if("error"in t)throw new W(t.error,"failed to get epoch schedule");const n=t.result;return new vi(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=E(e,rl);if("error"in t)throw new W(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),r=await this._rpcRequest("getMinimumBalanceForRentExemption",n),s=E(r,Bl);return"error"in s?(console.warn("Unable to fetch minimum balance for rent exemption"),0):s.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),r=E(n,Ml);if("error"in r)throw new W(r.error,"failed to get recent blockhash");return r.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=E(t,Hl);if("error"in n)throw new W(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),r=await this._rpcRequest("getFeeCalculatorForBlockhash",n),s=E(r,Vl);if("error"in s)throw new W(s.error,"failed to get fee calculator");const{context:o,value:c}=s.result;return{context:o,value:c!==null?c.feeCalculator:null}}async getFeeForMessage(e,t){const n=G(e.serialize()).toString("base64"),r=this._buildArgs([n],t),s=await this._rpcRequest("getFeeForMessage",r),o=E(s,de(B(y())));if("error"in o)throw new W(o.error,"failed to get fee for message");if(o.result===null)throw new Error("invalid blockhash");return o.result}async getRecentPrioritizationFees(e){var o;const t=(o=e==null?void 0:e.lockedWritableAccounts)==null?void 0:o.map(c=>c.toBase58()),n=t!=null&&t.length?[t]:[],r=await this._rpcRequest("getRecentPrioritizationFees",n),s=E(r,el);if("error"in s)throw new W(s.error,"failed to get recent prioritization fees");return s.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=ce(e),r=this._buildArgs([],t,void 0,n),s=await this._rpcRequest("getLatestBlockhash",r),o=E(s,Dl);if("error"in o)throw new W(o.error,"failed to get latest blockhash");return o.result}async isBlockhashValid(e,t){const{commitment:n,config:r}=ce(t),s=this._buildArgs([e],n,void 0,r),o=await this._rpcRequest("isBlockhashValid",s),c=E(o,$l);if("error"in c)throw new W(c.error,"failed to determine if the blockhash `"+e+"`is valid");return c.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=E(e,V(qu));if("error"in t)throw new W(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=E(e,V(v()));if("error"in t)throw new W(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:r}=ce(t),s=this._buildArgsAtLeastConfirmed([e],n,void 0,r),o=await this._rpcRequest("getBlock",s);try{switch(r==null?void 0:r.transactionDetails){case"accounts":{const c=E(o,Kl);if("error"in c)throw c.error;return c.result}case"none":{const c=E(o,Ll);if("error"in c)throw c.error;return c.result}default:{const c=E(o,Nl);if("error"in c)throw c.error;const{result:u}=c;return u?{...u,transactions:u.transactions.map(({transaction:d,meta:g,version:m})=>({meta:g,transaction:{...d,message:Rr(m,d.message)},version:m}))}:null}}}catch(c){throw new W(c,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:r}=ce(t),s=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),o=await this._rpcRequest("getBlock",s);try{switch(r==null?void 0:r.transactionDetails){case"accounts":{const c=E(o,Ul);if("error"in c)throw c.error;return c.result}case"none":{const c=E(o,zl);if("error"in c)throw c.error;return c.result}default:{const c=E(o,xl);if("error"in c)throw c.error;return c.result}}}catch(c){throw new W(c,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:c,...u}=e;n=c,t=u}const r=this._buildArgs([],n,"base64",t),s=await this._rpcRequest("getBlockProduction",r),o=E(s,Yu);if("error"in o)throw new W(o.error,"failed to get block production information");return o.result}async getTransaction(e,t){const{commitment:n,config:r}=ce(t),s=this._buildArgsAtLeastConfirmed([e],n,void 0,r),o=await this._rpcRequest("getTransaction",s),c=E(o,vr);if("error"in c)throw new W(c.error,"failed to get transaction");const u=c.result;return u&&{...u,transaction:{...u.transaction,message:Rr(u.version,u.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:r}=ce(t),s=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),o=await this._rpcRequest("getTransaction",s),c=E(o,Gn);if("error"in c)throw new W(c.error,"failed to get transaction");return c.result}async getParsedTransactions(e,t){const{commitment:n,config:r}=ce(t),s=e.map(u=>{const d=this._buildArgsAtLeastConfirmed([u],n,"jsonParsed",r);return{methodName:"getTransaction",args:d}});return(await this._rpcBatchRequest(s)).map(u=>{const d=E(u,Gn);if("error"in d)throw new W(d.error,"failed to get transactions");return d.result})}async getTransactions(e,t){const{commitment:n,config:r}=ce(t),s=e.map(u=>{const d=this._buildArgsAtLeastConfirmed([u],n,void 0,r);return{methodName:"getTransaction",args:d}});return(await this._rpcBatchRequest(s)).map(u=>{const d=E(u,vr);if("error"in d)throw new W(d.error,"failed to get transactions");const g=d.result;return g&&{...g,transaction:{...g.transaction,message:Rr(g.version,g.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getConfirmedBlock",n),s=E(r,Wl);if("error"in s)throw new W(s.error,"failed to get confirmed block");const o=s.result;if(!o)throw new Error("Confirmed block "+e+" not found");const c={...o,transactions:o.transactions.map(({transaction:u,meta:d})=>{const g=new Ge(u.message);return{meta:d,transaction:{...u,message:g}}})};return{...c,transactions:c.transactions.map(({transaction:u,meta:d})=>({meta:d,transaction:se.populate(u.message,u.signatures)}))}}async getBlocks(e,t,n){const r=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),s=await this._rpcRequest("getBlocks",r),o=E(s,V(O(y())));if("error"in o)throw new W(o.error,"failed to get blocks");return o.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getBlock",n),s=E(r,zs);if("error"in s)throw new W(s.error,"failed to get block");const o=s.result;if(!o)throw new Error("Block "+e+" not found");return o}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getConfirmedBlock",n),s=E(r,zs);if("error"in s)throw new W(s.error,"failed to get confirmed block");const o=s.result;if(!o)throw new Error("Confirmed block "+e+" not found");return o}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getConfirmedTransaction",n),s=E(r,vr);if("error"in s)throw new W(s.error,"failed to get transaction");const o=s.result;if(!o)return o;const c=new Ge(o.transaction.message),u=o.transaction.signatures;return{...o,transaction:se.populate(c,u)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),r=await this._rpcRequest("getConfirmedTransaction",n),s=E(r,Gn);if("error"in s)throw new W(s.error,"failed to get confirmed transaction");return s.result}async getParsedConfirmedTransactions(e,t){const n=e.map(o=>{const c=this._buildArgsAtLeastConfirmed([o],t,"jsonParsed");return{methodName:"getConfirmedTransaction",args:c}});return(await this._rpcBatchRequest(n)).map(o=>{const c=E(o,Gn);if("error"in c)throw new W(c.error,"failed to get confirmed transactions");return c.result})}async getConfirmedSignaturesForAddress(e,t,n){let r={},s=await this.getFirstAvailableBlock();for(;!("until"in r)&&(t--,!(t<=0||t<s));)try{const u=await this.getConfirmedBlockSignatures(t,"finalized");u.signatures.length>0&&(r.until=u.signatures[u.signatures.length-1].toString())}catch(u){if(u instanceof Error&&u.message.includes("skipped"))continue;throw u}let o=await this.getSlot("finalized");for(;!("before"in r)&&(n++,!(n>o));)try{const u=await this.getConfirmedBlockSignatures(n);u.signatures.length>0&&(r.before=u.signatures[u.signatures.length-1].toString())}catch(u){if(u instanceof Error&&u.message.includes("skipped"))continue;throw u}return(await this.getConfirmedSignaturesForAddress2(e,r)).map(u=>u.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),s=await this._rpcRequest("getConfirmedSignaturesForAddress2",r),o=E(s,gl);if("error"in o)throw new W(o.error,"failed to get confirmed signatures for address");return o.result}async getSignaturesForAddress(e,t,n){const r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),s=await this._rpcRequest("getSignaturesForAddress",r),o=E(s,yl);if("error"in o)throw new W(o.error,"failed to get signatures for address");return o.result}async getAddressLookupTable(e,t){const{context:n,value:r}=await this.getAccountInfoAndContext(e,t);let s=null;return r!==null&&(s=new xr({key:e,state:xr.deserialize(r.data)})),{context:n,value:s}}async getNonceAndContext(e,t){const{context:n,value:r}=await this.getAccountInfoAndContext(e,t);let s=null;return r!==null&&(s=ar.fromAccountData(r.data)),{context:n,value:s}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),r=E(n,Gl);if("error"in r)throw new W(r.error,`airdrop to ${e.toBase58()} failed`);return r.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await Et(100);const n=Date.now()-this._blockhashInfo.lastFetch>=Ei;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let r=0;r<50;r++){const s=await this.getLatestBlockhash("finalized");if(n!==s.blockhash)return this._blockhashInfo={latestBlockhash:s,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},s;await Et(Ai/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=ce(e),r=this._buildArgs([],t,"base64",n),s=await this._rpcRequest("getStakeMinimumDelegation",r),o=E(s,de(y()));if("error"in o)throw new W(o.error,"failed to get stake minimum delegation");return o.result}async simulateTransaction(e,t,n){if("message"in e){const w=e.serialize(),A=D.Buffer.from(w).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const h=t||{};h.encoding="base64","commitment"in h||(h.commitment=this.commitment);const k=[A,h],S=await this._rpcRequest("simulateTransaction",k),C=E(S,xs);if("error"in C)throw new Error("failed to simulate transaction: "+C.error.message);return C.result}let r;if(e instanceof se){let b=e;r=new se,r.feePayer=b.feePayer,r.instructions=e.instructions,r.nonceInfo=b.nonceInfo,r.signatures=b.signatures}else r=se.populate(e),r._message=r._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(r.nonceInfo&&s)r.sign(...s);else{let b=this._disableBlockhashCaching;for(;;){const w=await this._blockhashWithExpiryBlockHeight(b);if(r.lastValidBlockHeight=w.lastValidBlockHeight,r.recentBlockhash=w.blockhash,!s)break;if(r.sign(...s),!r.signature)throw new Error("!signature");const A=r.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(A)&&!this._blockhashInfo.transactionSignatures.includes(A)){this._blockhashInfo.simulatedSignatures.push(A);break}else b=!0}}const o=r._compile(),c=o.serialize(),d=r._serialize(c).toString("base64"),g={encoding:"base64",commitment:this.commitment};if(n){const b=(Array.isArray(n)?n:o.nonProgramIds()).map(w=>w.toBase58());g.accounts={encoding:"base64",addresses:b}}s&&(g.sigVerify=!0);const m=[d,g],_=await this._rpcRequest("simulateTransaction",m),f=E(_,xs);if("error"in f){let b;if("data"in f.error&&(b=f.error.data.logs,b&&Array.isArray(b))){const w=`
    `,A=w+b.join(w);console.error(f.error.message,A)}throw new Kr("failed to simulate transaction: "+f.error.message,b)}return f.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const o=e.serialize();return await this.sendRawTransaction(o,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const r=t;if(e.nonceInfo)e.sign(...r);else{let o=this._disableBlockhashCaching;for(;;){const c=await this._blockhashWithExpiryBlockHeight(o);if(e.lastValidBlockHeight=c.lastValidBlockHeight,e.recentBlockhash=c.blockhash,e.sign(...r),!e.signature)throw new Error("!signature");const u=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(u))o=!0;else{this._blockhashInfo.transactionSignatures.push(u);break}}}const s=e.serialize();return await this.sendRawTransaction(s,n)}async sendRawTransaction(e,t){const n=G(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},r=t&&t.skipPreflight,s=t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),r&&(n.skipPreflight=r),s&&(n.preflightCommitment=s);const o=[e,n],c=await this._rpcRequest("sendTransaction",o),u=E(c,ql);if("error"in u){let d;throw"data"in u.error&&(d=u.error.data.logs),new Kr("failed to send transaction: "+u.error.message,d)}return u.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){var r;const n=(r=this._subscriptionsByHash[e])==null?void 0:r.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const s=this._subscriptionStateChangeCallbacksByHash[e];s&&s.forEach(o=>{try{o(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const r=this._subscriptionStateChangeCallbacksByHash[n]||=new Set;return r.add(t),()=>{r.delete(t),r.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const r=this._subscriptionsByHash[n];if(r!==void 0)switch(r.state){case"pending":case"unsubscribed":if(r.callbacks.size===0){delete this._subscriptionsByHash[n],r.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:s,method:o}=r;try{this._setSubscription(n,{...r,state:"subscribing"});const c=await this._rpcWebSocket.call(o,s);this._setSubscription(n,{...r,serverSubscriptionId:c,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[c]=r.callbacks,await this._updateSubscriptions()}catch(c){if(c instanceof Error&&console.error(`${o} error for argument`,s,c.message),!t())return;this._setSubscription(n,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":r.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:s,unsubscribeMethod:o}=r;if(this._subscriptionsAutoDisposedByRpc.has(s))this._subscriptionsAutoDisposedByRpc.delete(s);else{this._setSubscription(n,{...r,state:"unsubscribing"}),this._setSubscription(n,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(o,[s])}catch(c){if(c instanceof Error&&console.error(`${o} error:`,c.message),!t())return;this._setSubscription(n,{...r,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(r=>{try{r(...t)}catch(s){console.error(s)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=E(e,pl);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,r=Ls([e.method,t],!0),s=this._subscriptionsByHash[r];return s===void 0?this._subscriptionsByHash[r]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:s.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=r,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const o=this._subscriptionsByHash[r];te(o!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),o.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const r=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64");return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},r)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=E(e,ml);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,r){const s=this._buildArgs([e.toBase58()],n||this._commitment||"finalized","base64",r?{filters:r}:void 0);return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},s)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const r=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},r)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=E(e,jl);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=E(e,kl);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=E(e,Sl);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,r){const s=t||this._commitment;if(s||n||r){let o={};n&&(o.encoding=n),s&&(o.commitment=s),r&&(o=Object.assign(o,r)),e.push(o)}return e}_buildArgsAtLeastConfirmed(e,t,n,r){const s=t||this._commitment;if(s&&!["confirmed","finalized"].includes(s))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,r)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=E(e,Al);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const r=this._buildArgs([e],n||this._commitment||"finalized"),s=this._makeSubscription({callback:(o,c)=>{if(o.type==="status"){t(o.result,c);try{this.removeSignatureListener(s)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},r);return s}onSignatureWithOptions(e,t,n){const{commitment:r,...s}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},o=this._buildArgs([e],r,void 0,s),c=this._makeSubscription({callback:(u,d)=>{t(u,d);try{this.removeSignatureListener(c)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},o);return c}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=E(e,Il);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Ht{constructor(e){this._keypair=void 0,this._keypair=e??Os()}static generate(){return new Ht(Os())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const n=e.slice(32,64);if(!t||!t.skipValidation){const r=e.slice(0,32),s=Jn(r);for(let o=0;o<32;o++)if(n[o]!==s[o])throw new Error("provided secretKey is invalid")}return new Ht({publicKey:n,secretKey:e})}static fromSeed(e){const t=Jn(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new Ht({publicKey:t,secretKey:n})}get publicKey(){return new T(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const ft=Object.freeze({CreateLookupTable:{index:0,layout:U([z("instruction"),Jt("recentSlot"),ne("bumpSeed")])},FreezeLookupTable:{index:1,layout:U([z("instruction")])},ExtendLookupTable:{index:2,layout:U([z("instruction"),Jt(),Re(Y(),Bt(z(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:U([z("instruction")])},CloseLookupTable:{index:4,layout:U([z("instruction")])}});class Zl{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=z("instruction").decode(e.data);let r;for(const[s,o]of Object.entries(ft))if(o.index==n){r=s;break}if(!r)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return r}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=re(ft.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=re(ft.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(n=>new T(n))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(rs.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class rs{constructor(){}static createLookupTable(e){const[t,n]=T.findProgramAddressSync([e.authority.toBuffer(),Ys(BigInt(e.recentSlot),8)],this.programId),r=ft.CreateLookupTable,s=Q(r,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),o=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Se.programId,isSigner:!1,isWritable:!1}];return[new oe({programId:this.programId,keys:o,data:s}),t]}static freezeLookupTable(e){const t=ft.FreezeLookupTable,n=Q(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new oe({programId:this.programId,keys:r,data:n})}static extendLookupTable(e){const t=ft.ExtendLookupTable,n=Q(t,{addresses:e.addresses.map(s=>s.toBytes())}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:Se.programId,isSigner:!1,isWritable:!1}),new oe({programId:this.programId,keys:r,data:n})}static deactivateLookupTable(e){const t=ft.DeactivateLookupTable,n=Q(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new oe({programId:this.programId,keys:r,data:n})}static closeLookupTable(e){const t=ft.CloseLookupTable,n=Q(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new oe({programId:this.programId,keys:r,data:n})}}rs.programId=new T("AddressLookupTab1e1111111111111111111111111");class Ql{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=ne("instruction").decode(e.data);let r;for(const[s,o]of Object.entries(Je))if(o.index==n){r=s;break}if(!r)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return r}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:n}=re(Je.RequestUnits,e.data);return{units:t,additionalFee:n}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=re(Je.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=re(Je.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=re(Je.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(ss.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const Je=Object.freeze({RequestUnits:{index:0,layout:U([ne("instruction"),z("units"),z("additionalFee")])},RequestHeapFrame:{index:1,layout:U([ne("instruction"),z("bytes")])},SetComputeUnitLimit:{index:2,layout:U([ne("instruction"),z("units")])},SetComputeUnitPrice:{index:3,layout:U([ne("instruction"),Jt("microLamports")])}});class ss{constructor(){}static requestUnits(e){const t=Je.RequestUnits,n=Q(t,e);return new oe({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){const t=Je.RequestHeapFrame,n=Q(t,e);return new oe({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){const t=Je.SetComputeUnitLimit,n=Q(t,e);return new oe({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){const t=Je.SetComputeUnitPrice,n=Q(t,{microLamports:BigInt(e.microLamports)});return new oe({keys:[],programId:this.programId,data:n})}}ss.programId=new T("ComputeBudget111111111111111111111111111111");const Ws=64,Ms=32,Ds=64,$s=U([ne("numSignatures"),ne("padding"),Ve("signatureOffset"),Ve("signatureInstructionIndex"),Ve("publicKeyOffset"),Ve("publicKeyInstructionIndex"),Ve("messageDataOffset"),Ve("messageDataSize"),Ve("messageInstructionIndex")]);class lr{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:r,instructionIndex:s}=e;te(t.length===Ms,`Public Key must be ${Ms} bytes but received ${t.length} bytes`),te(r.length===Ds,`Signature must be ${Ds} bytes but received ${r.length} bytes`);const o=$s.span,c=o+t.length,u=c+r.length,d=1,g=D.Buffer.alloc(u+n.length),m=s??65535;return $s.encode({numSignatures:d,padding:0,signatureOffset:c,signatureInstructionIndex:m,publicKeyOffset:o,publicKeyInstructionIndex:m,messageDataOffset:u,messageDataSize:n.length,messageInstructionIndex:m},g),g.fill(t,o),g.fill(r,c),g.fill(n,u),new oe({keys:[],programId:lr.programId,data:g})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:r}=e;te(t.length===Ws,`Private key must be ${Ws} bytes but received ${t.length} bytes`);try{const s=Ht.fromSecretKey(t),o=s.publicKey.toBytes(),c=qr(n,s.secretKey);return this.createInstructionWithPublicKey({publicKey:o,message:n,signature:c,instructionIndex:r})}catch(s){throw new Error(`Error creating instruction; ${s}`)}}}lr.programId=new T("Ed25519SigVerify111111111111111111111111111");const ed=(i,e)=>{const t=Fr.sign(i,e);return[t.toCompactRawBytes(),t.recovery]};Fr.utils.isValidPrivateKey;const td=Fr.getPublicKey,Fs=32,Tr=20,Hs=64,nd=11,Er=U([ne("numSignatures"),Ve("signatureOffset"),ne("signatureInstructionIndex"),Ve("ethAddressOffset"),ne("ethAddressInstructionIndex"),Ve("messageDataOffset"),Ve("messageDataSize"),ne("messageInstructionIndex"),ue(20,"ethAddress"),ue(64,"signature"),ne("recoveryId")]);class Vt{constructor(){}static publicKeyToEthAddress(e){te(e.length===Hs,`Public key must be ${Hs} bytes but received ${e.length} bytes`);try{return D.Buffer.from(Es(G(e))).slice(-Tr)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:r,recoveryId:s,instructionIndex:o}=e;return Vt.createInstructionWithEthAddress({ethAddress:Vt.publicKeyToEthAddress(t),message:n,signature:r,recoveryId:s,instructionIndex:o})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:n,signature:r,recoveryId:s,instructionIndex:o=0}=e;let c;typeof t=="string"?t.startsWith("0x")?c=D.Buffer.from(t.substr(2),"hex"):c=D.Buffer.from(t,"hex"):c=t,te(c.length===Tr,`Address must be ${Tr} bytes but received ${c.length} bytes`);const u=1+nd,d=u,g=u+c.length,m=g+r.length+1,_=1,f=D.Buffer.alloc(Er.span+n.length);return Er.encode({numSignatures:_,signatureOffset:g,signatureInstructionIndex:o,ethAddressOffset:d,ethAddressInstructionIndex:o,messageDataOffset:m,messageDataSize:n.length,messageInstructionIndex:o,signature:G(r),ethAddress:G(c),recoveryId:s},f),f.fill(G(n),Er.span),new oe({keys:[],programId:Vt.programId,data:f})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:r}=e;te(t.length===Fs,`Private key must be ${Fs} bytes but received ${t.length} bytes`);try{const s=G(t),o=td(s,!1).slice(1),c=D.Buffer.from(Es(G(n))),[u,d]=ed(c,s);return this.createInstructionWithPublicKey({publicKey:o,message:n,signature:u,recoveryId:d,instructionIndex:r})}catch(s){throw new Error(`Error creating instruction; ${s}`)}}}Vt.programId=new T("KeccakSecp256k11111111111111111111111111111");var zi;const Wi=new T("StakeConfig11111111111111111111111111111111");class Mi{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class kn{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}zi=kn;kn.default=new zi(0,0,T.default);class rd{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=z("instruction").decode(e.data);let r;for(const[s,o]of Object.entries(ke))if(o.index==n){r=s;break}if(!r)throw new Error("Instruction type incorrect; not a StakeInstruction");return r}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:n}=re(ke.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new Mi(new T(t.staker),new T(t.withdrawer)),lockup:new kn(n.unixTimestamp,n.epoch,new T(n.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),re(ke.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:n}=re(ke.Authorize,e.data),r={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new T(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(r.custodianPubkey=e.keys[3].pubkey),r}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:n,authoritySeed:r,authorityOwner:s}=re(ke.AuthorizeWithSeed,e.data),o={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:r,authorityOwner:new T(s),newAuthorizedPubkey:new T(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(o.custodianPubkey=e.keys[3].pubkey),o}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=re(ke.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),re(ke.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=re(ke.Withdraw,e.data),n={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(n.custodianPubkey=e.keys[5].pubkey),n}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),re(ke.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(dr.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const ke=Object.freeze({Initialize:{index:0,layout:U([z("instruction"),iu(),ou()])},Authorize:{index:1,layout:U([z("instruction"),Y("newAuthorized"),z("stakeAuthorizationType")])},Delegate:{index:2,layout:U([z("instruction")])},Split:{index:3,layout:U([z("instruction"),Fe("lamports")])},Withdraw:{index:4,layout:U([z("instruction"),Fe("lamports")])},Deactivate:{index:5,layout:U([z("instruction")])},Merge:{index:7,layout:U([z("instruction")])},AuthorizeWithSeed:{index:8,layout:U([z("instruction"),Y("newAuthorized"),z("stakeAuthorizationType"),Pt("authoritySeed"),Y("authorityOwner")])}}),sd=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class dr{constructor(){}static initialize(e){const{stakePubkey:t,authorized:n,lockup:r}=e,s=r||kn.default,o=ke.Initialize,c=Q(o,{authorized:{staker:G(n.staker.toBuffer()),withdrawer:G(n.withdrawer.toBuffer())},lockup:{unixTimestamp:s.unixTimestamp,epoch:s.epoch,custodian:G(s.custodian.toBuffer())}}),u={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:jt,isSigner:!1,isWritable:!1}],programId:this.programId,data:c};return new oe(u)}static createAccountWithSeed(e){const t=new se;t.add(Se.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:r,lockup:s}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:s}))}static createAccount(e){const t=new se;t.add(Se.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:r,lockup:s}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:s}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:n,votePubkey:r}=e,s=ke.Delegate,o=Q(s);return new se().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:Yn,isSigner:!1,isWritable:!1},{pubkey:Wi,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static authorize(e){const{stakePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,stakeAuthorizationType:s,custodianPubkey:o}=e,c=ke.Authorize,u=Q(c,{newAuthorized:G(r.toBuffer()),stakeAuthorizationType:s.index}),d=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return o&&d.push({pubkey:o,isSigner:!1,isWritable:!1}),new se().add({keys:d,programId:this.programId,data:u})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:n,authoritySeed:r,authorityOwner:s,newAuthorizedPubkey:o,stakeAuthorizationType:c,custodianPubkey:u}=e,d=ke.AuthorizeWithSeed,g=Q(d,{newAuthorized:G(o.toBuffer()),stakeAuthorizationType:c.index,authoritySeed:r,authorityOwner:G(s.toBuffer())}),m=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:je,isSigner:!1,isWritable:!1}];return u&&m.push({pubkey:u,isSigner:!1,isWritable:!1}),new se().add({keys:m,programId:this.programId,data:g})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:r,lamports:s}=e,o=ke.Split,c=Q(o,{lamports:s});return new oe({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:c})}static split(e){const t=new se;return t.add(Se.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:0,space:this.space,programId:this.programId})),t.add(this.splitInstruction(e))}static splitWithSeed(e){const{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:r,basePubkey:s,seed:o,lamports:c}=e,u=new se;return u.add(Se.allocate({accountPubkey:r,basePubkey:s,seed:o,space:this.space,programId:this.programId})),u.add(this.splitInstruction({stakePubkey:t,authorizedPubkey:n,splitStakePubkey:r,lamports:c}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:n,authorizedPubkey:r}=e,s=ke.Merge,o=Q(s);return new se().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:Yn,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:o})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:n,toPubkey:r,lamports:s,custodianPubkey:o}=e,c=ke.Withdraw,u=Q(c,{lamports:s}),d=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:Yn,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return o&&d.push({pubkey:o,isSigner:!1,isWritable:!1}),new se().add({keys:d,programId:this.programId,data:u})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:n}=e,r=ke.Deactivate,s=Q(r);return new se().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}}dr.programId=new T("Stake11111111111111111111111111111111111111");dr.space=200;class Di{constructor(e,t,n,r){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=n,this.commission=r}}class id{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=z("instruction").decode(e.data);let r;for(const[s,o]of Object.entries(ht))if(o.index==n){r=s;break}if(!r)throw new Error("Instruction type incorrect; not a VoteInstruction");return r}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=re(ht.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new Di(new T(t.nodePubkey),new T(t.authorizedVoter),new T(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:n}=re(ht.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new T(t),voteAuthorizationType:{index:n}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:n,newAuthorized:r,voteAuthorizationType:s}}=re(ht.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new T(t),currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:new T(r),voteAuthorizationType:{index:s},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=re(ht.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(tn.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const ht=Object.freeze({InitializeAccount:{index:0,layout:U([z("instruction"),au()])},Authorize:{index:1,layout:U([z("instruction"),Y("newAuthorized"),z("voteAuthorizationType")])},Withdraw:{index:3,layout:U([z("instruction"),Fe("lamports")])},AuthorizeWithSeed:{index:10,layout:U([z("instruction"),cu()])}}),od=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class tn{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:n,voteInit:r}=e,s=ht.InitializeAccount,o=Q(s,{voteInit:{nodePubkey:G(r.nodePubkey.toBuffer()),authorizedVoter:G(r.authorizedVoter.toBuffer()),authorizedWithdrawer:G(r.authorizedWithdrawer.toBuffer()),commission:r.commission}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:jt,isSigner:!1,isWritable:!1},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:o};return new oe(c)}static createAccount(e){const t=new se;return t.add(Se.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,voteAuthorizationType:s}=e,o=ht.Authorize,c=Q(o,{newAuthorized:G(r.toBuffer()),voteAuthorizationType:s.index}),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new se().add({keys:u,programId:this.programId,data:c})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:s,voteAuthorizationType:o,votePubkey:c}=e,u=ht.AuthorizeWithSeed,d=Q(u,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:G(n.toBuffer()),currentAuthorityDerivedKeySeed:r,newAuthorized:G(s.toBuffer()),voteAuthorizationType:o.index}}),g=[{pubkey:c,isSigner:!1,isWritable:!0},{pubkey:je,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new se().add({keys:g,programId:this.programId,data:d})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:n,lamports:r,toPubkey:s}=e,o=ht.Withdraw,c=Q(o,{lamports:r}),u=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return new se().add({keys:u,programId:this.programId,data:c})}static safeWithdraw(e,t,n){if(e.lamports>t-n)throw new Error("Withdraw will leave vote account with insuffcient funds.");return tn.withdraw(e)}}tn.programId=new T("Vote111111111111111111111111111111111111111");tn.space=3731;const $i=new T("Va1idator1nfo111111111111111111111111111111"),ad=R({name:v(),website:$(v()),details:$(v()),keybaseUsername:$(v())});class is{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];if(Oe(t)!==2)return null;const r=[];for(let s=0;s<2;s++){const o=new T(t.slice(0,xe));t=t.slice(xe);const c=t.slice(0,1)[0]===1;t=t.slice(1),r.push({publicKey:o,isSigner:c})}if(r[0].publicKey.equals($i)&&r[1].isSigner){const s=Pt().decode(D.Buffer.from(t)),o=JSON.parse(s);return Oa(o,ad),new is(r[1].publicKey,o)}return null}}const cd=new T("Vote111111111111111111111111111111111111111"),ud=U([Y("nodePubkey"),Y("authorizedWithdrawer"),ne("commission"),Ie(),Re(U([Ie("slot"),z("confirmationCount")]),Bt(z(),-8),"votes"),ne("rootSlotValid"),Ie("rootSlot"),Ie(),Re(U([Ie("epoch"),Y("authorizedVoter")]),Bt(z(),-8),"authorizedVoters"),U([Re(U([Y("authorizedPubkey"),Ie("epochOfLastAuthorizedSwitch"),Ie("targetEpoch")]),32,"buf"),Ie("idx"),ne("isEmpty")],"priorVoters"),Ie(),Re(U([Ie("epoch"),Ie("credits"),Ie("prevCredits")]),Bt(z(),-8),"epochCredits"),U([Ie("slot"),Ie("timestamp")],"lastTimestamp")]);class os{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const n=ud.decode(G(e),4);let r=n.rootSlot;return n.rootSlotValid||(r=null),new os({nodePubkey:new T(n.nodePubkey),authorizedWithdrawer:new T(n.authorizedWithdrawer),commission:n.commission,votes:n.votes,rootSlot:r,authorizedVoters:n.authorizedVoters.map(ld),priorVoters:dd(n.priorVoters),epochCredits:n.epochCredits,lastTimestamp:n.lastTimestamp})}}function ld({authorizedVoter:i,epoch:e}){return{epoch:e,authorizedVoter:new T(i)}}function Vs({authorizedPubkey:i,epochOfLastAuthorizedSwitch:e,targetEpoch:t}){return{authorizedPubkey:new T(i),epochOfLastAuthorizedSwitch:e,targetEpoch:t}}function dd({buf:i,idx:e,isEmpty:t}){return t?[]:[...i.slice(e+1).map(Vs),...i.slice(0,e).map(Vs)]}const Gs={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function fd(i,e){const t=e===!1?"http":"https";if(!i)return Gs[t].devnet;const n=Gs[t][i];if(!n)throw new Error(`Unknown ${t} cluster: ${i}`);return n}async function hd(i,e,t,n){let r,s;t&&Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")||t&&Object.prototype.hasOwnProperty.call(t,"nonceValue")?(r=t,s=n):s=t;const o=s&&{skipPreflight:s.skipPreflight,preflightCommitment:s.preflightCommitment||s.commitment,minContextSlot:s.minContextSlot},c=await i.sendRawTransaction(e,o),u=s&&s.commitment,g=(await(r?i.confirmTransaction(r,u):i.confirmTransaction(c,u))).value;if(g.err)throw new Error(`Raw transaction ${c} failed (${JSON.stringify(g)})`);return c}const gd=1e9;var yd=Object.freeze(Object.defineProperty({__proto__:null,Account:nu,AddressLookupTableAccount:xr,AddressLookupTableInstruction:Zl,AddressLookupTableProgram:rs,Authorized:Mi,BLOCKHASH_CACHE_TIMEOUT_MS:Ei,BPF_LOADER_DEPRECATED_PROGRAM_ID:ru,BPF_LOADER_PROGRAM_ID:Su,BpfLoader:Au,COMPUTE_BUDGET_INSTRUCTION_LAYOUTS:Je,ComputeBudgetInstruction:Ql,ComputeBudgetProgram:ss,Connection:Xl,Ed25519Program:lr,Enum:eu,EpochSchedule:vi,FeeCalculatorLayout:Ii,Keypair:Ht,LAMPORTS_PER_SOL:gd,LOOKUP_TABLE_INSTRUCTION_LAYOUTS:ft,Loader:Ct,Lockup:kn,MAX_SEED_LENGTH:_i,Message:Ge,MessageAccountKeys:yn,MessageV0:Ot,NONCE_ACCOUNT_LENGTH:Lr,NonceAccount:ar,PACKET_DATA_SIZE:wt,PUBLIC_KEY_LENGTH:xe,PublicKey:T,SIGNATURE_LENGTH_IN_BYTES:Yt,SOLANA_SCHEMA:hn,STAKE_CONFIG_ID:Wi,STAKE_INSTRUCTION_LAYOUTS:ke,SYSTEM_INSTRUCTION_LAYOUTS:ae,SYSVAR_CLOCK_PUBKEY:je,SYSVAR_EPOCH_SCHEDULE_PUBKEY:hu,SYSVAR_INSTRUCTIONS_PUBKEY:gu,SYSVAR_RECENT_BLOCKHASHES_PUBKEY:qn,SYSVAR_RENT_PUBKEY:jt,SYSVAR_REWARDS_PUBKEY:yu,SYSVAR_SLOT_HASHES_PUBKEY:pu,SYSVAR_SLOT_HISTORY_PUBKEY:bu,SYSVAR_STAKE_HISTORY_PUBKEY:Yn,Secp256k1Program:Vt,SendTransactionError:Kr,SolanaJSONRPCError:W,SolanaJSONRPCErrorCode:Pu,StakeAuthorizationLayout:sd,StakeInstruction:rd,StakeProgram:dr,Struct:Yr,SystemInstruction:ku,SystemProgram:Se,Transaction:se,TransactionExpiredBlockheightExceededError:jr,TransactionExpiredNonceInvalidError:Ft,TransactionExpiredTimeoutError:Jr,TransactionInstruction:oe,TransactionMessage:Zr,TransactionStatus:dt,VALIDATOR_INFO_KEY:$i,VERSION_PREFIX_MASK:ir,VOTE_PROGRAM_ID:cd,ValidatorInfo:is,VersionedMessage:Xr,VersionedTransaction:Qr,VoteAccount:os,VoteAuthorizationLayout:od,VoteInit:Di,VoteInstruction:id,VoteProgram:tn,clusterApiUrl:fd,sendAndConfirmRawTransaction:hd,sendAndConfirmTransaction:Nr},Symbol.toStringTag,{value:"Module"})),_n=Na(yd),He={},he={},Kt={},be={},pd=N&&N.__createBinding||(Object.create?function(i,e,t,n){n===void 0&&(n=t),Object.defineProperty(i,n,{enumerable:!0,get:function(){return e[t]}})}:function(i,e,t,n){n===void 0&&(n=t),i[n]=e[t]}),bd=N&&N.__setModuleDefault||(Object.create?function(i,e){Object.defineProperty(i,"default",{enumerable:!0,value:e})}:function(i,e){i.default=e}),nt=N&&N.__decorate||function(i,e,t,n){var r=arguments.length,s=r<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,o;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(i,e,t,n);else for(var c=i.length-1;c>=0;c--)(o=i[c])&&(s=(r<3?o(s):r>3?o(e,t,s):o(e,t))||s);return r>3&&s&&Object.defineProperty(e,t,s),s},md=N&&N.__importStar||function(i){if(i&&i.__esModule)return i;var e={};if(i!=null)for(var t in i)t!=="default"&&Object.hasOwnProperty.call(i,t)&&pd(e,i,t);return bd(e,i),e},Fi=N&&N.__importDefault||function(i){return i&&i.__esModule?i:{default:i}};Object.defineProperty(be,"__esModule",{value:!0});be.deserializeUnchecked=be.deserialize=be.serialize=be.BinaryReader=be.BinaryWriter=be.BorshError=be.baseDecode=be.baseEncode=void 0;const mt=Fi(nr.exports),Hi=Fi(ge),wd=md(Mr),kd=typeof N.TextDecoder!="function"?wd.TextDecoder:N.TextDecoder,_d=new kd("utf-8",{fatal:!0});function Sd(i){return typeof i=="string"&&(i=x.Buffer.from(i,"utf8")),Hi.default.encode(x.Buffer.from(i))}be.baseEncode=Sd;function Ad(i){return x.Buffer.from(Hi.default.decode(i))}be.baseDecode=Ad;const Pr=1024;class Ne extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}be.BorshError=Ne;class Vi{constructor(){this.buf=x.Buffer.alloc(Pr),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=x.Buffer.concat([this.buf,x.Buffer.alloc(Pr)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new mt.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new mt.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new mt.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(x.Buffer.from(new mt.default(e).toArray("le",64)))}writeBuffer(e){this.buf=x.Buffer.concat([x.Buffer.from(this.buf.subarray(0,this.length)),e,x.Buffer.alloc(Pr)]),this.length+=e.length}writeString(e){this.maybeResize();const t=x.Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(x.Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}}be.BinaryWriter=Vi;function rt(i,e,t){const n=t.value;t.value=function(...r){try{return n.apply(this,r)}catch(s){if(s instanceof RangeError){const o=s.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(o)>=0)throw new Ne("Reached the end of buffer when deserializing")}throw s}}}class We{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new mt.default(e,"le")}readU128(){const e=this.readBuffer(16);return new mt.default(e,"le")}readU256(){const e=this.readBuffer(32);return new mt.default(e,"le")}readU512(){const e=this.readBuffer(64);return new mt.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new Ne(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return _d.decode(t)}catch(n){throw new Ne(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let r=0;r<t;++r)n.push(e());return n}}nt([rt],We.prototype,"readU8",null);nt([rt],We.prototype,"readU16",null);nt([rt],We.prototype,"readU32",null);nt([rt],We.prototype,"readU64",null);nt([rt],We.prototype,"readU128",null);nt([rt],We.prototype,"readU256",null);nt([rt],We.prototype,"readU512",null);nt([rt],We.prototype,"readString",null);nt([rt],We.prototype,"readFixedArray",null);nt([rt],We.prototype,"readArray",null);be.BinaryReader=We;function Gi(i){return i.charAt(0).toUpperCase()+i.slice(1)}function Zn(i,e,t,n,r){try{if(typeof n=="string")r[`write${Gi(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new Ne(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);r.writeFixedArray(t)}else r.writeArray(t,s=>{Zn(i,e,s,n[0],r)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?r.writeU8(0):(r.writeU8(1),Zn(i,e,t,n.type,r));break}default:throw new Ne(`FieldType ${n} unrecognized`)}else qi(i,t,r)}catch(s){throw s instanceof Ne&&s.addToFieldPath(e),s}}function qi(i,e,t){const n=i.get(e.constructor);if(!n)throw new Ne(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([r,s])=>{Zn(i,r,e[r],s,t)});else if(n.kind==="enum"){const r=e[n.field];for(let s=0;s<n.values.length;++s){const[o,c]=n.values[s];if(o===r){t.writeU8(s),Zn(i,o,e[o],c,t);break}}}else throw new Ne(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Id(i,e){const t=new Vi;return qi(i,e,t),t.toArray()}be.serialize=Id;function Qn(i,e,t,n){try{return typeof t=="string"?n[`read${Gi(t)}`]():t instanceof Array?typeof t[0]=="number"?n.readFixedArray(t[0]):n.readArray(()=>Qn(i,e,t[0],n)):t.kind==="option"?n.readU8()?Qn(i,e,t.type,n):void 0:as(i,t,n)}catch(r){throw r instanceof Ne&&r.addToFieldPath(e),r}}function as(i,e,t){const n=i.get(e);if(!n)throw new Ne(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const r={};for(const[s,o]of i.get(e).fields)r[s]=Qn(i,s,o,t);return new e(r)}if(n.kind==="enum"){const r=t.readU8();if(r>=n.values.length)throw new Ne(`Enum index: ${r} is out of range`);const[s,o]=n.values[r],c=Qn(i,s,o,t);return new e({[s]:c})}throw new Ne(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function Rd(i,e,t){const n=new We(t),r=as(i,e,n);if(n.offset<t.length)throw new Ne(`Unexpected ${t.length-n.offset} bytes after deserialized data`);return r}be.deserialize=Rd;function vd(i,e,t){const n=new We(t);return as(i,e,n)}be.deserializeUnchecked=vd;Object.defineProperty(Kt,"__esModule",{value:!0});Kt.NameRegistryState=void 0;const Br=_n,Td=be;class Xt{constructor(e){this.parentName=new Br.PublicKey(e.parentName),this.owner=new Br.PublicKey(e.owner),this.class=new Br.PublicKey(e.class)}static async retrieve(e,t){var n;const r=await e.getAccountInfo(t,"processed");if(!r)throw new Error("Invalid name account provided");const s=(0,Td.deserializeUnchecked)(this.schema,Xt,r.data);return s.data=(n=r.data)===null||n===void 0?void 0:n.slice(this.HEADER_LEN),s}}Kt.NameRegistryState=Xt;Xt.HEADER_LEN=96;Xt.schema=new Map([[Xt,{kind:"struct",fields:[["parentName",[32]],["owner",[32]],["class",[32]]]}]]);var Yi=N&&N.__importDefault||function(i){return i&&i.__esModule?i:{default:i}};Object.defineProperty(he,"__esModule",{value:!0});he.getFilteredProgramAccounts=he.getNameOwner=he.getNameAccountKey=he.getHashedName=he.signAndSendTransactionInstructions=he.Numberu64=he.Numberu32=void 0;const er=Yi(za.exports),Ed=Wa,ji=_n,tr=Yi(nr.exports),Ji=sr,Pd=Kt;class Bd extends tr.default{toBuffer(){const e=super.toArray().reverse(),t=x.Buffer.from(e);if(t.length===4)return t;(0,er.default)(t.length<4,"Numberu32 too large");const n=x.Buffer.alloc(4);return t.copy(n),n}static fromBuffer(e){return(0,er.default)(e.length===4,`Invalid buffer length: ${e.length}`),new tr.default([...e].reverse().map(t=>`00${t.toString(16)}`.slice(-2)).join(""),16)}}he.Numberu32=Bd;class Od extends tr.default{toBuffer(){const e=super.toArray().reverse(),t=x.Buffer.from(e);if(t.length===8)return t;(0,er.default)(t.length<8,"Numberu64 too large");const n=x.Buffer.alloc(8);return t.copy(n),n}static fromBuffer(e){return(0,er.default)(e.length===8,`Invalid buffer length: ${e.length}`),new tr.default([...e].reverse().map(t=>`00${t.toString(16)}`.slice(-2)).join(""),16)}}he.Numberu64=Od;const Cd=async(i,e,t,n)=>{const r=new ji.Transaction;return r.feePayer=t.publicKey,e.push(t),r.add(...n),await i.sendTransaction(r,e)};he.signAndSendTransactionInstructions=Cd;async function Nd(i){const e=Ji.HASH_PREFIX+i;return(0,Ed.createHash)("sha256").update(e,"utf8").digest()}he.getHashedName=Nd;async function Ld(i,e,t){const n=[i];e?n.push(e.toBuffer()):n.push(x.Buffer.alloc(32)),t?n.push(t.toBuffer()):n.push(x.Buffer.alloc(32));const[r]=await ji.PublicKey.findProgramAddress(n,Ji.NAME_PROGRAM_ID);return r}he.getNameAccountKey=Ld;async function Kd(i,e){if(!await i.getAccountInfo(e))throw new Error("Unable to find the given account.");return Pd.NameRegistryState.retrieve(i,e)}he.getNameOwner=Kd;async function xd(i,e,t){return(await i.getProgramAccounts(e,{commitment:i.commitment,filters:t,encoding:"base64"})).map(({pubkey:r,account:{data:s,executable:o,owner:c,lamports:u}})=>({publicKey:r,accountInfo:{data:s,executable:o,owner:c,lamports:u}}))}he.getFilteredProgramAccounts=xd;Object.defineProperty(He,"__esModule",{value:!0});He.deleteInstruction=He.transferInstruction=He.updateInstruction=He.createInstruction=void 0;const Gt=_n,Xi=he;function Ud(i,e,t,n,r,s,o,c,u,d,g){const m=[x.Buffer.from(Int8Array.from([0])),new Xi.Numberu32(s.length).toBuffer(),s,o.toBuffer(),c.toBuffer()],_=x.Buffer.concat(m),f=[{pubkey:e,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!0},{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!1}];return u?f.push({pubkey:u,isSigner:!0,isWritable:!1}):f.push({pubkey:new Gt.PublicKey(x.Buffer.alloc(32)),isSigner:!1,isWritable:!1}),d?f.push({pubkey:d,isSigner:!1,isWritable:!1}):f.push({pubkey:new Gt.PublicKey(x.Buffer.alloc(32)),isSigner:!1,isWritable:!1}),g&&f.push({pubkey:g,isSigner:!0,isWritable:!1}),new Gt.TransactionInstruction({keys:f,programId:i,data:_})}He.createInstruction=Ud;function zd(i,e,t,n,r,s){const o=[x.Buffer.from(Int8Array.from([1])),t.toBuffer(),new Xi.Numberu32(n.length).toBuffer(),n],c=x.Buffer.concat(o),u=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1}];return s&&u.push({pubkey:s,isSigner:!1,isWritable:!1}),new Gt.TransactionInstruction({keys:u,programId:i,data:c})}He.updateInstruction=zd;function Wd(i,e,t,n,r,s){const o=[x.Buffer.from(Int8Array.from([2])),t.toBuffer()],c=x.Buffer.concat(o),u=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return r&&u.push({pubkey:r,isSigner:!0,isWritable:!1}),s&&u.push({pubkey:s,isSigner:!1,isWritable:!1}),new Gt.TransactionInstruction({keys:u,programId:i,data:c})}He.transferInstruction=Wd;function Md(i,e,t,n){const r=[x.Buffer.from(Int8Array.from([3]))],s=x.Buffer.concat(r),o=[{pubkey:e,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:t,isSigner:!1,isWritable:!0}];return new Gt.TransactionInstruction({keys:o,programId:i,data:s})}He.deleteInstruction=Md;(function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.deleteNameRegistry=i.transferNameOwnership=i.updateNameRegistryData=i.createNameRegistry=i.HASH_PREFIX=i.NAME_PROGRAM_ID=void 0;const e=_n,t=He,n=Kt,r=he,s=he;i.NAME_PROGRAM_ID=new e.PublicKey("namesLPneVptA9Z5rqUDD9tMTWEJwofgaYwp8cawRkX"),i.HASH_PREFIX="SPL Name Service";async function o(g,m,_,f,b,w,A,h){const k=await(0,s.getHashedName)(m),S=await(0,s.getNameAccountKey)(k,A,h),C=w||await g.getMinimumBalanceForRentExemption(_);let K;return h&&(K=(await(0,s.getNameOwner)(g,h)).owner),(0,t.createInstruction)(i.NAME_PROGRAM_ID,e.SystemProgram.programId,S,b,f,k,new r.Numberu64(C),new s.Numberu32(_),A,h,K)}i.createNameRegistry=o;async function c(g,m,_,f,b,w){const A=await(0,s.getHashedName)(m),h=await(0,s.getNameAccountKey)(A,b,w);let k;return b?k=b:k=(await n.NameRegistryState.retrieve(g,h)).owner,(0,t.updateInstruction)(i.NAME_PROGRAM_ID,h,new s.Numberu32(_),f,k,w)}i.updateNameRegistryData=c;async function u(g,m,_,f,b){const w=await(0,s.getHashedName)(m),A=await(0,s.getNameAccountKey)(w,f,b);let h;return f?h=f:h=(await n.NameRegistryState.retrieve(g,A)).owner,(0,t.transferInstruction)(i.NAME_PROGRAM_ID,A,_,h,f,b)}i.transferNameOwnership=u;async function d(g,m,_,f,b){const w=await(0,s.getHashedName)(m),A=await(0,s.getNameAccountKey)(w,f,b);let h;return f?h=f:h=(await n.NameRegistryState.retrieve(g,A)).owner,(0,t.deleteInstruction)(i.NAME_PROGRAM_ID,A,_,h)}i.deleteNameRegistry=d})(sr);var Zi={};(function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.createReverseTwitterRegistry=i.ReverseTwitterRegistryState=i.getTwitterRegistryData=i.getTwitterHandleandRegistryKeyViaFilters=i.getHandleAndRegistryKey=i.getTwitterRegistry=i.getTwitterRegistryKey=i.deleteTwitterRegistry=i.changeVerifiedPubkey=i.changeTwitterRegistryData=i.createVerifiedTwitterRegistry=i.TWITTER_ROOT_PARENT_REGISTRY_KEY=i.TWITTER_VERIFICATION_AUTHORITY=void 0;const e=_n,t=be,n=sr,r=He,s=Kt,o=he;i.TWITTER_VERIFICATION_AUTHORITY=new e.PublicKey("FvPH7PrVrLGKPfqaf3xJodFTjZriqrAXXLTVWEorTFBi"),i.TWITTER_ROOT_PARENT_REGISTRY_KEY=new e.PublicKey("4YcexoW3r78zz16J2aqmukBLRwGq6rAvWzJpkYAXqebv");async function c(k,S,C,K,L){const q=await(0,o.getHashedName)(S),j=await(0,o.getNameAccountKey)(q,void 0,i.TWITTER_ROOT_PARENT_REGISTRY_KEY);let ee=[(0,r.createInstruction)(n.NAME_PROGRAM_ID,e.SystemProgram.programId,j,C,L,q,new o.Numberu64(await k.getMinimumBalanceForRentExemption(K)),new o.Numberu32(K),void 0,i.TWITTER_ROOT_PARENT_REGISTRY_KEY,i.TWITTER_VERIFICATION_AUTHORITY)];return ee=ee.concat(await h(k,S,j,C,L)),ee}i.createVerifiedTwitterRegistry=c;async function u(k,S,C,K){const L=await(0,o.getHashedName)(k),q=await(0,o.getNameAccountKey)(L,void 0,i.TWITTER_ROOT_PARENT_REGISTRY_KEY);return[(0,r.updateInstruction)(n.NAME_PROGRAM_ID,q,new o.Numberu32(C),K,S,void 0)]}i.changeTwitterRegistryData=u;async function d(k,S,C,K,L){const q=await(0,o.getHashedName)(S),j=await(0,o.getNameAccountKey)(q,void 0,i.TWITTER_ROOT_PARENT_REGISTRY_KEY);let ee=[(0,r.transferInstruction)(n.NAME_PROGRAM_ID,j,K,C,void 0)];return ee.push(await(0,n.deleteNameRegistry)(k,C.toString(),L,i.TWITTER_VERIFICATION_AUTHORITY,i.TWITTER_ROOT_PARENT_REGISTRY_KEY)),ee=ee.concat(await h(k,S,j,K,L)),ee}i.changeVerifiedPubkey=d;async function g(k,S){const C=await(0,o.getHashedName)(k),K=await(0,o.getNameAccountKey)(C,void 0,i.TWITTER_ROOT_PARENT_REGISTRY_KEY),L=await(0,o.getHashedName)(S.toString()),q=await(0,o.getNameAccountKey)(L,i.TWITTER_VERIFICATION_AUTHORITY,i.TWITTER_ROOT_PARENT_REGISTRY_KEY);return[(0,r.deleteInstruction)(n.NAME_PROGRAM_ID,K,S,S),(0,r.deleteInstruction)(n.NAME_PROGRAM_ID,q,S,S)]}i.deleteTwitterRegistry=g;async function m(k){const S=await(0,o.getHashedName)(k);return await(0,o.getNameAccountKey)(S,void 0,i.TWITTER_ROOT_PARENT_REGISTRY_KEY)}i.getTwitterRegistryKey=m;async function _(k,S){const C=await(0,o.getHashedName)(S),K=await(0,o.getNameAccountKey)(C,void 0,i.TWITTER_ROOT_PARENT_REGISTRY_KEY);return s.NameRegistryState.retrieve(k,K)}i.getTwitterRegistry=_;async function f(k,S){const C=await(0,o.getHashedName)(S.toString()),K=await(0,o.getNameAccountKey)(C,i.TWITTER_VERIFICATION_AUTHORITY,i.TWITTER_ROOT_PARENT_REGISTRY_KEY),L=await A.retrieve(k,K);return[L.twitterHandle,new e.PublicKey(L.twitterRegistryKey)]}i.getHandleAndRegistryKey=f;async function b(k,S){const C=[{memcmp:{offset:0,bytes:i.TWITTER_ROOT_PARENT_REGISTRY_KEY.toBase58()}},{memcmp:{offset:32,bytes:S.toBase58()}},{memcmp:{offset:64,bytes:i.TWITTER_VERIFICATION_AUTHORITY.toBase58()}}],K=await(0,o.getFilteredProgramAccounts)(k,n.NAME_PROGRAM_ID,C);for(const L of K)if(L.accountInfo.data.length>s.NameRegistryState.HEADER_LEN+32){const q=L.accountInfo.data.slice(s.NameRegistryState.HEADER_LEN),j=(0,t.deserialize)(A.schema,A,q);return[j.twitterHandle,new e.PublicKey(j.twitterRegistryKey)]}throw new Error("Registry not found.")}i.getTwitterHandleandRegistryKeyViaFilters=b;async function w(k,S){const C=[{memcmp:{offset:0,bytes:i.TWITTER_ROOT_PARENT_REGISTRY_KEY.toBytes()}},{memcmp:{offset:32,bytes:S.toBytes()}},{memcmp:{offset:64,bytes:new e.PublicKey(x.Buffer.alloc(32,0)).toBase58()}}],K=await(0,o.getFilteredProgramAccounts)(k,n.NAME_PROGRAM_ID,C);if(K.length>1)throw new Error("Found more than one registry.");return K[0].accountInfo.data.slice(s.NameRegistryState.HEADER_LEN)}i.getTwitterRegistryData=w;class A{constructor(S){this.twitterRegistryKey=S.twitterRegistryKey,this.twitterHandle=S.twitterHandle}static async retrieve(S,C){const K=await S.getAccountInfo(C,"processed");if(!K)throw new Error("Invalid reverse Twitter account provided");return(0,t.deserializeUnchecked)(this.schema,A,K.data.slice(s.NameRegistryState.HEADER_LEN))}}i.ReverseTwitterRegistryState=A,A.schema=new Map([[A,{kind:"struct",fields:[["twitterRegistryKey",[32]],["twitterHandle","string"]]}]]);async function h(k,S,C,K,L){const q=await(0,o.getHashedName)(K.toString()),j=await(0,o.getNameAccountKey)(q,i.TWITTER_VERIFICATION_AUTHORITY,i.TWITTER_ROOT_PARENT_REGISTRY_KEY),ee=(0,t.serialize)(A.schema,new A({twitterRegistryKey:C.toBytes(),twitterHandle:S}));return[(0,r.createInstruction)(n.NAME_PROGRAM_ID,e.SystemProgram.programId,j,K,L,q,new o.Numberu64(await k.getMinimumBalanceForRentExemption(ee.length)),new o.Numberu32(ee.length),i.TWITTER_VERIFICATION_AUTHORITY,i.TWITTER_ROOT_PARENT_REGISTRY_KEY,i.TWITTER_VERIFICATION_AUTHORITY),(0,r.updateInstruction)(n.NAME_PROGRAM_ID,j,new o.Numberu32(0),x.Buffer.from(ee),i.TWITTER_VERIFICATION_AUTHORITY,void 0)]}i.createReverseTwitterRegistry=h})(Zi);(function(i){var e=N&&N.__createBinding||(Object.create?function(n,r,s,o){o===void 0&&(o=s);var c=Object.getOwnPropertyDescriptor(r,s);(!c||("get"in c?!r.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return r[s]}}),Object.defineProperty(n,o,c)}:function(n,r,s,o){o===void 0&&(o=s),n[o]=r[s]}),t=N&&N.__exportStar||function(n,r){for(var s in n)s!=="default"&&!Object.prototype.hasOwnProperty.call(r,s)&&e(r,n,s)};Object.defineProperty(i,"__esModule",{value:!0}),t(sr,i),t(He,i),t(Kt,i),t(he,i),t(Zi,i)})(li);(function(i){var e=N&&N.__awaiter||function(d,g,m,_){function f(b){return b instanceof m?b:new m(function(w){w(b)})}return new(m||(m=Promise))(function(b,w){function A(S){try{k(_.next(S))}catch(C){w(C)}}function h(S){try{k(_.throw(S))}catch(C){w(C)}}function k(S){S.done?b(S.value):f(S.value).then(A,h)}k((_=_.apply(d,g||[])).next())})},t=N&&N.__generator||function(d,g){var m={label:0,sent:function(){if(b[0]&1)throw b[1];return b[1]},trys:[],ops:[]},_,f,b,w;return w={next:A(0),throw:A(1),return:A(2)},typeof Symbol=="function"&&(w[Symbol.iterator]=function(){return this}),w;function A(k){return function(S){return h([k,S])}}function h(k){if(_)throw new TypeError("Generator is already executing.");for(;m;)try{if(_=1,f&&(b=k[0]&2?f.return:k[0]?f.throw||((b=f.return)&&b.call(f),0):f.next)&&!(b=b.call(f,k[1])).done)return b;switch(f=0,b&&(k=[k[0]&2,b.value]),k[0]){case 0:case 1:b=k;break;case 4:return m.label++,{value:k[1],done:!1};case 5:m.label++,f=k[1],k=[0];continue;case 7:k=m.ops.pop(),m.trys.pop();continue;default:if(b=m.trys,!(b=b.length>0&&b[b.length-1])&&(k[0]===6||k[0]===2)){m=0;continue}if(k[0]===3&&(!b||k[1]>b[0]&&k[1]<b[3])){m.label=k[1];break}if(k[0]===6&&m.label<b[1]){m.label=b[1],b=k;break}if(b&&m.label<b[2]){m.label=b[2],m.ops.push(k);break}b[2]&&m.ops.pop(),m.trys.pop();continue}k=g.call(d,m)}catch(S){k=[6,S],f=0}finally{_=b=0}if(k[0]&5)throw k[1];return{value:k[0]?k[1]:void 0,done:!0}}};Object.defineProperty(i,"__esModule",{value:!0}),i.resolveToWalletAddress=i.getInputKey=i.SOL_TLD_AUTHORITY=void 0;var n=Zt,r=li,s=Ce;i.SOL_TLD_AUTHORITY=new n.PublicKey("58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx");var o=function(d){return e(void 0,void 0,void 0,function(){var g,m;return t(this,function(_){switch(_.label){case 0:return[4,(0,r.getHashedName)(d)];case 1:return g=_.sent(),[4,(0,r.getNameAccountKey)(g,void 0,i.SOL_TLD_AUTHORITY)];case 2:return m=_.sent(),[2,{inputDomainKey:m,hashedInputName:g}]}})})};i.getInputKey=o;var c=new Error("Can't resolve provided name into valid Solana address =("),u=function(d){var g=d.text,m=d.connection,_=m===void 0?(0,s.createConnectionConfig)():m;return e(void 0,void 0,void 0,function(){var f,b,w,A,h,k,S,C,K,L,q,j;return t(this,function(ee){switch(ee.label){case 0:return f=(K=g==null?void 0:g.trim)===null||K===void 0?void 0:K.call(g),f?(b=(0,s.isValidSolanaAddress)(f),b?[2,Promise.resolve(f)]:(w=f==null?void 0:f.toLowerCase(),A=(L=w==null?void 0:w.endsWith)===null||L===void 0?void 0:L.call(w,".sol"),A?(h=w.split(".sol")[0],[4,(0,i.getInputKey)(h)]):[3,3])):[2,Promise.reject(c)];case 1:return k=ee.sent().inputDomainKey,[4,r.NameRegistryState.retrieve(_,k)];case 2:if(S=ee.sent(),C=(j=(q=S==null?void 0:S.owner)===null||q===void 0?void 0:q.toBase58)===null||j===void 0?void 0:j.call(q),C)return[2,Promise.resolve(C)];ee.label=3;case 3:return[2,Promise.reject(c)]}})})};i.resolveToWalletAddress=u})(ui);(function(i){Object.defineProperty(i,"__esModule",{value:!0}),i.decodeTokenMetadata=i.getSolanaMetadataAddress=i.createConnectionConfig=i.isValidSolanaAddress=i.resolveToWalletAddress=i.getParsedAccountByMint=i.getParsedNftAccountsByUpdateAuthority=i.getParsedNftAccountsByOwner=void 0;var e=Xs;Object.defineProperty(i,"getParsedNftAccountsByOwner",{enumerable:!0,get:function(){return e.getParsedNftAccountsByOwner}});var t=ci;Object.defineProperty(i,"getParsedNftAccountsByUpdateAuthority",{enumerable:!0,get:function(){return t.getParsedNftAccountsByUpdateAuthority}});var n=rr;Object.defineProperty(i,"getParsedAccountByMint",{enumerable:!0,get:function(){return n.getParsedAccountByMint}});var r=ui;Object.defineProperty(i,"resolveToWalletAddress",{enumerable:!0,get:function(){return r.resolveToWalletAddress}});var s=Ce;Object.defineProperty(i,"isValidSolanaAddress",{enumerable:!0,get:function(){return s.isValidSolanaAddress}}),Object.defineProperty(i,"createConnectionConfig",{enumerable:!0,get:function(){return s.createConnectionConfig}}),Object.defineProperty(i,"getSolanaMetadataAddress",{enumerable:!0,get:function(){return s.getSolanaMetadataAddress}}),Object.defineProperty(i,"decodeTokenMetadata",{enumerable:!0,get:function(){return s.decodeTokenMetadata}})})(Js);new js("3x5vrFFTspsicxrYHMA8SNVW71RMhVkALemXrJFfeQo1");const Gd=La("walletStore",{state:()=>({_updateCount:0,is_loading:!1,token_accounts:[],nft_accounts:[],nft_in_wallet:[],token_map:[],nft_map:[]}),getters:{get_account_map(i){return i.token_accounts.map(e=>{const t=e.account.data.parsed.info;return{pubkey:e.pubkey.toString(),info:t,account:e,meta:Ka().token_list.find(n=>n.address===t.mint)}})}},actions:{async update_accounts(){cn().connection&&(this.is_loading=!0,this.token_accounts=[],Vn().publicKey.value&&(this.token_accounts=[],this.token_accounts=(await cn().connection.getParsedTokenAccountsByOwner(Vn().publicKey.value,{programId:xa})).value),this.is_loading=!1)},async update_accounts_nft(i=!1){if(Vn().publicKey.value||!this.nft_map.length||i){this.is_loading=!0,this.nft_in_wallet=[],this.nft_map=[],this.nft_in_wallet=await Js.getParsedNftAccountsByOwner({publicAddress:Vn().publicKey.value.toString(),connection:cn().connection});for(const e of this.nft_in_wallet){const t=await cn().connection.getTokenLargestAccounts(new js(e.mint)),n=await cn().connection.getParsedAccountInfo(t.value[0].address),r=n.value.data.parsed.info;this.nft_map.push({pubkey:t.value[0].address.toString(),account:n.value,info:r,meta:e,data:await Dd(e.data.uri)})}}this.is_loading=!1}}});async function Dd(i){try{return await Ua.get(i).then(e=>e.data)}catch(e){console.warn(e);return}}export{Vd as Q,Gd as u};
