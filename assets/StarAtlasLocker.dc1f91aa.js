import{Q as Fr,a as _r,b as jo}from"./QInput.7907ef1d.js";import{Q as Go}from"./QPage.e974b77e.js";import{a as ge,Q as jr}from"./QCard.7ea828d2.js";import{Q as Zo}from"./QSpace.b3fa8673.js";import{e9 as Ys,di as V,dj as Bt,dk as C,dl as N,dm as $t,dn as st,dp as Ft,dq as Fe,dG as Yt,dI as pt,de as Tt,cX as Dr,e6 as Yo,e7 as Qo,e8 as Xo,dM as Jo,dN as ti,P as Lt,cn as _t,dT as ei,ea as ni,cq as Ze,eb as ri,d3 as si,au as Mn,b1 as ht,ai as se,bx as St,as as tt,al as w,V as rt,ck as me,ak as Pt,bz as ws,a6 as Qs,b7 as Xs,a1 as Et,aj as In,cs as xs,J as Js,aX as to,bs as oi,cl as ii}from"./index.6f8a223c.js";import{c as As,d as Ss}from"./use-key-composition.d98e1d48.js";import{Q as ai}from"./QList.56095fc3.js";import{b as c,a as F,c as ci,d as ui}from"./Amount.24cfb145.js";import{f as ln,g as je}from"./assert.8747a2e2.js";import{d as Ut}from"./index.9ce977f1.js";import{h as li}from"./handle_confirmation.050b3ccc.js";import{t as di}from"./token.40d108ab.js";import{T as fi}from"./constants.d556ca02.js";import{Q as hi}from"./QImg.e40cef39.js";import{Q as dn}from"./QSeparator.7c710843.js";import{_ as gi}from"./plugin-vue_export-helper.21dcd24c.js";import"./sha256.bb694e72.js";import"./defineProperty.034d6b40.js";function ks(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function pi(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function Pn(n,...t){if(!pi(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${n.length}`)}function mi(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ks(n.outputLen),ks(n.blockLen)}function vn(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function yi(n,t){Pn(n);const e=t.outputLen;if(n.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Lr=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Rr=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),Xt=(n,t)=>n<<32-t|n>>>t;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function bi(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function Gr(n){return typeof n=="string"&&(n=bi(n)),Pn(n),n}function wi(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];Pn(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const o=n[r];e.set(o,s),s+=o.length}return e}class eo{clone(){return this._cloneInto()}}function no(n){const t=r=>n().update(Gr(r)).digest(),e=n();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>n(),t}function ro(n=32){if(Lr&&typeof Lr.getRandomValues=="function")return Lr.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function xi(n,t,e,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,e,r);const s=BigInt(32),o=BigInt(4294967295),i=Number(e>>s&o),u=Number(e&o),a=r?4:0,l=r?0:4;n.setUint32(t+a,i,r),n.setUint32(t+l,u,r)}const Ai=(n,t,e)=>n&t^~n&e,Si=(n,t,e)=>n&t^n&e^t&e;class so extends eo{constructor(t,e,r,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Rr(this.buffer)}update(t){vn(this);const{view:e,buffer:r,blockLen:s}=this;t=Gr(t);const o=t.length;for(let i=0;i<o;){const u=Math.min(s-this.pos,o-i);if(u===s){const a=Rr(t);for(;s<=o-i;i+=s)this.process(a,i);continue}r.set(t.subarray(i,i+u),this.pos),this.pos+=u,i+=u,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){vn(this),yi(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:o}=this;let{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(r,0),i=0);for(let f=i;f<s;f++)e[f]=0;xi(r,s-8,BigInt(this.length*8),o),this.process(r,0);const u=Rr(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=a/4,d=this.get();if(l>d.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<l;f++)u.setUint32(4*f,d[f],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:o,destroyed:i,pos:u}=this;return t.length=s,t.pos=u,t.finished=o,t.destroyed=i,s%e&&t.buffer.set(r),t}}const fn=BigInt(2**32-1),Nr=BigInt(32);function oo(n,t=!1){return t?{h:Number(n&fn),l:Number(n>>Nr&fn)}:{h:Number(n>>Nr&fn)|0,l:Number(n&fn)|0}}function ki(n,t=!1){let e=new Uint32Array(n.length),r=new Uint32Array(n.length);for(let s=0;s<n.length;s++){const{h:o,l:i}=oo(n[s],t);[e[s],r[s]]=[o,i]}return[e,r]}const Ii=(n,t)=>BigInt(n>>>0)<<Nr|BigInt(t>>>0),Bi=(n,t,e)=>n>>>e,vi=(n,t,e)=>n<<32-e|t>>>e,Ei=(n,t,e)=>n>>>e|t<<32-e,Ti=(n,t,e)=>n<<32-e|t>>>e,_i=(n,t,e)=>n<<64-e|t>>>e-32,Li=(n,t,e)=>n>>>e-32|t<<64-e,Ri=(n,t)=>t,zi=(n,t)=>n,Ci=(n,t,e)=>n<<e|t>>>32-e,Ki=(n,t,e)=>t<<e|n>>>32-e,Mi=(n,t,e)=>t<<e-32|n>>>64-e,Pi=(n,t,e)=>n<<e-32|t>>>64-e;function Fi(n,t,e,r){const s=(t>>>0)+(r>>>0);return{h:n+e+(s/2**32|0)|0,l:s|0}}const Di=(n,t,e)=>(n>>>0)+(t>>>0)+(e>>>0),Ni=(n,t,e,r)=>t+e+r+(n/2**32|0)|0,qi=(n,t,e,r)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0),Ui=(n,t,e,r,s)=>t+e+r+s+(n/2**32|0)|0,$i=(n,t,e,r,s)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0)+(s>>>0),Oi=(n,t,e,r,s,o)=>t+e+r+s+o+(n/2**32|0)|0,Hi={fromBig:oo,split:ki,toBig:Ii,shrSH:Bi,shrSL:vi,rotrSH:Ei,rotrSL:Ti,rotrBH:_i,rotrBL:Li,rotr32H:Ri,rotr32L:zi,rotlSH:Ci,rotlSL:Ki,rotlBH:Mi,rotlBL:Pi,add:Fi,add3L:Di,add3H:Ni,add4L:qi,add4H:Ui,add5H:Oi,add5L:$i};var G=Hi;const[Wi,Vi]=(()=>G.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))))(),ae=new Uint32Array(80),ce=new Uint32Array(80);class ji extends so{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:r,Bl:s,Ch:o,Cl:i,Dh:u,Dl:a,Eh:l,El:d,Fh:f,Fl:A,Gh:I,Gl:b,Hh:h,Hl:p}=this;return[t,e,r,s,o,i,u,a,l,d,f,A,I,b,h,p]}set(t,e,r,s,o,i,u,a,l,d,f,A,I,b,h,p){this.Ah=t|0,this.Al=e|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=u|0,this.Dl=a|0,this.Eh=l|0,this.El=d|0,this.Fh=f|0,this.Fl=A|0,this.Gh=I|0,this.Gl=b|0,this.Hh=h|0,this.Hl=p|0}process(t,e){for(let S=0;S<16;S++,e+=4)ae[S]=t.getUint32(e),ce[S]=t.getUint32(e+=4);for(let S=16;S<80;S++){const H=ae[S-15]|0,K=ce[S-15]|0,M=G.rotrSH(H,K,1)^G.rotrSH(H,K,8)^G.shrSH(H,K,7),$=G.rotrSL(H,K,1)^G.rotrSL(H,K,8)^G.shrSL(H,K,7),D=ae[S-2]|0,at=ce[S-2]|0,X=G.rotrSH(D,at,19)^G.rotrBH(D,at,61)^G.shrSH(D,at,6),J=G.rotrSL(D,at,19)^G.rotrBL(D,at,61)^G.shrSL(D,at,6),mt=G.add4L($,J,ce[S-7],ce[S-16]),yt=G.add4H(mt,M,X,ae[S-7],ae[S-16]);ae[S]=yt|0,ce[S]=mt|0}let{Ah:r,Al:s,Bh:o,Bl:i,Ch:u,Cl:a,Dh:l,Dl:d,Eh:f,El:A,Fh:I,Fl:b,Gh:h,Gl:p,Hh:k,Hl:B}=this;for(let S=0;S<80;S++){const H=G.rotrSH(f,A,14)^G.rotrSH(f,A,18)^G.rotrBH(f,A,41),K=G.rotrSL(f,A,14)^G.rotrSL(f,A,18)^G.rotrBL(f,A,41),M=f&I^~f&h,$=A&b^~A&p,D=G.add5L(B,K,$,Vi[S],ce[S]),at=G.add5H(D,k,H,M,Wi[S],ae[S]),X=D|0,J=G.rotrSH(r,s,28)^G.rotrBH(r,s,34)^G.rotrBH(r,s,39),mt=G.rotrSL(r,s,28)^G.rotrBL(r,s,34)^G.rotrBL(r,s,39),yt=r&o^r&u^o&u,R=s&i^s&a^i&a;k=h|0,B=p|0,h=I|0,p=b|0,I=f|0,b=A|0,{h:f,l:A}=G.add(l|0,d|0,at|0,X|0),l=u|0,d=a|0,u=o|0,a=i|0,o=r|0,i=s|0;const y=G.add3L(X,mt,R);r=G.add3H(y,at,J,yt),s=y|0}({h:r,l:s}=G.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:i}=G.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:u,l:a}=G.add(this.Ch|0,this.Cl|0,u|0,a|0),{h:l,l:d}=G.add(this.Dh|0,this.Dl|0,l|0,d|0),{h:f,l:A}=G.add(this.Eh|0,this.El|0,f|0,A|0),{h:I,l:b}=G.add(this.Fh|0,this.Fl|0,I|0,b|0),{h,l:p}=G.add(this.Gh|0,this.Gl|0,h|0,p|0),{h:k,l:B}=G.add(this.Hh|0,this.Hl|0,k|0,B|0),this.set(r,s,o,i,u,a,l,d,f,A,I,b,h,p,k,B)}roundClean(){ae.fill(0),ce.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Gi=no(()=>new ji);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Zr=BigInt(0),Fn=BigInt(1),Zi=BigInt(2);function Te(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function nn(n){if(!Te(n))throw new Error("Uint8Array expected")}function oe(n,t){if(typeof t!="boolean")throw new Error(`${n} must be valid boolean, got "${t}".`)}const Yi=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function _e(n){nn(n);let t="";for(let e=0;e<n.length;e++)t+=Yi[n[e]];return t}function io(n){const t=n.toString(16);return t.length&1?`0${t}`:t}function Yr(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}const ne={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Is(n){if(n>=ne._0&&n<=ne._9)return n-ne._0;if(n>=ne._A&&n<=ne._F)return n-(ne._A-10);if(n>=ne._a&&n<=ne._f)return n-(ne._a-10)}function qe(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const t=n.length,e=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){const i=Is(n.charCodeAt(o)),u=Is(n.charCodeAt(o+1));if(i===void 0||u===void 0){const a=n[o]+n[o+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+o)}r[s]=i*16+u}return r}function ve(n){return Yr(_e(n))}function De(n){return nn(n),Yr(_e(Uint8Array.from(n).reverse()))}function Ue(n,t){return qe(n.toString(16).padStart(t*2,"0"))}function Ye(n,t){return Ue(n,t).reverse()}function Qi(n){return qe(io(n))}function wt(n,t,e){let r;if(typeof t=="string")try{r=qe(t)}catch(o){throw new Error(`${n} must be valid hex string, got "${t}". Cause: ${o}`)}else if(Te(t))r=Uint8Array.from(t);else throw new Error(`${n} must be hex string or Uint8Array`);const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(`${n} expected ${e} bytes, got ${s}`);return r}function Le(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];nn(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const o=n[r];e.set(o,s),s+=o.length}return e}function Xi(n,t){if(n.length!==t.length)return!1;let e=0;for(let r=0;r<n.length;r++)e|=n[r]^t[r];return e===0}function Ji(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}const zr=n=>typeof n=="bigint"&&Zr<=n;function Dn(n,t,e){return zr(n)&&zr(t)&&zr(e)&&t<=n&&n<e}function Vt(n,t,e,r){if(!Dn(t,e,r))throw new Error(`expected valid ${n}: ${e} <= n < ${r}, got ${typeof t} ${t}`)}function ta(n){let t;for(t=0;n>Zr;n>>=Fn,t+=1);return t}function ea(n,t){return n>>BigInt(t)&Fn}function na(n,t,e){return n|(e?Fn:Zr)<<BigInt(t)}const Qr=n=>(Zi<<BigInt(n-1))-Fn,Cr=n=>new Uint8Array(n),Bs=n=>Uint8Array.from(n);function ao(n,t,e){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Cr(n),s=Cr(n),o=0;const i=()=>{r.fill(1),s.fill(0),o=0},u=(...f)=>e(s,r,...f),a=(f=Cr())=>{s=u(Bs([0]),f),r=u(),f.length!==0&&(s=u(Bs([1]),f),r=u())},l=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const A=[];for(;f<t;){r=u();const I=r.slice();A.push(I),f+=r.length}return Le(...A)};return(f,A)=>{i(),a(f);let I;for(;!(I=A(l()));)a();return i(),I}}const ra={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||Te(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,t)=>t.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function Oe(n,t,e={}){const r=(s,o,i)=>{const u=ra[o];if(typeof u!="function")throw new Error(`Invalid validator "${o}", expected function`);const a=n[s];if(!(i&&a===void 0)&&!u(a,n))throw new Error(`Invalid param ${String(s)}=${a} (${typeof a}), expected ${o}`)};for(const[s,o]of Object.entries(t))r(s,o,!1);for(const[s,o]of Object.entries(e))r(s,o,!0);return n}const sa=()=>{throw new Error("not implemented")};function Qe(n){const t=new WeakMap;return(e,...r)=>{const s=t.get(e);if(s!==void 0)return s;const o=n(e,...r);return t.set(e,o),o}}var oa=Object.freeze(Object.defineProperty({__proto__:null,isBytes:Te,abytes:nn,abool:oe,bytesToHex:_e,numberToHexUnpadded:io,hexToNumber:Yr,hexToBytes:qe,bytesToNumberBE:ve,bytesToNumberLE:De,numberToBytesBE:Ue,numberToBytesLE:Ye,numberToVarBytesBE:Qi,ensureBytes:wt,concatBytes:Le,equalBytes:Xi,utf8ToBytes:Ji,inRange:Dn,aInRange:Vt,bitLen:ta,bitGet:ea,bitSet:na,bitMask:Qr,createHmacDrbg:ao,validateObject:Oe,notImplemented:sa,memoized:Qe},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const kt=BigInt(0),dt=BigInt(1),ye=BigInt(2),ia=BigInt(3),qr=BigInt(4),vs=BigInt(5),Es=BigInt(8);BigInt(9);BigInt(16);function it(n,t){const e=n%t;return e>=kt?e:t+e}function aa(n,t,e){if(e<=kt||t<kt)throw new Error("Expected power/modulo > 0");if(e===dt)return kt;let r=dt;for(;t>kt;)t&dt&&(r=r*n%e),n=n*n%e,t>>=dt;return r}function ft(n,t,e){let r=n;for(;t-- >kt;)r*=r,r%=e;return r}function Ur(n,t){if(n===kt||t<=kt)throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);let e=it(n,t),r=t,s=kt,o=dt;for(;e!==kt;){const u=r/e,a=r%e,l=s-o*u;r=e,e=a,s=o,o=l}if(r!==dt)throw new Error("invert: does not exist");return it(s,t)}function ca(n){const t=(n-dt)/ye;let e,r,s;for(e=n-dt,r=0;e%ye===kt;e/=ye,r++);for(s=ye;s<n&&aa(s,t,n)!==n-dt;s++);if(r===1){const i=(n+dt)/qr;return function(a,l){const d=a.pow(l,i);if(!a.eql(a.sqr(d),l))throw new Error("Cannot find square root");return d}}const o=(e+dt)/ye;return function(u,a){if(u.pow(a,t)===u.neg(u.ONE))throw new Error("Cannot find square root");let l=r,d=u.pow(u.mul(u.ONE,s),e),f=u.pow(a,o),A=u.pow(a,e);for(;!u.eql(A,u.ONE);){if(u.eql(A,u.ZERO))return u.ZERO;let I=1;for(let h=u.sqr(A);I<l&&!u.eql(h,u.ONE);I++)h=u.sqr(h);const b=u.pow(d,dt<<BigInt(l-I-1));d=u.sqr(b),f=u.mul(f,b),A=u.mul(A,d),l=I}return f}}function ua(n){if(n%qr===ia){const t=(n+dt)/qr;return function(r,s){const o=r.pow(s,t);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(n%Es===vs){const t=(n-vs)/Es;return function(r,s){const o=r.mul(s,ye),i=r.pow(o,t),u=r.mul(s,i),a=r.mul(r.mul(u,ye),i),l=r.mul(u,r.sub(a,r.ONE));if(!r.eql(r.sqr(l),s))throw new Error("Cannot find square root");return l}}return ca(n)}const la=(n,t)=>(it(n,t)&dt)===dt,da=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function fa(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=da.reduce((r,s)=>(r[s]="function",r),t);return Oe(n,e)}function ha(n,t,e){if(e<kt)throw new Error("Expected power > 0");if(e===kt)return n.ONE;if(e===dt)return t;let r=n.ONE,s=t;for(;e>kt;)e&dt&&(r=n.mul(r,s)),s=n.sqr(s),e>>=dt;return r}function ga(n,t){const e=new Array(t.length),r=t.reduce((o,i,u)=>n.is0(i)?o:(e[u]=o,n.mul(o,i)),n.ONE),s=n.inv(r);return t.reduceRight((o,i,u)=>n.is0(i)?o:(e[u]=n.mul(o,e[u]),n.mul(o,i)),s),e}function co(n,t){const e=t!==void 0?t:n.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function uo(n,t,e=!1,r={}){if(n<=kt)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:s,nByteLength:o}=co(n,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=ua(n),u=Object.freeze({ORDER:n,BITS:s,BYTES:o,MASK:Qr(s),ZERO:kt,ONE:dt,create:a=>it(a,n),isValid:a=>{if(typeof a!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof a}`);return kt<=a&&a<n},is0:a=>a===kt,isOdd:a=>(a&dt)===dt,neg:a=>it(-a,n),eql:(a,l)=>a===l,sqr:a=>it(a*a,n),add:(a,l)=>it(a+l,n),sub:(a,l)=>it(a-l,n),mul:(a,l)=>it(a*l,n),pow:(a,l)=>ha(u,a,l),div:(a,l)=>it(a*Ur(l,n),n),sqrN:a=>a*a,addN:(a,l)=>a+l,subN:(a,l)=>a-l,mulN:(a,l)=>a*l,inv:a=>Ur(a,n),sqrt:r.sqrt||(a=>i(u,a)),invertBatch:a=>ga(u,a),cmov:(a,l,d)=>d?l:a,toBytes:a=>e?Ye(a,o):Ue(a,o),fromBytes:a=>{if(a.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${a.length}`);return e?De(a):ve(a)}});return Object.freeze(u)}function lo(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function fo(n){const t=lo(n);return t+Math.ceil(t/2)}function pa(n,t,e=!1){const r=n.length,s=lo(t),o=fo(t);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const i=e?ve(n):De(n),u=it(i,t-dt)+dt;return e?Ye(u,s):Ue(u,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ma=BigInt(0),Kr=BigInt(1),Mr=new WeakMap,Ts=new WeakMap;function ho(n,t){const e=(o,i)=>{const u=i.negate();return o?u:i},r=o=>{if(!Number.isSafeInteger(o)||o<=0||o>t)throw new Error(`Wrong window size=${o}, should be [1..${t}]`)},s=o=>{r(o);const i=Math.ceil(t/o)+1,u=2**(o-1);return{windows:i,windowSize:u}};return{constTimeNegate:e,unsafeLadder(o,i){let u=n.ZERO,a=o;for(;i>ma;)i&Kr&&(u=u.add(a)),a=a.double(),i>>=Kr;return u},precomputeWindow(o,i){const{windows:u,windowSize:a}=s(i),l=[];let d=o,f=d;for(let A=0;A<u;A++){f=d,l.push(f);for(let I=1;I<a;I++)f=f.add(d),l.push(f);d=f.double()}return l},wNAF(o,i,u){const{windows:a,windowSize:l}=s(o);let d=n.ZERO,f=n.BASE;const A=BigInt(2**o-1),I=2**o,b=BigInt(o);for(let h=0;h<a;h++){const p=h*l;let k=Number(u&A);u>>=b,k>l&&(k-=I,u+=Kr);const B=p,S=p+Math.abs(k)-1,H=h%2!==0,K=k<0;k===0?f=f.add(e(H,i[B])):d=d.add(e(K,i[S]))}return{p:d,f}},wNAFCached(o,i,u){const a=Ts.get(o)||1;let l=Mr.get(o);return l||(l=this.precomputeWindow(o,a),a!==1&&Mr.set(o,u(l))),this.wNAF(a,l,i)},setWindowSize(o,i){r(i),Ts.set(o,i),Mr.delete(o)}}}function Xr(n){return fa(n.Fp),Oe(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...co(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Zt=BigInt(0),Kt=BigInt(1),hn=BigInt(2),ya=BigInt(8),ba={zip215:!0};function wa(n){const t=Xr(n);return Oe(n,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function xa(n){const t=wa(n),{Fp:e,n:r,prehash:s,hash:o,randomBytes:i,nByteLength:u,h:a}=t,l=hn<<BigInt(u*8)-Kt,d=e.create,f=t.uvRatio||((y,m)=>{try{return{isValid:!0,value:e.sqrt(y*e.inv(m))}}catch{return{isValid:!1,value:Zt}}}),A=t.adjustScalarBytes||(y=>y),I=t.domain||((y,m,E)=>{if(oe("phflag",E),m.length||E)throw new Error("Contexts/pre-hash are not supported");return y});function b(y,m){Vt("coordinate "+y,m,Zt,l)}function h(y){if(!(y instanceof B))throw new Error("ExtendedPoint expected")}const p=Qe((y,m)=>{const{ex:E,ey:L,ez:q}=y,O=y.is0();m==null&&(m=O?ya:e.inv(q));const W=d(E*m),et=d(L*m),Y=d(q*m);if(O)return{x:Zt,y:Kt};if(Y!==Kt)throw new Error("invZ was invalid");return{x:W,y:et}}),k=Qe(y=>{const{a:m,d:E}=t;if(y.is0())throw new Error("bad point: ZERO");const{ex:L,ey:q,ez:O,et:W}=y,et=d(L*L),Y=d(q*q),nt=d(O*O),ct=d(nt*nt),ut=d(et*m),zt=d(nt*d(ut+Y)),xt=d(ct+d(E*d(et*Y)));if(zt!==xt)throw new Error("bad point: equation left != right (1)");const bt=d(L*q),Gt=d(O*W);if(bt!==Gt)throw new Error("bad point: equation left != right (2)");return!0});class B{constructor(m,E,L,q){this.ex=m,this.ey=E,this.ez=L,this.et=q,b("x",m),b("y",E),b("z",L),b("t",q),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(m){if(m instanceof B)throw new Error("extended point not allowed");const{x:E,y:L}=m||{};return b("x",E),b("y",L),new B(E,L,Kt,d(E*L))}static normalizeZ(m){const E=e.invertBatch(m.map(L=>L.ez));return m.map((L,q)=>L.toAffine(E[q])).map(B.fromAffine)}_setWindowSize(m){K.setWindowSize(this,m)}assertValidity(){k(this)}equals(m){h(m);const{ex:E,ey:L,ez:q}=this,{ex:O,ey:W,ez:et}=m,Y=d(E*et),nt=d(O*q),ct=d(L*et),ut=d(W*q);return Y===nt&&ct===ut}is0(){return this.equals(B.ZERO)}negate(){return new B(d(-this.ex),this.ey,this.ez,d(-this.et))}double(){const{a:m}=t,{ex:E,ey:L,ez:q}=this,O=d(E*E),W=d(L*L),et=d(hn*d(q*q)),Y=d(m*O),nt=E+L,ct=d(d(nt*nt)-O-W),ut=Y+W,zt=ut-et,xt=Y-W,bt=d(ct*zt),Gt=d(ut*xt),Ct=d(ct*xt),It=d(zt*ut);return new B(bt,Gt,It,Ct)}add(m){h(m);const{a:E,d:L}=t,{ex:q,ey:O,ez:W,et}=this,{ex:Y,ey:nt,ez:ct,et:ut}=m;if(E===BigInt(-1)){const fs=d((O-q)*(nt+Y)),hs=d((O+q)*(nt-Y)),Tr=d(hs-fs);if(Tr===Zt)return this.double();const gs=d(W*hn*ut),ps=d(et*hn*ct),ms=ps+gs,ys=hs+fs,bs=ps-gs,Oo=d(ms*Tr),Ho=d(ys*bs),Wo=d(ms*bs),Vo=d(Tr*ys);return new B(Oo,Ho,Vo,Wo)}const zt=d(q*Y),xt=d(O*nt),bt=d(et*L*ut),Gt=d(W*ct),Ct=d((q+O)*(Y+nt)-zt-xt),It=Gt-bt,ee=Gt+bt,Ve=d(xt-E*zt),un=d(Ct*It),qo=d(ee*Ve),Uo=d(Ct*Ve),$o=d(It*ee);return new B(un,qo,$o,Uo)}subtract(m){return this.add(m.negate())}wNAF(m){return K.wNAFCached(this,m,B.normalizeZ)}multiply(m){const E=m;Vt("scalar",E,Kt,r);const{p:L,f:q}=this.wNAF(E);return B.normalizeZ([L,q])[0]}multiplyUnsafe(m){const E=m;return Vt("scalar",E,Zt,r),E===Zt?H:this.equals(H)||E===Kt?this:this.equals(S)?this.wNAF(E).p:K.unsafeLadder(this,E)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}isTorsionFree(){return K.unsafeLadder(this,r).is0()}toAffine(m){return p(this,m)}clearCofactor(){const{h:m}=t;return m===Kt?this:this.multiplyUnsafe(m)}static fromHex(m,E=!1){const{d:L,a:q}=t,O=e.BYTES;m=wt("pointHex",m,O),oe("zip215",E);const W=m.slice(),et=m[O-1];W[O-1]=et&-129;const Y=De(W),nt=E?l:e.ORDER;Vt("pointHex.y",Y,Zt,nt);const ct=d(Y*Y),ut=d(ct-Kt),zt=d(L*ct-q);let{isValid:xt,value:bt}=f(ut,zt);if(!xt)throw new Error("Point.fromHex: invalid y coordinate");const Gt=(bt&Kt)===Kt,Ct=(et&128)!==0;if(!E&&bt===Zt&&Ct)throw new Error("Point.fromHex: x=0 and x_0=1");return Ct!==Gt&&(bt=d(-bt)),B.fromAffine({x:bt,y:Y})}static fromPrivateKey(m){return D(m).point}toRawBytes(){const{x:m,y:E}=this.toAffine(),L=Ye(E,e.BYTES);return L[L.length-1]|=m&Kt?128:0,L}toHex(){return _e(this.toRawBytes())}}B.BASE=new B(t.Gx,t.Gy,Kt,d(t.Gx*t.Gy)),B.ZERO=new B(Zt,Kt,Kt,Zt);const{BASE:S,ZERO:H}=B,K=ho(B,u*8);function M(y){return it(y,r)}function $(y){return M(De(y))}function D(y){const m=u;y=wt("private key",y,m);const E=wt("hashed private key",o(y),2*m),L=A(E.slice(0,m)),q=E.slice(m,2*m),O=$(L),W=S.multiply(O),et=W.toRawBytes();return{head:L,prefix:q,scalar:O,point:W,pointBytes:et}}function at(y){return D(y).pointBytes}function X(y=new Uint8Array,...m){const E=Le(...m);return $(o(I(E,wt("context",y),!!s)))}function J(y,m,E={}){y=wt("message",y),s&&(y=s(y));const{prefix:L,scalar:q,pointBytes:O}=D(m),W=X(E.context,L,y),et=S.multiply(W).toRawBytes(),Y=X(E.context,et,O,y),nt=M(W+Y*q);Vt("signature.s",nt,Zt,r);const ct=Le(et,Ye(nt,e.BYTES));return wt("result",ct,u*2)}const mt=ba;function yt(y,m,E,L=mt){const{context:q,zip215:O}=L,W=e.BYTES;y=wt("signature",y,2*W),m=wt("message",m),O!==void 0&&oe("zip215",O),s&&(m=s(m));const et=De(y.slice(W,2*W));let Y,nt,ct;try{Y=B.fromHex(E,O),nt=B.fromHex(y.slice(0,W),O),ct=S.multiplyUnsafe(et)}catch{return!1}if(!O&&Y.isSmallOrder())return!1;const ut=X(q,nt.toRawBytes(),Y.toRawBytes(),m);return nt.add(Y.multiplyUnsafe(ut)).subtract(ct).clearCofactor().equals(B.ZERO)}return S._setWindowSize(8),{CURVE:t,getPublicKey:at,sign:J,verify:yt,ExtendedPoint:B,utils:{getExtendedPublicKey:D,randomPrivateKey:()=>i(e.BYTES),precompute(y=8,m=B.BASE){return m._setWindowSize(y),m.multiply(BigInt(3)),m}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Jr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),_s=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Aa=BigInt(1),Ls=BigInt(2);BigInt(3);const Sa=BigInt(5),ka=BigInt(8);function Ia(n){const t=BigInt(10),e=BigInt(20),r=BigInt(40),s=BigInt(80),o=Jr,u=n*n%o*n%o,a=ft(u,Ls,o)*u%o,l=ft(a,Aa,o)*n%o,d=ft(l,Sa,o)*l%o,f=ft(d,t,o)*d%o,A=ft(f,e,o)*f%o,I=ft(A,r,o)*A%o,b=ft(I,s,o)*I%o,h=ft(b,s,o)*I%o,p=ft(h,t,o)*d%o;return{pow_p_5_8:ft(p,Ls,o)*n%o,b2:u}}function Ba(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}function va(n,t){const e=Jr,r=it(t*t*t,e),s=it(r*r*t,e),o=Ia(n*s).pow_p_5_8;let i=it(n*r*o,e);const u=it(t*i*i,e),a=i,l=it(i*_s,e),d=u===n,f=u===it(-n,e),A=u===it(-n*_s,e);return d&&(i=a),(f||A)&&(i=l),la(i,e)&&(i=it(-i,e)),{isValid:d||f,value:i}}const Ea=(()=>uo(Jr,void 0,!0))(),Ta=(()=>({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Ea,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:ka,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Gi,randomBytes:ro,adjustScalarBytes:Ba,uvRatio:va}))(),rn=(()=>xa(Ta))(),_a=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ue=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),le=new Uint32Array(64);class La extends so{constructor(){super(64,32,8,!1),this.A=ue[0]|0,this.B=ue[1]|0,this.C=ue[2]|0,this.D=ue[3]|0,this.E=ue[4]|0,this.F=ue[5]|0,this.G=ue[6]|0,this.H=ue[7]|0}get(){const{A:t,B:e,C:r,D:s,E:o,F:i,G:u,H:a}=this;return[t,e,r,s,o,i,u,a]}set(t,e,r,s,o,i,u,a){this.A=t|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=u|0,this.H=a|0}process(t,e){for(let f=0;f<16;f++,e+=4)le[f]=t.getUint32(e,!1);for(let f=16;f<64;f++){const A=le[f-15],I=le[f-2],b=Xt(A,7)^Xt(A,18)^A>>>3,h=Xt(I,17)^Xt(I,19)^I>>>10;le[f]=h+le[f-7]+b+le[f-16]|0}let{A:r,B:s,C:o,D:i,E:u,F:a,G:l,H:d}=this;for(let f=0;f<64;f++){const A=Xt(u,6)^Xt(u,11)^Xt(u,25),I=d+A+Ai(u,a,l)+_a[f]+le[f]|0,h=(Xt(r,2)^Xt(r,13)^Xt(r,22))+Si(r,s,o)|0;d=l,l=a,a=u,u=i+I|0,i=o,o=s,s=r,r=I+h|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,u=u+this.E|0,a=a+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(r,s,o,i,u,a,l,d)}roundClean(){le.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const $r=no(()=>new La);class Ra extends TypeError{constructor(t,e){let r;const{message:s,explanation:o,...i}=t,{path:u}=t,a=u.length===0?s:`At path: ${u.join(".")} -- ${s}`;super(o??a),o!=null&&(this.cause=a),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>r??(r=[t,...e()])}}function za(n){return sn(n)&&typeof n[Symbol.iterator]=="function"}function sn(n){return typeof n=="object"&&n!=null}function En(n){return sn(n)&&!Array.isArray(n)}function Qt(n){return typeof n=="symbol"?n.toString():typeof n=="string"?JSON.stringify(n):`${n}`}function Ca(n){const{done:t,value:e}=n.next();return t?void 0:e}function Ka(n,t,e,r){if(n===!0)return;n===!1?n={}:typeof n=="string"&&(n={message:n});const{path:s,branch:o}=t,{type:i}=e,{refinement:u,message:a=`Expected a value of type \`${i}\`${u?` with refinement \`${u}\``:""}, but received: \`${Qt(r)}\``}=n;return{value:r,type:i,refinement:u,key:s[s.length-1],path:s,branch:o,...n,message:a}}function*Rs(n,t,e,r){za(n)||(n=[n]);for(const s of n){const o=Ka(s,t,e,r);o&&(yield o)}}function*ts(n,t,e={}){const{path:r=[],branch:s=[n],coerce:o=!1,mask:i=!1}=e,u={path:r,branch:s,mask:i};o&&(n=t.coercer(n,u));let a="valid";for(const l of t.validator(n,u))l.explanation=e.message,a="not_valid",yield[l,void 0];for(let[l,d,f]of t.entries(n,u)){const A=ts(d,f,{path:l===void 0?r:[...r,l],branch:l===void 0?s:[...s,d],coerce:o,mask:i,message:e.message});for(const I of A)I[0]?(a=I[0].refinement!=null?"not_refined":"not_valid",yield[I[0],void 0]):o&&(d=I[1],l===void 0?n=d:n instanceof Map?n.set(l,d):n instanceof Set?n.add(d):sn(n)&&(d!==void 0||l in n)&&(n[l]=d))}if(a!=="not_valid")for(const l of t.refiner(n,u))l.explanation=e.message,a="not_refined",yield[l,void 0];a==="valid"&&(yield[void 0,n])}class te{constructor(t){const{type:e,schema:r,validator:s,refiner:o,coercer:i=a=>a,entries:u=function*(){}}=t;this.type=e,this.schema=r,this.entries=u,this.coercer=i,s?this.validator=(a,l)=>{const d=s(a,l);return Rs(d,l,this,a)}:this.validator=()=>[],o?this.refiner=(a,l)=>{const d=o(a,l);return Rs(d,l,this,a)}:this.refiner=()=>[]}assert(t,e){return Ma(t,this,e)}create(t,e){return Xe(t,this,e)}is(t){return go(t,this)}mask(t,e){return Pa(t,this,e)}validate(t,e={}){return on(t,this,e)}}function Ma(n,t,e){const r=on(n,t,{message:e});if(r[0])throw r[0]}function Xe(n,t,e){const r=on(n,t,{coerce:!0,message:e});if(r[0])throw r[0];return r[1]}function Pa(n,t,e){const r=on(n,t,{coerce:!0,mask:!0,message:e});if(r[0])throw r[0];return r[1]}function go(n,t){return!on(n,t)[0]}function on(n,t,e={}){const r=ts(n,t,e),s=Ca(r);if(s[0])return[new Ra(s[0],function*(){for(const i of r)i[0]&&(yield i[0])}),void 0];{const o=s[1];return[void 0,o]}}function Re(n,t){return new te({type:n,schema:null,validator:t})}function Fa(){return Re("any",()=>!0)}function T(n){return new te({type:"array",schema:n,*entries(t){if(n&&Array.isArray(t))for(const[e,r]of t.entries())yield[e,r,n]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||`Expected an array value, but received: ${Qt(t)}`}})}function Jt(){return Re("boolean",n=>typeof n=="boolean")}function es(n){return Re("instance",t=>t instanceof n||`Expected a \`${n.name}\` instance, but received: ${Qt(t)}`)}function lt(n){const t=Qt(n),e=typeof n;return new te({type:"literal",schema:e==="string"||e==="number"||e==="boolean"?n:null,validator(r){return r===n||`Expected the literal \`${t}\`, but received: ${Qt(r)}`}})}function Da(){return Re("never",()=>!1)}function _(n){return new te({...n,validator:(t,e)=>t===null||n.validator(t,e),refiner:(t,e)=>t===null||n.refiner(t,e)})}function g(){return Re("number",n=>typeof n=="number"&&!isNaN(n)||`Expected a number, but received: ${Qt(n)}`)}function U(n){return new te({...n,validator:(t,e)=>t===void 0||n.validator(t,e),refiner:(t,e)=>t===void 0||n.refiner(t,e)})}function po(n,t){return new te({type:"record",schema:null,*entries(e){if(sn(e))for(const r in e){const s=e[r];yield[r,r,n],yield[r,s,t]}},validator(e){return En(e)||`Expected an object, but received: ${Qt(e)}`},coercer(e){return En(e)?{...e}:e}})}function v(){return Re("string",n=>typeof n=="string"||`Expected a string, but received: ${Qt(n)}`)}function ns(n){const t=Da();return new te({type:"tuple",schema:null,*entries(e){if(Array.isArray(e)){const r=Math.max(n.length,e.length);for(let s=0;s<r;s++)yield[s,e[s],n[s]||t]}},validator(e){return Array.isArray(e)||`Expected an array, but received: ${Qt(e)}`},coercer(e){return Array.isArray(e)?e.slice():e}})}function x(n){const t=Object.keys(n);return new te({type:"type",schema:n,*entries(e){if(sn(e))for(const r of t)yield[r,e[r],n[r]]},validator(e){return En(e)||`Expected an object, but received: ${Qt(e)}`},coercer(e){return En(e)?{...e}:e}})}function Rt(n){const t=n.map(e=>e.type).join(" | ");return new te({type:"union",schema:null,coercer(e,r){for(const s of n){const[o,i]=s.validate(e,{coerce:!0,mask:r.mask});if(!o)return i}return e},validator(e,r){const s=[];for(const o of n){const[...i]=ts(e,o,r),[u]=i;if(u[0])for(const[a]of i)a&&s.push(a);else return[]}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${Qt(e)}`,...s]}})}function He(){return Re("unknown",()=>!0)}function an(n,t,e){return new te({...n,coercer:(r,s)=>go(r,t)?n.coercer(e(r,s),s):n.coercer(r,s)})}Ys.v4;Ys.v4;var Na={exports:{}};(function(n){var t=Object.prototype.hasOwnProperty,e="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(e=!1));function s(a,l,d){this.fn=a,this.context=l,this.once=d||!1}function o(a,l,d,f,A){if(typeof d!="function")throw new TypeError("The listener must be a function");var I=new s(d,f||a,A),b=e?e+l:l;return a._events[b]?a._events[b].fn?a._events[b]=[a._events[b],I]:a._events[b].push(I):(a._events[b]=I,a._eventsCount++),a}function i(a,l){--a._eventsCount===0?a._events=new r:delete a._events[l]}function u(){this._events=new r,this._eventsCount=0}u.prototype.eventNames=function(){var l=[],d,f;if(this._eventsCount===0)return l;for(f in d=this._events)t.call(d,f)&&l.push(e?f.slice(1):f);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(d)):l},u.prototype.listeners=function(l){var d=e?e+l:l,f=this._events[d];if(!f)return[];if(f.fn)return[f.fn];for(var A=0,I=f.length,b=new Array(I);A<I;A++)b[A]=f[A].fn;return b},u.prototype.listenerCount=function(l){var d=e?e+l:l,f=this._events[d];return f?f.fn?1:f.length:0},u.prototype.emit=function(l,d,f,A,I,b){var h=e?e+l:l;if(!this._events[h])return!1;var p=this._events[h],k=arguments.length,B,S;if(p.fn){switch(p.once&&this.removeListener(l,p.fn,void 0,!0),k){case 1:return p.fn.call(p.context),!0;case 2:return p.fn.call(p.context,d),!0;case 3:return p.fn.call(p.context,d,f),!0;case 4:return p.fn.call(p.context,d,f,A),!0;case 5:return p.fn.call(p.context,d,f,A,I),!0;case 6:return p.fn.call(p.context,d,f,A,I,b),!0}for(S=1,B=new Array(k-1);S<k;S++)B[S-1]=arguments[S];p.fn.apply(p.context,B)}else{var H=p.length,K;for(S=0;S<H;S++)switch(p[S].once&&this.removeListener(l,p[S].fn,void 0,!0),k){case 1:p[S].fn.call(p[S].context);break;case 2:p[S].fn.call(p[S].context,d);break;case 3:p[S].fn.call(p[S].context,d,f);break;case 4:p[S].fn.call(p[S].context,d,f,A);break;default:if(!B)for(K=1,B=new Array(k-1);K<k;K++)B[K-1]=arguments[K];p[S].fn.apply(p[S].context,B)}}return!0},u.prototype.on=function(l,d,f){return o(this,l,d,f,!1)},u.prototype.once=function(l,d,f){return o(this,l,d,f,!0)},u.prototype.removeListener=function(l,d,f,A){var I=e?e+l:l;if(!this._events[I])return this;if(!d)return i(this,I),this;var b=this._events[I];if(b.fn)b.fn===d&&(!A||b.once)&&(!f||b.context===f)&&i(this,I);else{for(var h=0,p=[],k=b.length;h<k;h++)(b[h].fn!==d||A&&!b[h].once||f&&b[h].context!==f)&&p.push(b[h]);p.length?this._events[I]=p.length===1?p[0]:p:i(this,I)}return this},u.prototype.removeAllListeners=function(l){var d;return l?(d=e?e+l:l,this._events[d]&&i(this,d)):(this._events=new r,this._eventsCount=0),this},u.prototype.off=u.prototype.removeListener,u.prototype.addListener=u.prototype.on,u.prefixed=e,u.EventEmitter=u,n.exports=u})(Na);class mo extends eo{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,mi(t);const r=Gr(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?t.create().update(r).digest():r);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=t.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(t){return vn(this),this.iHash.update(t),this}digestInto(t){vn(this),Pn(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:o,blockLen:i,outputLen:u}=this;return t=t,t.finished=s,t.destroyed=o,t.blockLen=i,t.outputLen=u,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const yo=(n,t,e)=>new mo(n,t).update(e).digest();yo.create=(n,t)=>new mo(n,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function zs(n){n.lowS!==void 0&&oe("lowS",n.lowS),n.prehash!==void 0&&oe("prehash",n.prehash)}function qa(n){const t=Xr(n);Oe(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:s}=t;if(e){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:Ua,hexToBytes:$a}=oa,Be={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(n){const{Err:t}=Be;if(n.length<2||n[0]!==2)throw new t("Invalid signature integer tag");const e=n[1],r=n.subarray(2,e+2);if(!e||r.length!==e)throw new t("Invalid signature integer: wrong length");if(r[0]&128)throw new t("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:Ua(r),l:n.subarray(e+2)}},toSig(n){const{Err:t}=Be,e=typeof n=="string"?$a(n):n;nn(e);let r=e.length;if(r<2||e[0]!=48)throw new t("Invalid signature tag");if(e[1]!==r-2)throw new t("Invalid signature: incorrect length");const{d:s,l:o}=Be._parseInt(e.subarray(2)),{d:i,l:u}=Be._parseInt(o);if(u.length)throw new t("Invalid signature: left bytes after parsing");return{r:s,s:i}},hexFromSig(n){const t=l=>Number.parseInt(l[0],16)&8?"00"+l:l,e=l=>{const d=l.toString(16);return d.length&1?`0${d}`:d},r=t(e(n.s)),s=t(e(n.r)),o=r.length/2,i=s.length/2,u=e(o),a=e(i);return`30${e(i+o+4)}02${a}${s}02${u}${r}`}},fe=BigInt(0),At=BigInt(1);BigInt(2);const Cs=BigInt(3);BigInt(4);function Oa(n){const t=qa(n),{Fp:e}=t,r=t.toBytes||((b,h,p)=>{const k=h.toAffine();return Le(Uint8Array.from([4]),e.toBytes(k.x),e.toBytes(k.y))}),s=t.fromBytes||(b=>{const h=b.subarray(1),p=e.fromBytes(h.subarray(0,e.BYTES)),k=e.fromBytes(h.subarray(e.BYTES,2*e.BYTES));return{x:p,y:k}});function o(b){const{a:h,b:p}=t,k=e.sqr(b),B=e.mul(k,b);return e.add(e.add(B,e.mul(b,h)),p)}if(!e.eql(e.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function i(b){return Dn(b,At,t.n)}function u(b){const{allowedPrivateKeyLengths:h,nByteLength:p,wrapPrivateKey:k,n:B}=t;if(h&&typeof b!="bigint"){if(Te(b)&&(b=_e(b)),typeof b!="string"||!h.includes(b.length))throw new Error("Invalid key");b=b.padStart(p*2,"0")}let S;try{S=typeof b=="bigint"?b:ve(wt("private key",b,p))}catch{throw new Error(`private key must be ${p} bytes, hex or bigint, not ${typeof b}`)}return k&&(S=it(S,B)),Vt("private key",S,At,B),S}function a(b){if(!(b instanceof f))throw new Error("ProjectivePoint expected")}const l=Qe((b,h)=>{const{px:p,py:k,pz:B}=b;if(e.eql(B,e.ONE))return{x:p,y:k};const S=b.is0();h==null&&(h=S?e.ONE:e.inv(B));const H=e.mul(p,h),K=e.mul(k,h),M=e.mul(B,h);if(S)return{x:e.ZERO,y:e.ZERO};if(!e.eql(M,e.ONE))throw new Error("invZ was invalid");return{x:H,y:K}}),d=Qe(b=>{if(b.is0()){if(t.allowInfinityPoint&&!e.is0(b.py))return;throw new Error("bad point: ZERO")}const{x:h,y:p}=b.toAffine();if(!e.isValid(h)||!e.isValid(p))throw new Error("bad point: x or y not FE");const k=e.sqr(p),B=o(h);if(!e.eql(k,B))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class f{constructor(h,p,k){if(this.px=h,this.py=p,this.pz=k,h==null||!e.isValid(h))throw new Error("x required");if(p==null||!e.isValid(p))throw new Error("y required");if(k==null||!e.isValid(k))throw new Error("z required");Object.freeze(this)}static fromAffine(h){const{x:p,y:k}=h||{};if(!h||!e.isValid(p)||!e.isValid(k))throw new Error("invalid affine point");if(h instanceof f)throw new Error("projective point not allowed");const B=S=>e.eql(S,e.ZERO);return B(p)&&B(k)?f.ZERO:new f(p,k,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const p=e.invertBatch(h.map(k=>k.pz));return h.map((k,B)=>k.toAffine(p[B])).map(f.fromAffine)}static fromHex(h){const p=f.fromAffine(s(wt("pointHex",h)));return p.assertValidity(),p}static fromPrivateKey(h){return f.BASE.multiply(u(h))}_setWindowSize(h){I.setWindowSize(this,h)}assertValidity(){d(this)}hasEvenY(){const{y:h}=this.toAffine();if(e.isOdd)return!e.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){a(h);const{px:p,py:k,pz:B}=this,{px:S,py:H,pz:K}=h,M=e.eql(e.mul(p,K),e.mul(S,B)),$=e.eql(e.mul(k,K),e.mul(H,B));return M&&$}negate(){return new f(this.px,e.neg(this.py),this.pz)}double(){const{a:h,b:p}=t,k=e.mul(p,Cs),{px:B,py:S,pz:H}=this;let K=e.ZERO,M=e.ZERO,$=e.ZERO,D=e.mul(B,B),at=e.mul(S,S),X=e.mul(H,H),J=e.mul(B,S);return J=e.add(J,J),$=e.mul(B,H),$=e.add($,$),K=e.mul(h,$),M=e.mul(k,X),M=e.add(K,M),K=e.sub(at,M),M=e.add(at,M),M=e.mul(K,M),K=e.mul(J,K),$=e.mul(k,$),X=e.mul(h,X),J=e.sub(D,X),J=e.mul(h,J),J=e.add(J,$),$=e.add(D,D),D=e.add($,D),D=e.add(D,X),D=e.mul(D,J),M=e.add(M,D),X=e.mul(S,H),X=e.add(X,X),D=e.mul(X,J),K=e.sub(K,D),$=e.mul(X,at),$=e.add($,$),$=e.add($,$),new f(K,M,$)}add(h){a(h);const{px:p,py:k,pz:B}=this,{px:S,py:H,pz:K}=h;let M=e.ZERO,$=e.ZERO,D=e.ZERO;const at=t.a,X=e.mul(t.b,Cs);let J=e.mul(p,S),mt=e.mul(k,H),yt=e.mul(B,K),R=e.add(p,k),y=e.add(S,H);R=e.mul(R,y),y=e.add(J,mt),R=e.sub(R,y),y=e.add(p,B);let m=e.add(S,K);return y=e.mul(y,m),m=e.add(J,yt),y=e.sub(y,m),m=e.add(k,B),M=e.add(H,K),m=e.mul(m,M),M=e.add(mt,yt),m=e.sub(m,M),D=e.mul(at,y),M=e.mul(X,yt),D=e.add(M,D),M=e.sub(mt,D),D=e.add(mt,D),$=e.mul(M,D),mt=e.add(J,J),mt=e.add(mt,J),yt=e.mul(at,yt),y=e.mul(X,y),mt=e.add(mt,yt),yt=e.sub(J,yt),yt=e.mul(at,yt),y=e.add(y,yt),J=e.mul(mt,y),$=e.add($,J),J=e.mul(m,y),M=e.mul(R,M),M=e.sub(M,J),J=e.mul(R,mt),D=e.mul(m,D),D=e.add(D,J),new f(M,$,D)}subtract(h){return this.add(h.negate())}is0(){return this.equals(f.ZERO)}wNAF(h){return I.wNAFCached(this,h,f.normalizeZ)}multiplyUnsafe(h){Vt("scalar",h,fe,t.n);const p=f.ZERO;if(h===fe)return p;if(h===At)return this;const{endo:k}=t;if(!k)return I.unsafeLadder(this,h);let{k1neg:B,k1:S,k2neg:H,k2:K}=k.splitScalar(h),M=p,$=p,D=this;for(;S>fe||K>fe;)S&At&&(M=M.add(D)),K&At&&($=$.add(D)),D=D.double(),S>>=At,K>>=At;return B&&(M=M.negate()),H&&($=$.negate()),$=new f(e.mul($.px,k.beta),$.py,$.pz),M.add($)}multiply(h){const{endo:p,n:k}=t;Vt("scalar",h,At,k);let B,S;if(p){const{k1neg:H,k1:K,k2neg:M,k2:$}=p.splitScalar(h);let{p:D,f:at}=this.wNAF(K),{p:X,f:J}=this.wNAF($);D=I.constTimeNegate(H,D),X=I.constTimeNegate(M,X),X=new f(e.mul(X.px,p.beta),X.py,X.pz),B=D.add(X),S=at.add(J)}else{const{p:H,f:K}=this.wNAF(h);B=H,S=K}return f.normalizeZ([B,S])[0]}multiplyAndAddUnsafe(h,p,k){const B=f.BASE,S=(K,M)=>M===fe||M===At||!K.equals(B)?K.multiplyUnsafe(M):K.multiply(M),H=S(this,p).add(S(h,k));return H.is0()?void 0:H}toAffine(h){return l(this,h)}isTorsionFree(){const{h,isTorsionFree:p}=t;if(h===At)return!0;if(p)return p(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:p}=t;return h===At?this:p?p(f,this):this.multiplyUnsafe(t.h)}toRawBytes(h=!0){return oe("isCompressed",h),this.assertValidity(),r(f,this,h)}toHex(h=!0){return oe("isCompressed",h),_e(this.toRawBytes(h))}}f.BASE=new f(t.Gx,t.Gy,e.ONE),f.ZERO=new f(e.ZERO,e.ONE,e.ZERO);const A=t.nBitLength,I=ho(f,t.endo?Math.ceil(A/2):A);return{CURVE:t,ProjectivePoint:f,normPrivateKeyToScalar:u,weierstrassEquation:o,isWithinCurveOrder:i}}function Ha(n){const t=Xr(n);return Oe(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function Wa(n){const t=Ha(n),{Fp:e,n:r}=t,s=e.BYTES+1,o=2*e.BYTES+1;function i(R){return it(R,r)}function u(R){return Ur(R,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:l,weierstrassEquation:d,isWithinCurveOrder:f}=Oa({...t,toBytes(R,y,m){const E=y.toAffine(),L=e.toBytes(E.x),q=Le;return oe("isCompressed",m),m?q(Uint8Array.from([y.hasEvenY()?2:3]),L):q(Uint8Array.from([4]),L,e.toBytes(E.y))},fromBytes(R){const y=R.length,m=R[0],E=R.subarray(1);if(y===s&&(m===2||m===3)){const L=ve(E);if(!Dn(L,At,e.ORDER))throw new Error("Point is not on curve");const q=d(L);let O;try{O=e.sqrt(q)}catch(Y){const nt=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+nt)}const W=(O&At)===At;return(m&1)===1!==W&&(O=e.neg(O)),{x:L,y:O}}else if(y===o&&m===4){const L=e.fromBytes(E.subarray(0,e.BYTES)),q=e.fromBytes(E.subarray(e.BYTES,2*e.BYTES));return{x:L,y:q}}else throw new Error(`Point of length ${y} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),A=R=>_e(Ue(R,t.nByteLength));function I(R){const y=r>>At;return R>y}function b(R){return I(R)?i(-R):R}const h=(R,y,m)=>ve(R.slice(y,m));class p{constructor(y,m,E){this.r=y,this.s=m,this.recovery=E,this.assertValidity()}static fromCompact(y){const m=t.nByteLength;return y=wt("compactSignature",y,m*2),new p(h(y,0,m),h(y,m,2*m))}static fromDER(y){const{r:m,s:E}=Be.toSig(wt("DER",y));return new p(m,E)}assertValidity(){Vt("r",this.r,At,r),Vt("s",this.s,At,r)}addRecoveryBit(y){return new p(this.r,this.s,y)}recoverPublicKey(y){const{r:m,s:E,recovery:L}=this,q=M(wt("msgHash",y));if(L==null||![0,1,2,3].includes(L))throw new Error("recovery id invalid");const O=L===2||L===3?m+t.n:m;if(O>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const W=(L&1)===0?"02":"03",et=a.fromHex(W+A(O)),Y=u(O),nt=i(-q*Y),ct=i(E*Y),ut=a.BASE.multiplyAndAddUnsafe(et,nt,ct);if(!ut)throw new Error("point at infinify");return ut.assertValidity(),ut}hasHighS(){return I(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return qe(this.toDERHex())}toDERHex(){return Be.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return qe(this.toCompactHex())}toCompactHex(){return A(this.r)+A(this.s)}}const k={isValidPrivateKey(R){try{return l(R),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const R=fo(t.n);return pa(t.randomBytes(R),t.n)},precompute(R=8,y=a.BASE){return y._setWindowSize(R),y.multiply(BigInt(3)),y}};function B(R,y=!0){return a.fromPrivateKey(R).toRawBytes(y)}function S(R){const y=Te(R),m=typeof R=="string",E=(y||m)&&R.length;return y?E===s||E===o:m?E===2*s||E===2*o:R instanceof a}function H(R,y,m=!0){if(S(R))throw new Error("first arg must be private key");if(!S(y))throw new Error("second arg must be public key");return a.fromHex(y).multiply(l(R)).toRawBytes(m)}const K=t.bits2int||function(R){const y=ve(R),m=R.length*8-t.nBitLength;return m>0?y>>BigInt(m):y},M=t.bits2int_modN||function(R){return i(K(R))},$=Qr(t.nBitLength);function D(R){return Vt(`num < 2^${t.nBitLength}`,R,fe,$),Ue(R,t.nByteLength)}function at(R,y,m=X){if(["recovered","canonical"].some(xt=>xt in m))throw new Error("sign() legacy options not supported");const{hash:E,randomBytes:L}=t;let{lowS:q,prehash:O,extraEntropy:W}=m;q==null&&(q=!0),R=wt("msgHash",R),zs(m),O&&(R=wt("prehashed msgHash",E(R)));const et=M(R),Y=l(y),nt=[D(Y),D(et)];if(W!=null&&W!==!1){const xt=W===!0?L(e.BYTES):W;nt.push(wt("extraEntropy",xt))}const ct=Le(...nt),ut=et;function zt(xt){const bt=K(xt);if(!f(bt))return;const Gt=u(bt),Ct=a.BASE.multiply(bt).toAffine(),It=i(Ct.x);if(It===fe)return;const ee=i(Gt*i(ut+It*Y));if(ee===fe)return;let Ve=(Ct.x===It?0:2)|Number(Ct.y&At),un=ee;return q&&I(ee)&&(un=b(ee),Ve^=1),new p(It,un,Ve)}return{seed:ct,k2sig:zt}}const X={lowS:t.lowS,prehash:!1},J={lowS:t.lowS,prehash:!1};function mt(R,y,m=X){const{seed:E,k2sig:L}=at(R,y,m),q=t;return ao(q.hash.outputLen,q.nByteLength,q.hmac)(E,L)}a.BASE._setWindowSize(8);function yt(R,y,m,E=J){var Ct;const L=R;if(y=wt("msgHash",y),m=wt("publicKey",m),"strict"in E)throw new Error("options.strict was renamed to lowS");zs(E);const{lowS:q,prehash:O}=E;let W,et;try{if(typeof L=="string"||Te(L))try{W=p.fromDER(L)}catch(It){if(!(It instanceof Be.Err))throw It;W=p.fromCompact(L)}else if(typeof L=="object"&&typeof L.r=="bigint"&&typeof L.s=="bigint"){const{r:It,s:ee}=L;W=new p(It,ee)}else throw new Error("PARSE");et=a.fromHex(m)}catch(It){if(It.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(q&&W.hasHighS())return!1;O&&(y=t.hash(y));const{r:Y,s:nt}=W,ct=M(y),ut=u(nt),zt=i(ct*ut),xt=i(Y*ut),bt=(Ct=a.BASE.multiplyAndAddUnsafe(et,zt,xt))==null?void 0:Ct.toAffine();return bt?i(bt.x)===Y:!1}return{CURVE:t,getPublicKey:B,getSharedSecret:H,sign:mt,verify:yt,ProjectivePoint:a,Signature:p,utils:k}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Va(n){return{hash:n,hmac:(t,...e)=>yo(n,t,wi(...e)),randomBytes:ro}}function ja(n,t){const e=r=>Wa({...n,...Va(r)});return Object.freeze({...e(t),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const bo=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Ks=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ga=BigInt(1),Or=BigInt(2),Ms=(n,t)=>(n+t/Or)/t;function Za(n){const t=bo,e=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),u=BigInt(44),a=BigInt(88),l=n*n*n%t,d=l*l*n%t,f=ft(d,e,t)*d%t,A=ft(f,e,t)*d%t,I=ft(A,Or,t)*l%t,b=ft(I,s,t)*I%t,h=ft(b,o,t)*b%t,p=ft(h,u,t)*h%t,k=ft(p,a,t)*p%t,B=ft(k,u,t)*h%t,S=ft(B,e,t)*d%t,H=ft(S,i,t)*b%t,K=ft(H,r,t)*l%t,M=ft(K,Or,t);if(!Hr.eql(Hr.sqr(M),n))throw new Error("Cannot find square root");return M}const Hr=uo(bo,void 0,void 0,{sqrt:Za}),rs=ja({a:BigInt(0),b:BigInt(7),Fp:Hr,n:Ks,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const t=Ks,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Ga*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,i=BigInt("0x100000000000000000000000000000000"),u=Ms(o*n,t),a=Ms(-r*n,t);let l=it(n-u*e-a*s,t),d=it(-u*r-a*o,t);const f=l>i,A=d>i;if(f&&(l=t-l),A&&(d=t-d),l>i||d>i)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:f,k1:l,k2neg:A,k2:d}}}},$r);BigInt(0);rs.ProjectivePoint;rn.utils.randomPrivateKey;rn.getPublicKey;function Ps(n){try{return rn.ExtendedPoint.fromHex(n),!0}catch{return!1}}const Ya=(n,t)=>rn.sign(n,t.slice(0,32)),Qa=rn.verify,Mt=n=>V.Buffer.isBuffer(n)?n:n instanceof Uint8Array?V.Buffer.from(n.buffer,n.byteOffset,n.byteLength):V.Buffer.from(n);class Xa{constructor(t){Object.assign(this,t)}encode(){return V.Buffer.from(Yo(Bn,this))}static decode(t){return Qo(Bn,this,t)}static decodeUnchecked(t){return Xo(Bn,this,t)}}const Bn=new Map;var wo;const Ja=32,pe=32;function tc(n){return n._bn!==void 0}let Fs=1;class z extends Xa{constructor(t){if(super({}),this._bn=void 0,tc(t))this._bn=t._bn;else{if(typeof t=="string"){const e=Tt.decode(t);if(e.length!=pe)throw new Error("Invalid public key input");this._bn=new Dr(e)}else this._bn=new Dr(t);if(this._bn.byteLength()>pe)throw new Error("Invalid public key input")}}static unique(){const t=new z(Fs);return Fs+=1,new z(t.toBuffer())}equals(t){return this._bn.eq(t._bn)}toBase58(){return Tt.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const t=this.toBuffer();return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}toBuffer(){const t=this._bn.toArrayLike(V.Buffer);if(t.length===pe)return t;const e=V.Buffer.alloc(32);return t.copy(e,32-t.length),e}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(t,e,r){const s=V.Buffer.concat([t.toBuffer(),V.Buffer.from(e),r.toBuffer()]),o=$r(s);return new z(o)}static createProgramAddressSync(t,e){let r=V.Buffer.alloc(0);t.forEach(function(o){if(o.length>Ja)throw new TypeError("Max seed length exceeded");r=V.Buffer.concat([r,Mt(o)])}),r=V.Buffer.concat([r,e.toBuffer(),V.Buffer.from("ProgramDerivedAddress")]);const s=$r(r);if(Ps(s))throw new Error("Invalid seeds, address must fall off the curve");return new z(s)}static async createProgramAddress(t,e){return this.createProgramAddressSync(t,e)}static findProgramAddressSync(t,e){let r=255,s;for(;r!=0;){try{const o=t.concat(V.Buffer.from([r]));s=this.createProgramAddressSync(o,e)}catch(o){if(o instanceof TypeError)throw o;r--;continue}return[s,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(t,e){return this.findProgramAddressSync(t,e)}static isOnCurve(t){const e=new z(t);return Ps(e.toBytes())}}wo=z;z.default=new wo("11111111111111111111111111111111");Bn.set(z,{kind:"struct",fields:[["_bn","u256"]]});new z("BPFLoader1111111111111111111111111111111111");const Ne=1280-40-8,xo=127,Ao=64;class Je{constructor(t,e){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=t,this.accountKeysFromLookups=e}keySegments(){const t=[this.staticAccountKeys];return this.accountKeysFromLookups&&(t.push(this.accountKeysFromLookups.writable),t.push(this.accountKeysFromLookups.readonly)),t}get(t){for(const e of this.keySegments()){if(t<e.length)return e[t];t-=e.length}}get length(){return this.keySegments().flat().length}compileInstructions(t){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((o,i)=>{r.set(o.toBase58(),i)});const s=o=>{const i=r.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return t.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const Q=(n="publicKey")=>pt(32,n),Pe=(n="string")=>{const t=C([N("length"),N("lengthPadding"),pt(Fe(N(),-8),"chars")],n),e=t.decode.bind(t),r=t.encode.bind(t),s=t;return s.decode=(o,i)=>e(o,i).chars.toString(),s.encode=(o,i,u)=>{const a={chars:V.Buffer.from(o,"utf8")};return r(a,i,u)},s.alloc=o=>N().span+N().span+V.Buffer.from(o,"utf8").length,s},ec=(n="authorized")=>C([Q("staker"),Q("withdrawer")],n),nc=(n="lockup")=>C([$t("unixTimestamp"),$t("epoch"),Q("custodian")],n),rc=(n="voteInit")=>C([Q("nodePubkey"),Q("authorizedVoter"),Q("authorizedWithdrawer"),st("commission")],n),sc=(n="voteAuthorizeWithSeedArgs")=>C([N("voteAuthorizationType"),Q("currentAuthorityDerivedKeyOwnerPubkey"),Pe("currentAuthorityDerivedKeySeed"),Q("newAuthorized")],n);function So(n,t){const e=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(t[s.property]);if("count"in s&&"elementLayout"in s){const o=t[s.property];if(Array.isArray(o))return o.length*e(s.elementLayout)}else if("fields"in s)return So({layout:s},t[s.property]);return 0};let r=0;return n.layout.fields.forEach(s=>{r+=e(s)}),r}function Ot(n){let t=0,e=0;for(;;){let r=n.shift();if(t|=(r&127)<<e*7,e+=1,(r&128)===0)break}return t}function Ht(n,t){let e=t;for(;;){let r=e&127;if(e>>=7,e==0){n.push(r);break}else r|=128,n.push(r)}}function vt(n,t){if(!n)throw new Error(t||"Assertion failed")}class Nn{constructor(t,e){this.payer=void 0,this.keyMetaMap=void 0,this.payer=t,this.keyMetaMap=e}static compile(t,e){const r=new Map,s=i=>{const u=i.toBase58();let a=r.get(u);return a===void 0&&(a={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(u,a)),a},o=s(e);o.isSigner=!0,o.isWritable=!0;for(const i of t){s(i.programId).isInvoked=!0;for(const u of i.keys){const a=s(u.pubkey);a.isSigner||=u.isSigner,a.isWritable||=u.isWritable}}return new Nn(e,r)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];vt(t.length<=256,"Max static account keys length exceeded");const e=t.filter(([,a])=>a.isSigner&&a.isWritable),r=t.filter(([,a])=>a.isSigner&&!a.isWritable),s=t.filter(([,a])=>!a.isSigner&&a.isWritable),o=t.filter(([,a])=>!a.isSigner&&!a.isWritable),i={numRequiredSignatures:e.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{vt(e.length>0,"Expected at least one writable signer key");const[a]=e[0];vt(a===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const u=[...e.map(([a])=>new z(a)),...r.map(([a])=>new z(a)),...s.map(([a])=>new z(a)),...o.map(([a])=>new z(a))];return[i,u]}extractTableLookup(t){const[e,r]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(e.length===0&&s.length===0))return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:s},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(t,e){const r=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(e(i)){const u=new z(o),a=t.findIndex(l=>l.equals(u));a>=0&&(vt(a<256,"Max lookup table index exceeded"),r.push(a),s.push(u),this.keyMetaMap.delete(o))}return[r,s]}}const ko="Reached end of buffer unexpectedly";function re(n){if(n.length===0)throw new Error(ko);return n.shift()}function Wt(n,...t){const[e]=t;if(t.length===2?e+(t[1]??0)>n.length:e>=n.length)throw new Error(ko);return n.splice(...t)}class tn{constructor(t){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=t.header,this.accountKeys=t.accountKeys.map(e=>new z(e)),this.recentBlockhash=t.recentBlockhash,this.instructions=t.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:Tt.decode(t.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Je(this.staticAccountKeys)}static compile(t){const e=Nn.compile(t.instructions,t.payerKey),[r,s]=e.getMessageComponents(),i=new Je(s).compileInstructions(t.instructions).map(u=>({programIdIndex:u.programIdIndex,accounts:u.accountKeyIndexes,data:Tt.encode(u.data)}));return new tn({header:r,accountKeys:s,recentBlockhash:t.recentBlockhash,instructions:i})}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures;if(t>=this.header.numRequiredSignatures){const r=t-e,o=this.accountKeys.length-e-this.header.numReadonlyUnsignedAccounts;return r<o}else{const r=e-this.header.numReadonlySignedAccounts;return t<r}}isProgramId(t){return this.indexToProgramIds.has(t)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((t,e)=>!this.isProgramId(e))}serialize(){const t=this.accountKeys.length;let e=[];Ht(e,t);const r=this.instructions.map(f=>{const{accounts:A,programIdIndex:I}=f,b=Array.from(Tt.decode(f.data));let h=[];Ht(h,A.length);let p=[];return Ht(p,b.length),{programIdIndex:I,keyIndicesCount:V.Buffer.from(h),keyIndices:A,dataLength:V.Buffer.from(p),data:b}});let s=[];Ht(s,r.length);let o=V.Buffer.alloc(Ne);V.Buffer.from(s).copy(o);let i=s.length;r.forEach(f=>{i+=C([st("programIdIndex"),pt(f.keyIndicesCount.length,"keyIndicesCount"),Ft(st("keyIndex"),f.keyIndices.length,"keyIndices"),pt(f.dataLength.length,"dataLength"),Ft(st("userdatum"),f.data.length,"data")]).encode(f,o,i)}),o=o.slice(0,i);const u=C([pt(1,"numRequiredSignatures"),pt(1,"numReadonlySignedAccounts"),pt(1,"numReadonlyUnsignedAccounts"),pt(e.length,"keyCount"),Ft(Q("key"),t,"keys"),Q("recentBlockhash")]),a={numRequiredSignatures:V.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:V.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:V.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:V.Buffer.from(e),keys:this.accountKeys.map(f=>Mt(f.toBytes())),recentBlockhash:Tt.decode(this.recentBlockhash)};let l=V.Buffer.alloc(2048);const d=u.encode(a,l);return o.copy(l,d),l.slice(0,d+o.length)}static from(t){let e=[...t];const r=re(e);if(r!==(r&xo))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=re(e),o=re(e),i=Ot(e);let u=[];for(let A=0;A<i;A++){const I=Wt(e,0,pe);u.push(new z(V.Buffer.from(I)))}const a=Wt(e,0,pe),l=Ot(e);let d=[];for(let A=0;A<l;A++){const I=re(e),b=Ot(e),h=Wt(e,0,b),p=Ot(e),k=Wt(e,0,p),B=Tt.encode(V.Buffer.from(k));d.push({programIdIndex:I,accounts:h,data:B})}const f={header:{numRequiredSignatures:r,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:Tt.encode(V.Buffer.from(a)),accountKeys:u,instructions:d};return new tn(f)}}class Tn{constructor(t){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=t.header,this.staticAccountKeys=t.staticAccountKeys,this.recentBlockhash=t.recentBlockhash,this.compiledInstructions=t.compiledInstructions,this.addressTableLookups=t.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let t=0;for(const e of this.addressTableLookups)t+=e.readonlyIndexes.length+e.writableIndexes.length;return t}getAccountKeys(t){let e;if(t&&"accountKeysFromLookups"in t&&t.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=t.accountKeysFromLookups.writable.length+t.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");e=t.accountKeysFromLookups}else if(t&&"addressLookupTableAccounts"in t&&t.addressLookupTableAccounts)e=this.resolveAddressTableLookups(t.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Je(this.staticAccountKeys,e)}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(t>=r){const s=t-r,o=this.addressTableLookups.reduce((i,u)=>i+u.writableIndexes.length,0);return s<o}else if(t>=this.header.numRequiredSignatures){const s=t-e,i=r-e-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=e-this.header.numReadonlySignedAccounts;return t<s}}resolveAddressTableLookups(t){const e={writable:[],readonly:[]};for(const r of this.addressTableLookups){const s=t.find(o=>o.key.equals(r.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const o of r.writableIndexes)if(o<s.state.addresses.length)e.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`);for(const o of r.readonlyIndexes)if(o<s.state.addresses.length)e.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`)}return e}static compile(t){const e=Nn.compile(t.instructions,t.payerKey),r=new Array,s={writable:new Array,readonly:new Array},o=t.addressLookupTableAccounts||[];for(const d of o){const f=e.extractTableLookup(d);if(f!==void 0){const[A,{writable:I,readonly:b}]=f;r.push(A),s.writable.push(...I),s.readonly.push(...b)}}const[i,u]=e.getMessageComponents(),l=new Je(u,s).compileInstructions(t.instructions);return new Tn({header:i,staticAccountKeys:u,recentBlockhash:t.recentBlockhash,compiledInstructions:l,addressTableLookups:r})}serialize(){const t=Array();Ht(t,this.staticAccountKeys.length);const e=this.serializeInstructions(),r=Array();Ht(r,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();Ht(o,this.addressTableLookups.length);const i=C([st("prefix"),C([st("numRequiredSignatures"),st("numReadonlySignedAccounts"),st("numReadonlyUnsignedAccounts")],"header"),pt(t.length,"staticAccountKeysLength"),Ft(Q(),this.staticAccountKeys.length,"staticAccountKeys"),Q("recentBlockhash"),pt(r.length,"instructionsLength"),pt(e.length,"serializedInstructions"),pt(o.length,"addressTableLookupsLength"),pt(s.length,"serializedAddressTableLookups")]),u=new Uint8Array(Ne),a=1<<7,l=i.encode({prefix:a,header:this.header,staticAccountKeysLength:new Uint8Array(t),staticAccountKeys:this.staticAccountKeys.map(d=>d.toBytes()),recentBlockhash:Tt.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:e,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},u);return u.slice(0,l)}serializeInstructions(){let t=0;const e=new Uint8Array(Ne);for(const r of this.compiledInstructions){const s=Array();Ht(s,r.accountKeyIndexes.length);const o=Array();Ht(o,r.data.length),t+=C([st("programIdIndex"),pt(s.length,"encodedAccountKeyIndexesLength"),Ft(st(),r.accountKeyIndexes.length,"accountKeyIndexes"),pt(o.length,"encodedDataLength"),pt(r.data.length,"data")]).encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:r.data},e,t)}return e.slice(0,t)}serializeAddressTableLookups(){let t=0;const e=new Uint8Array(Ne);for(const r of this.addressTableLookups){const s=Array();Ht(s,r.writableIndexes.length);const o=Array();Ht(o,r.readonlyIndexes.length),t+=C([Q("accountKey"),pt(s.length,"encodedWritableIndexesLength"),Ft(st(),r.writableIndexes.length,"writableIndexes"),pt(o.length,"encodedReadonlyIndexesLength"),Ft(st(),r.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:r.readonlyIndexes},e,t)}return e.slice(0,t)}static deserialize(t){let e=[...t];const r=re(e),s=r&xo;vt(r!==s,"Expected versioned message but received legacy message");const o=s;vt(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:re(e),numReadonlySignedAccounts:re(e),numReadonlyUnsignedAccounts:re(e)},u=[],a=Ot(e);for(let b=0;b<a;b++)u.push(new z(Wt(e,0,pe)));const l=Tt.encode(Wt(e,0,pe)),d=Ot(e),f=[];for(let b=0;b<d;b++){const h=re(e),p=Ot(e),k=Wt(e,0,p),B=Ot(e),S=new Uint8Array(Wt(e,0,B));f.push({programIdIndex:h,accountKeyIndexes:k,data:S})}const A=Ot(e),I=[];for(let b=0;b<A;b++){const h=new z(Wt(e,0,pe)),p=Ot(e),k=Wt(e,0,p),B=Ot(e),S=Wt(e,0,B);I.push({accountKey:h,writableIndexes:k,readonlyIndexes:S})}return new Tn({header:i,staticAccountKeys:u,recentBlockhash:l,compiledInstructions:f,addressTableLookups:I})}}const oc=V.Buffer.alloc(Ao).fill(0);class qt{constructor(t){this.keys=void 0,this.programId=void 0,this.data=V.Buffer.alloc(0),this.programId=t.programId,this.keys=t.keys,t.data&&(this.data=t.data)}toJSON(){return{keys:this.keys.map(({pubkey:t,isSigner:e,isWritable:r})=>({pubkey:t.toJSON(),isSigner:e,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class _n{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(t){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!t)if(t.feePayer&&(this.feePayer=t.feePayer),t.signatures&&(this.signatures=t.signatures),Object.prototype.hasOwnProperty.call(t,"nonceInfo")){const{minContextSlot:e,nonceInfo:r}=t;this.minNonceContextSlot=e,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")){const{blockhash:e,lastValidBlockHeight:r}=t;this.recentBlockhash=e,this.lastValidBlockHeight=r}else{const{recentBlockhash:e,nonceInfo:r}=t;r&&(this.nonceInfo=r),this.recentBlockhash=e}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(t=>t.toJSON()),signers:this.signatures.map(({publicKey:t})=>t.toJSON())}}add(...t){if(t.length===0)throw new Error("No instructions");return t.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new qt(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let t,e;if(this.nonceInfo?(t=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?e=[this.nonceInfo.nonceInstruction,...this.instructions]:e=this.instructions):(t=this.recentBlockhash,e=this.instructions),!t)throw new Error("Transaction recentBlockhash required");e.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let h=0;h<e.length;h++)if(e[h].programId===void 0)throw new Error(`Transaction instruction index ${h} has undefined program id`);const s=[],o=[];e.forEach(h=>{h.keys.forEach(k=>{o.push({...k})});const p=h.programId.toString();s.includes(p)||s.push(p)}),s.forEach(h=>{o.push({pubkey:new z(h),isSigner:!1,isWritable:!1})});const i=[];o.forEach(h=>{const p=h.pubkey.toString(),k=i.findIndex(B=>B.pubkey.toString()===p);k>-1?(i[k].isWritable=i[k].isWritable||h.isWritable,i[k].isSigner=i[k].isSigner||h.isSigner):i.push(h)}),i.sort(function(h,p){if(h.isSigner!==p.isSigner)return h.isSigner?-1:1;if(h.isWritable!==p.isWritable)return h.isWritable?-1:1;const k={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return h.pubkey.toBase58().localeCompare(p.pubkey.toBase58(),"en",k)});const u=i.findIndex(h=>h.pubkey.equals(r));if(u>-1){const[h]=i.splice(u,1);h.isSigner=!0,h.isWritable=!0,i.unshift(h)}else i.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const h of this.signatures){const p=i.findIndex(k=>k.pubkey.equals(h.publicKey));if(p>-1)i[p].isSigner||(i[p].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${h.publicKey.toString()}`)}let a=0,l=0,d=0;const f=[],A=[];i.forEach(({pubkey:h,isSigner:p,isWritable:k})=>{p?(f.push(h.toString()),a+=1,k||(l+=1)):(A.push(h.toString()),k||(d+=1))});const I=f.concat(A),b=e.map(h=>{const{data:p,programId:k}=h;return{programIdIndex:I.indexOf(k.toString()),accounts:h.keys.map(B=>I.indexOf(B.pubkey.toString())),data:Tt.encode(p)}});return b.forEach(h=>{vt(h.programIdIndex>=0),h.accounts.forEach(p=>vt(p>=0))}),new tn({header:{numRequiredSignatures:a,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:d},accountKeys:I,recentBlockhash:t,instructions:b})}_compile(){const t=this.compileMessage(),e=t.accountKeys.slice(0,t.header.numRequiredSignatures);return this.signatures.length===e.length&&this.signatures.every((s,o)=>e[o].equals(s.publicKey))||(this.signatures=e.map(r=>({signature:null,publicKey:r}))),t}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(t){return(await t.getFeeForMessage(this.compileMessage())).value}setSigners(...t){if(t.length===0)throw new Error("No signers");const e=new Set;this.signatures=t.filter(r=>{const s=r.toString();return e.has(s)?!1:(e.add(s),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const o of t){const i=o.publicKey.toString();e.has(i)||(e.add(i),r.push(o))}this.signatures=r.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...r)}partialSign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const o of t){const i=o.publicKey.toString();e.has(i)||(e.add(i),r.push(o))}const s=this._compile();this._partialSign(s,...r)}_partialSign(t,...e){const r=t.serialize();e.forEach(s=>{const o=Ya(r,s.secretKey);this._addSignature(s.publicKey,Mt(o))})}addSignature(t,e){this._compile(),this._addSignature(t,e)}_addSignature(t,e){vt(e.length===64);const r=this.signatures.findIndex(s=>t.equals(s.publicKey));if(r<0)throw new Error(`unknown signer: ${t.toString()}`);this.signatures[r].signature=V.Buffer.from(e)}verifySignatures(t=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),t)}_getMessageSignednessErrors(t,e){const r={};for(const{signature:s,publicKey:o}of this.signatures)s===null?e&&(r.missing||=[]).push(o):Qa(s,t,o.toBytes())||(r.invalid||=[]).push(o);return r.invalid||r.missing?r:void 0}serialize(t){const{requireAllSignatures:e,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},t),s=this.serializeMessage();if(r){const o=this._getMessageSignednessErrors(s,e);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(u=>u.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(u=>u.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(s)}_serialize(t){const{signatures:e}=this,r=[];Ht(r,e.length);const s=r.length+e.length*64+t.length,o=V.Buffer.alloc(s);return vt(e.length<256),V.Buffer.from(r).copy(o,0),e.forEach(({signature:i},u)=>{i!==null&&(vt(i.length===64,"signature has invalid length"),V.Buffer.from(i).copy(o,r.length+u*64))}),t.copy(o,r.length+e.length*64),vt(o.length<=Ne,`Transaction too large: ${o.length} > ${Ne}`),o}get keys(){return vt(this.instructions.length===1),this.instructions[0].keys.map(t=>t.pubkey)}get programId(){return vt(this.instructions.length===1),this.instructions[0].programId}get data(){return vt(this.instructions.length===1),this.instructions[0].data}static from(t){let e=[...t];const r=Ot(e);let s=[];for(let o=0;o<r;o++){const i=Wt(e,0,Ao);s.push(Tt.encode(V.Buffer.from(i)))}return _n.populate(tn.from(e),s)}static populate(t,e=[]){const r=new _n;return r.recentBlockhash=t.recentBlockhash,t.header.numRequiredSignatures>0&&(r.feePayer=t.accountKeys[0]),e.forEach((s,o)=>{const i={signature:s==Tt.encode(oc)?null:Tt.decode(s),publicKey:t.accountKeys[o]};r.signatures.push(i)}),t.instructions.forEach(s=>{const o=s.accounts.map(i=>{const u=t.accountKeys[i];return{pubkey:u,isSigner:r.signatures.some(a=>a.publicKey.toString()===u.toString())||t.isAccountSigner(i),isWritable:t.isAccountWritable(i)}});r.instructions.push(new qt({keys:o,programId:t.accountKeys[s.programIdIndex],data:Tt.decode(s.data)}))}),r._message=t,r._json=r.toJSON(),r}}new z("SysvarC1ock11111111111111111111111111111111");new z("SysvarEpochSchedu1e111111111111111111111111");new z("Sysvar1nstructions1111111111111111111111111");const Pr=new z("SysvarRecentB1ockHashes11111111111111111111"),Ds=new z("SysvarRent111111111111111111111111111111111");new z("SysvarRewards111111111111111111111111111111");new z("SysvarS1otHashes111111111111111111111111111");new z("SysvarS1otHistory11111111111111111111111111");new z("SysvarStakeHistory1111111111111111111111111");function Dt(n,t){const e=n.layout.span>=0?n.layout.span:So(n,t),r=V.Buffer.alloc(e),s=Object.assign({instruction:n.index},t);return n.layout.encode(s,r),r}const ic=Bt("lamportsPerSignature"),ac=C([N("version"),N("state"),Q("authorizedPubkey"),Q("nonce"),C([ic],"feeCalculator")]),Ns=ac.span,cc=n=>{const t=n.decode.bind(n),e=n.encode.bind(n);return{decode:t,encode:e}},uc=n=>t=>{const e=pt(n,t),{encode:r,decode:s}=cc(e),o=e;return o.decode=(i,u)=>{const a=s(i,u);return Jo(V.Buffer.from(a))},o.encode=(i,u,a)=>{const l=ti(i,n);return r(l,u,a)},o},$e=uc(8),Nt=Object.freeze({Create:{index:0,layout:C([N("instruction"),$t("lamports"),$t("space"),Q("programId")])},Assign:{index:1,layout:C([N("instruction"),Q("programId")])},Transfer:{index:2,layout:C([N("instruction"),$e("lamports")])},CreateWithSeed:{index:3,layout:C([N("instruction"),Q("base"),Pe("seed"),$t("lamports"),$t("space"),Q("programId")])},AdvanceNonceAccount:{index:4,layout:C([N("instruction")])},WithdrawNonceAccount:{index:5,layout:C([N("instruction"),$t("lamports")])},InitializeNonceAccount:{index:6,layout:C([N("instruction"),Q("authorized")])},AuthorizeNonceAccount:{index:7,layout:C([N("instruction"),Q("authorized")])},Allocate:{index:8,layout:C([N("instruction"),$t("space")])},AllocateWithSeed:{index:9,layout:C([N("instruction"),Q("base"),Pe("seed"),$t("space"),Q("programId")])},AssignWithSeed:{index:10,layout:C([N("instruction"),Q("base"),Pe("seed"),Q("programId")])},TransferWithSeed:{index:11,layout:C([N("instruction"),$e("lamports"),Pe("seed"),Q("programId")])},UpgradeNonceAccount:{index:12,layout:C([N("instruction")])}});class en{constructor(){}static createAccount(t){const e=Nt.Create,r=Dt(e,{lamports:t.lamports,space:t.space,programId:Mt(t.programId.toBuffer())});return new qt({keys:[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(t){let e,r;if("basePubkey"in t){const s=Nt.TransferWithSeed;e=Dt(s,{lamports:BigInt(t.lamports),seed:t.seed,programId:Mt(t.programId.toBuffer())}),r=[{pubkey:t.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=Nt.Transfer;e=Dt(s,{lamports:BigInt(t.lamports)}),r=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}return new qt({keys:r,programId:this.programId,data:e})}static assign(t){let e,r;if("basePubkey"in t){const s=Nt.AssignWithSeed;e=Dt(s,{base:Mt(t.basePubkey.toBuffer()),seed:t.seed,programId:Mt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Nt.Assign;e=Dt(s,{programId:Mt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new qt({keys:r,programId:this.programId,data:e})}static createAccountWithSeed(t){const e=Nt.CreateWithSeed,r=Dt(e,{base:Mt(t.basePubkey.toBuffer()),seed:t.seed,lamports:t.lamports,space:t.space,programId:Mt(t.programId.toBuffer())});let s=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!1,isWritable:!0}];return t.basePubkey.equals(t.fromPubkey)||s.push({pubkey:t.basePubkey,isSigner:!0,isWritable:!1}),new qt({keys:s,programId:this.programId,data:r})}static createNonceAccount(t){const e=new _n;"basePubkey"in t&&"seed"in t?e.add(en.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:Ns,programId:this.programId})):e.add(en.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,lamports:t.lamports,space:Ns,programId:this.programId}));const r={noncePubkey:t.noncePubkey,authorizedPubkey:t.authorizedPubkey};return e.add(this.nonceInitialize(r)),e}static nonceInitialize(t){const e=Nt.InitializeNonceAccount,r=Dt(e,{authorized:Mt(t.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Pr,isSigner:!1,isWritable:!1},{pubkey:Ds,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new qt(s)}static nonceAdvance(t){const e=Nt.AdvanceNonceAccount,r=Dt(e),s={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Pr,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new qt(s)}static nonceWithdraw(t){const e=Nt.WithdrawNonceAccount,r=Dt(e,{lamports:t.lamports});return new qt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Pr,isSigner:!1,isWritable:!1},{pubkey:Ds,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(t){const e=Nt.AuthorizeNonceAccount,r=Dt(e,{authorized:Mt(t.newAuthorizedPubkey.toBuffer())});return new qt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(t){let e,r;if("basePubkey"in t){const s=Nt.AllocateWithSeed;e=Dt(s,{base:Mt(t.basePubkey.toBuffer()),seed:t.seed,space:t.space,programId:Mt(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Nt.Allocate;e=Dt(s,{space:t.space}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new qt({keys:r,programId:this.programId,data:e})}}en.programId=new z("11111111111111111111111111111111");new z("BPFLoader2111111111111111111111111111111111");C([N("typeIndex"),$e("deactivationSlot"),Bt("lastExtendedSlot"),st("lastExtendedStartIndex"),st(),Ft(Q(),Fe(st(),-1),"authority")]);const gt=an(es(z),v(),n=>new z(n)),Io=ns([v(),lt("base64")]),ss=an(es(V.Buffer),Io,n=>V.Buffer.from(n[0],"base64"));function Bo(n){return Rt([x({jsonrpc:lt("2.0"),id:v(),result:n}),x({jsonrpc:lt("2.0"),id:v(),error:x({code:He(),message:v(),data:U(Fa())})})])}const lc=Bo(He());function ot(n){return an(Bo(n),lc,t=>"error"in t?t:{...t,result:Xe(t.result,n)})}function jt(n){return ot(x({context:x({slot:g()}),value:n}))}function qn(n){return x({context:x({slot:g()}),value:n})}const dc=x({foundation:g(),foundationTerm:g(),initial:g(),taper:g(),terminal:g()});ot(T(_(x({epoch:g(),effectiveSlot:g(),amount:g(),postBalance:g(),commission:U(_(g()))}))));const fc=T(x({slot:g(),prioritizationFee:g()})),hc=x({total:g(),validator:g(),foundation:g(),epoch:g()}),gc=x({epoch:g(),slotIndex:g(),slotsInEpoch:g(),absoluteSlot:g(),blockHeight:U(g()),transactionCount:U(g())}),pc=x({slotsPerEpoch:g(),leaderScheduleSlotOffset:g(),warmup:Jt(),firstNormalEpoch:g(),firstNormalSlot:g()}),mc=po(v(),T(g())),ze=_(Rt([x({}),v()])),yc=x({err:ze}),bc=lt("receivedSignature");x({"solana-core":v(),"feature-set":U(g())});const wc=x({program:v(),programId:gt,parsed:He()}),xc=x({programId:gt,accounts:T(gt),data:v()});jt(x({err:_(Rt([x({}),v()])),logs:_(T(v())),accounts:U(_(T(_(x({executable:Jt(),owner:v(),lamports:g(),data:T(v()),rentEpoch:U(g())}))))),unitsConsumed:U(g()),returnData:U(_(x({programId:v(),data:ns([v(),lt("base64")])}))),innerInstructions:U(_(T(x({index:g(),instructions:T(Rt([wc,xc]))}))))}));jt(x({byIdentity:po(v(),T(g())),range:x({firstSlot:g(),lastSlot:g()})}));ot(dc);ot(hc);ot(fc);ot(gc);ot(pc);ot(mc);ot(g());jt(x({total:g(),circulating:g(),nonCirculating:g(),nonCirculatingAccounts:T(gt)}));const Ac=x({amount:v(),uiAmount:_(g()),decimals:g(),uiAmountString:U(v())});jt(T(x({address:gt,amount:v(),uiAmount:_(g()),decimals:g(),uiAmountString:U(v())})));jt(T(x({pubkey:gt,account:x({executable:Jt(),owner:gt,lamports:g(),data:ss,rentEpoch:g()})})));const Wr=x({program:v(),parsed:He(),space:g()});jt(T(x({pubkey:gt,account:x({executable:Jt(),owner:gt,lamports:g(),data:Wr,rentEpoch:g()})})));jt(T(x({lamports:g(),address:gt})));const os=x({executable:Jt(),owner:gt,lamports:g(),data:ss,rentEpoch:g()});x({pubkey:gt,account:os});const Sc=an(Rt([es(V.Buffer),Wr]),Rt([Io,Wr]),n=>Array.isArray(n)?Xe(n,ss):n),kc=x({executable:Jt(),owner:gt,lamports:g(),data:Sc,rentEpoch:g()});x({pubkey:gt,account:kc});x({state:Rt([lt("active"),lt("inactive"),lt("activating"),lt("deactivating")]),active:g(),inactive:g()});ot(T(x({signature:v(),slot:g(),err:ze,memo:_(v()),blockTime:U(_(g()))})));ot(T(x({signature:v(),slot:g(),err:ze,memo:_(v()),blockTime:U(_(g()))})));x({subscription:g(),result:qn(os)});const Ic=x({pubkey:gt,account:os});x({subscription:g(),result:qn(Ic)});const Bc=x({parent:g(),slot:g(),root:g()});x({subscription:g(),result:Bc});const vc=Rt([x({type:Rt([lt("firstShredReceived"),lt("completed"),lt("optimisticConfirmation"),lt("root")]),slot:g(),timestamp:g()}),x({type:lt("createdBank"),parent:g(),slot:g(),timestamp:g()}),x({type:lt("frozen"),slot:g(),timestamp:g(),stats:x({numTransactionEntries:g(),numSuccessfulTransactions:g(),numFailedTransactions:g(),maxTransactionsPerEntry:g()})}),x({type:lt("dead"),slot:g(),timestamp:g(),err:v()})]);x({subscription:g(),result:vc});x({subscription:g(),result:qn(Rt([yc,bc]))});x({subscription:g(),result:g()});x({pubkey:v(),gossip:_(v()),tpu:_(v()),rpc:_(v()),version:_(v())});const qs=x({votePubkey:v(),nodePubkey:v(),activatedStake:g(),epochVoteAccount:Jt(),epochCredits:T(ns([g(),g(),g()])),commission:g(),lastVote:g(),rootSlot:_(g())});ot(x({current:T(qs),delinquent:T(qs)}));const Ec=Rt([lt("processed"),lt("confirmed"),lt("finalized")]),Tc=x({slot:g(),confirmations:_(g()),err:ze,confirmationStatus:U(Ec)});jt(T(_(Tc)));ot(g());const vo=x({accountKey:gt,writableIndexes:T(g()),readonlyIndexes:T(g())}),is=x({signatures:T(v()),message:x({accountKeys:T(v()),header:x({numRequiredSignatures:g(),numReadonlySignedAccounts:g(),numReadonlyUnsignedAccounts:g()}),instructions:T(x({accounts:T(g()),data:v(),programIdIndex:g()})),recentBlockhash:v(),addressTableLookups:U(T(vo))})}),Eo=x({pubkey:gt,signer:Jt(),writable:Jt(),source:U(Rt([lt("transaction"),lt("lookupTable")]))}),To=x({accountKeys:T(Eo),signatures:T(v())}),_o=x({parsed:He(),program:v(),programId:gt}),Lo=x({accounts:T(gt),data:v(),programId:gt}),_c=Rt([Lo,_o]),Lc=Rt([x({parsed:He(),program:v(),programId:v()}),x({accounts:T(v()),data:v(),programId:v()})]),Ro=an(_c,Lc,n=>"accounts"in n?Xe(n,Lo):Xe(n,_o)),zo=x({signatures:T(v()),message:x({accountKeys:T(Eo),instructions:T(Ro),recentBlockhash:v(),addressTableLookups:U(_(T(vo)))})}),Ln=x({accountIndex:g(),mint:v(),owner:U(v()),uiTokenAmount:Ac}),Co=x({writable:T(gt),readonly:T(gt)}),Un=x({err:ze,fee:g(),innerInstructions:U(_(T(x({index:g(),instructions:T(x({accounts:T(g()),data:v(),programIdIndex:g()}))})))),preBalances:T(g()),postBalances:T(g()),logMessages:U(_(T(v()))),preTokenBalances:U(_(T(Ln))),postTokenBalances:U(_(T(Ln))),loadedAddresses:U(Co),computeUnitsConsumed:U(g())}),as=x({err:ze,fee:g(),innerInstructions:U(_(T(x({index:g(),instructions:T(Ro)})))),preBalances:T(g()),postBalances:T(g()),logMessages:U(_(T(v()))),preTokenBalances:U(_(T(Ln))),postTokenBalances:U(_(T(Ln))),loadedAddresses:U(Co),computeUnitsConsumed:U(g())}),We=Rt([lt(0),lt("legacy")]),Ce=x({pubkey:v(),lamports:g(),postBalance:_(g()),rewardType:_(v()),commission:U(_(g()))});ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:is,meta:_(Un),version:U(We)})),rewards:U(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),rewards:U(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:To,meta:_(Un),version:U(We)})),rewards:U(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:zo,meta:_(as),version:U(We)})),rewards:U(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:To,meta:_(as),version:U(We)})),rewards:U(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),rewards:U(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:is,meta:_(Un)})),rewards:U(T(Ce)),blockTime:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),signatures:T(v()),blockTime:_(g())})));ot(_(x({slot:g(),meta:_(Un),blockTime:U(_(g())),transaction:is,version:U(We)})));ot(_(x({slot:g(),transaction:zo,meta:_(as),blockTime:U(_(g())),version:U(We)})));jt(x({blockhash:v(),feeCalculator:x({lamportsPerSignature:g()})}));jt(x({blockhash:v(),lastValidBlockHeight:g()}));jt(Jt());const Rc=x({slot:g(),numTransactions:g(),numSlots:g(),samplePeriodSecs:g()});ot(T(Rc));jt(_(x({feeCalculator:x({lamportsPerSignature:g()})})));ot(v());ot(v());const zc=x({err:ze,logs:T(v()),signature:v()});x({result:qn(zc),subscription:g()});Object.freeze({CreateLookupTable:{index:0,layout:C([N("instruction"),$e("recentSlot"),st("bumpSeed")])},FreezeLookupTable:{index:1,layout:C([N("instruction")])},ExtendLookupTable:{index:2,layout:C([N("instruction"),$e(),Ft(Q(),Fe(N(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:C([N("instruction")])},CloseLookupTable:{index:4,layout:C([N("instruction")])}});new z("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:C([st("instruction"),N("units"),N("additionalFee")])},RequestHeapFrame:{index:1,layout:C([st("instruction"),N("bytes")])},SetComputeUnitLimit:{index:2,layout:C([st("instruction"),N("units")])},SetComputeUnitPrice:{index:3,layout:C([st("instruction"),$e("microLamports")])}});new z("ComputeBudget111111111111111111111111111111");C([st("numSignatures"),st("padding"),Yt("signatureOffset"),Yt("signatureInstructionIndex"),Yt("publicKeyOffset"),Yt("publicKeyInstructionIndex"),Yt("messageDataOffset"),Yt("messageDataSize"),Yt("messageInstructionIndex")]);new z("Ed25519SigVerify111111111111111111111111111");rs.utils.isValidPrivateKey;rs.getPublicKey;C([st("numSignatures"),Yt("signatureOffset"),st("signatureInstructionIndex"),Yt("ethAddressOffset"),st("ethAddressInstructionIndex"),Yt("messageDataOffset"),Yt("messageDataSize"),st("messageInstructionIndex"),pt(20,"ethAddress"),pt(64,"signature"),st("recoveryId")]);new z("KeccakSecp256k11111111111111111111111111111");var Ko;new z("StakeConfig11111111111111111111111111111111");class Mo{constructor(t,e,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=t,this.epoch=e,this.custodian=r}}Ko=Mo;Mo.default=new Ko(0,0,z.default);Object.freeze({Initialize:{index:0,layout:C([N("instruction"),ec(),nc()])},Authorize:{index:1,layout:C([N("instruction"),Q("newAuthorized"),N("stakeAuthorizationType")])},Delegate:{index:2,layout:C([N("instruction")])},Split:{index:3,layout:C([N("instruction"),$t("lamports")])},Withdraw:{index:4,layout:C([N("instruction"),$t("lamports")])},Deactivate:{index:5,layout:C([N("instruction")])},Merge:{index:7,layout:C([N("instruction")])},AuthorizeWithSeed:{index:8,layout:C([N("instruction"),Q("newAuthorized"),N("stakeAuthorizationType"),Pe("authoritySeed"),Q("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});new z("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:C([N("instruction"),rc()])},Authorize:{index:1,layout:C([N("instruction"),Q("newAuthorized"),N("voteAuthorizationType")])},Withdraw:{index:3,layout:C([N("instruction"),$t("lamports")])},UpdateValidatorIdentity:{index:4,layout:C([N("instruction")])},AuthorizeWithSeed:{index:10,layout:C([N("instruction"),sc()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});new z("Vote111111111111111111111111111111111111111");new z("Va1idator1nfo111111111111111111111111111111");x({name:v(),website:U(v()),details:U(v()),iconUrl:U(v()),keybaseUsername:U(v())});new z("Vote111111111111111111111111111111111111111");C([Q("nodePubkey"),Q("authorizedWithdrawer"),st("commission"),Bt(),Ft(C([Bt("slot"),N("confirmationCount")]),Fe(N(),-8),"votes"),st("rootSlotValid"),Bt("rootSlot"),Bt(),Ft(C([Bt("epoch"),Q("authorizedVoter")]),Fe(N(),-8),"authorizedVoters"),C([Ft(C([Q("authorizedPubkey"),Bt("epochOfLastAuthorizedSwitch"),Bt("targetEpoch")]),32,"buf"),Bt("idx"),st("isEmpty")],"priorVoters"),Bt(),Ft(C([Bt("epoch"),Bt("credits"),Bt("prevCredits")]),Fe(N(),-8),"epochCredits"),C([Bt("slot"),Bt("timestamp")],"lastTimestamp")]);const Cc=[156,194,70,44,22,88,137,44];class be{multisig;creator;index;bump;vaultIndex;vaultBump;size;executedTransactionIndex;constructor(t,e,r,s,o,i,u,a){this.multisig=t,this.creator=e,this.index=r,this.bump=s,this.vaultIndex=o,this.vaultBump=i,this.size=u,this.executedTransactionIndex=a}static fromArgs(t){return new be(t.multisig,t.creator,t.index,t.bump,t.vaultIndex,t.vaultBump,t.size,t.executedTransactionIndex)}static fromAccountInfo(t,e=0){return be.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find Batch account at ${e}`);return be.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new z("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(t,gn)}static deserialize(t,e=0){return gn.deserialize(t,e)}serialize(){return gn.serialize({accountDiscriminator:Cc,...this})}static get byteSize(){return gn.byteSize}static async getMinimumBalanceForRentExemption(t,e){return t.getMinimumBalanceForRentExemption(be.byteSize,e)}static hasCorrectByteSize(t,e=0){return t.byteLength-e===be.byteSize}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const t=this.index;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,vaultIndex:this.vaultIndex,vaultBump:this.vaultBump,size:this.size,executedTransactionIndex:this.executedTransactionIndex}}}const gn=new c.BeetStruct([["accountDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["multisig",F.publicKey],["creator",F.publicKey],["index",c.u64],["bump",c.u8],["vaultIndex",c.u8],["vaultBump",c.u8],["size",c.u32],["executedTransactionIndex",c.u32]],be.fromArgs,"Batch"),Kc=new c.BeetArgsStruct([["mask",c.u8]],"Permissions"),cn=new c.BeetArgsStruct([["key",F.publicKey],["permissions",Kc]],"Member");var Rn;(function(n){n[n.OneTime=0]="OneTime",n[n.Day=1]="Day",n[n.Week=2]="Week",n[n.Month=3]="Month"})(Rn||(Rn={}));const cs=c.fixedScalarEnum(Rn),Po=c.dataEnum([["AddMember",new c.BeetArgsStruct([["newMember",cn]],'ConfigActionRecord["AddMember"]')],["RemoveMember",new c.BeetArgsStruct([["oldMember",F.publicKey]],'ConfigActionRecord["RemoveMember"]')],["ChangeThreshold",new c.BeetArgsStruct([["newThreshold",c.u16]],'ConfigActionRecord["ChangeThreshold"]')],["SetTimeLock",new c.BeetArgsStruct([["newTimeLock",c.u32]],'ConfigActionRecord["SetTimeLock"]')],["AddSpendingLimit",new c.FixableBeetArgsStruct([["createKey",F.publicKey],["vaultIndex",c.u8],["mint",F.publicKey],["amount",c.u64],["period",cs],["members",c.array(F.publicKey)],["destinations",c.array(F.publicKey)]],'ConfigActionRecord["AddSpendingLimit"]')],["RemoveSpendingLimit",new c.BeetArgsStruct([["spendingLimit",F.publicKey]],'ConfigActionRecord["RemoveSpendingLimit"]')],["SetRentCollector",new c.FixableBeetArgsStruct([["newRentCollector",c.coption(F.publicKey)]],'ConfigActionRecord["SetRentCollector"]')]]),Us=[94,8,4,35,113,139,139,112];class we{multisig;creator;index;bump;actions;constructor(t,e,r,s,o){this.multisig=t,this.creator=e,this.index=r,this.bump=s,this.actions=o}static fromArgs(t){return new we(t.multisig,t.creator,t.index,t.bump,t.actions)}static fromAccountInfo(t,e=0){return we.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find ConfigTransaction account at ${e}`);return we.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new z("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(t,pn)}static deserialize(t,e=0){return pn.deserialize(t,e)}serialize(){return pn.serialize({accountDiscriminator:Us,...this})}static byteSize(t){const e=we.fromArgs(t);return pn.toFixedFromValue({accountDiscriminator:Us,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(we.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const t=this.index;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,actions:this.actions}}}const pn=new c.FixableBeetStruct([["accountDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["multisig",F.publicKey],["creator",F.publicKey],["index",c.u64],["bump",c.u8],["actions",c.array(Po)]],we.fromArgs,"ConfigTransaction"),$s=[224,116,121,186,68,161,79,236];class he{createKey;configAuthority;threshold;timeLock;transactionIndex;staleTransactionIndex;rentCollector;bump;members;constructor(t,e,r,s,o,i,u,a,l){this.createKey=t,this.configAuthority=e,this.threshold=r,this.timeLock=s,this.transactionIndex=o,this.staleTransactionIndex=i,this.rentCollector=u,this.bump=a,this.members=l}static fromArgs(t){return new he(t.createKey,t.configAuthority,t.threshold,t.timeLock,t.transactionIndex,t.staleTransactionIndex,t.rentCollector,t.bump,t.members)}static fromAccountInfo(t,e=0){return he.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find Multisig account at ${e}`);return he.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new z("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(t,mn)}static deserialize(t,e=0){return mn.deserialize(t,e)}serialize(){return mn.serialize({accountDiscriminator:$s,...this})}static byteSize(t){const e=he.fromArgs(t);return mn.toFixedFromValue({accountDiscriminator:$s,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(he.byteSize(t),r)}pretty(){return{createKey:this.createKey.toBase58(),configAuthority:this.configAuthority.toBase58(),threshold:this.threshold,timeLock:this.timeLock,transactionIndex:(()=>{const t=this.transactionIndex;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),staleTransactionIndex:(()=>{const t=this.staleTransactionIndex;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),rentCollector:this.rentCollector,bump:this.bump,members:this.members}}}const mn=new c.FixableBeetStruct([["accountDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["createKey",F.publicKey],["configAuthority",F.publicKey],["threshold",c.u16],["timeLock",c.u32],["transactionIndex",c.u64],["staleTransactionIndex",c.u64],["rentCollector",c.coption(F.publicKey)],["bump",c.u8],["members",c.array(cn)]],he.fromArgs,"Multisig"),Mc=[196,210,90,231,144,149,140,63];class xe{authority;multisigCreationFee;treasury;reserved;constructor(t,e,r,s){this.authority=t,this.multisigCreationFee=e,this.treasury=r,this.reserved=s}static fromArgs(t){return new xe(t.authority,t.multisigCreationFee,t.treasury,t.reserved)}static fromAccountInfo(t,e=0){return xe.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find ProgramConfig account at ${e}`);return xe.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new z("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(t,yn)}static deserialize(t,e=0){return yn.deserialize(t,e)}serialize(){return yn.serialize({accountDiscriminator:Mc,...this})}static get byteSize(){return yn.byteSize}static async getMinimumBalanceForRentExemption(t,e){return t.getMinimumBalanceForRentExemption(xe.byteSize,e)}static hasCorrectByteSize(t,e=0){return t.byteLength-e===xe.byteSize}pretty(){return{authority:this.authority.toBase58(),multisigCreationFee:(()=>{const t=this.multisigCreationFee;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),treasury:this.treasury.toBase58(),reserved:this.reserved}}}const yn=new c.BeetStruct([["accountDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["authority",F.publicKey],["multisigCreationFee",c.u64],["treasury",F.publicKey],["reserved",c.uniformFixedSizeArray(c.u8,64)]],xe.fromArgs,"ProgramConfig"),Pc=c.dataEnum([["Draft",new c.BeetArgsStruct([["timestamp",c.i64]],'ProposalStatusRecord["Draft"]')],["Active",new c.BeetArgsStruct([["timestamp",c.i64]],'ProposalStatusRecord["Active"]')],["Rejected",new c.BeetArgsStruct([["timestamp",c.i64]],'ProposalStatusRecord["Rejected"]')],["Approved",new c.BeetArgsStruct([["timestamp",c.i64]],'ProposalStatusRecord["Approved"]')],["Executing",c.unit],["Executed",new c.BeetArgsStruct([["timestamp",c.i64]],'ProposalStatusRecord["Executed"]')],["Cancelled",new c.BeetArgsStruct([["timestamp",c.i64]],'ProposalStatusRecord["Cancelled"]')]]),Os=[26,94,189,187,116,136,53,33];class Ae{multisig;transactionIndex;status;bump;approved;rejected;cancelled;constructor(t,e,r,s,o,i,u){this.multisig=t,this.transactionIndex=e,this.status=r,this.bump=s,this.approved=o,this.rejected=i,this.cancelled=u}static fromArgs(t){return new Ae(t.multisig,t.transactionIndex,t.status,t.bump,t.approved,t.rejected,t.cancelled)}static fromAccountInfo(t,e=0){return Ae.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find Proposal account at ${e}`);return Ae.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new z("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(t,bn)}static deserialize(t,e=0){return bn.deserialize(t,e)}serialize(){return bn.serialize({accountDiscriminator:Os,...this})}static byteSize(t){const e=Ae.fromArgs(t);return bn.toFixedFromValue({accountDiscriminator:Os,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(Ae.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),transactionIndex:(()=>{const t=this.transactionIndex;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),status:this.status.__kind,bump:this.bump,approved:this.approved,rejected:this.rejected,cancelled:this.cancelled}}}const bn=new c.FixableBeetStruct([["accountDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["multisig",F.publicKey],["transactionIndex",c.u64],["status",Pc],["bump",c.u8],["approved",c.array(F.publicKey)],["rejected",c.array(F.publicKey)],["cancelled",c.array(F.publicKey)]],Ae.fromArgs,"Proposal"),Hs=[10,201,27,160,218,195,222,152];class Se{multisig;createKey;vaultIndex;mint;amount;period;remainingAmount;lastReset;bump;members;destinations;constructor(t,e,r,s,o,i,u,a,l,d,f){this.multisig=t,this.createKey=e,this.vaultIndex=r,this.mint=s,this.amount=o,this.period=i,this.remainingAmount=u,this.lastReset=a,this.bump=l,this.members=d,this.destinations=f}static fromArgs(t){return new Se(t.multisig,t.createKey,t.vaultIndex,t.mint,t.amount,t.period,t.remainingAmount,t.lastReset,t.bump,t.members,t.destinations)}static fromAccountInfo(t,e=0){return Se.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find SpendingLimit account at ${e}`);return Se.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new z("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(t,wn)}static deserialize(t,e=0){return wn.deserialize(t,e)}serialize(){return wn.serialize({accountDiscriminator:Hs,...this})}static byteSize(t){const e=Se.fromArgs(t);return wn.toFixedFromValue({accountDiscriminator:Hs,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(Se.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),createKey:this.createKey.toBase58(),vaultIndex:this.vaultIndex,mint:this.mint.toBase58(),amount:(()=>{const t=this.amount;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),period:"Period."+Rn[this.period],remainingAmount:(()=>{const t=this.remainingAmount;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),lastReset:(()=>{const t=this.lastReset;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,members:this.members,destinations:this.destinations}}}const wn=new c.FixableBeetStruct([["accountDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["multisig",F.publicKey],["createKey",F.publicKey],["vaultIndex",c.u8],["mint",F.publicKey],["amount",c.u64],["period",cs],["remainingAmount",c.u64],["lastReset",c.i64],["bump",c.u8],["members",c.array(F.publicKey)],["destinations",c.array(F.publicKey)]],Se.fromArgs,"SpendingLimit"),Fc=new c.FixableBeetArgsStruct([["programIdIndex",c.u8],["accountIndexes",c.bytes],["data",c.bytes]],"MultisigCompiledInstruction"),Dc=new c.FixableBeetArgsStruct([["accountKey",F.publicKey],["writableIndexes",c.bytes],["readonlyIndexes",c.bytes]],"MultisigMessageAddressTableLookup"),Fo=new c.FixableBeetArgsStruct([["numSigners",c.u8],["numWritableSigners",c.u8],["numWritableNonSigners",c.u8],["accountKeys",c.array(F.publicKey)],["instructions",c.array(Fc)],["addressTableLookups",c.array(Dc)]],"VaultTransactionMessage"),Ws=[196,121,46,36,12,19,252,7];class ke{bump;ephemeralSignerBumps;message;constructor(t,e,r){this.bump=t,this.ephemeralSignerBumps=e,this.message=r}static fromArgs(t){return new ke(t.bump,t.ephemeralSignerBumps,t.message)}static fromAccountInfo(t,e=0){return ke.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find VaultBatchTransaction account at ${e}`);return ke.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new z("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(t,xn)}static deserialize(t,e=0){return xn.deserialize(t,e)}serialize(){return xn.serialize({accountDiscriminator:Ws,...this})}static byteSize(t){const e=ke.fromArgs(t);return xn.toFixedFromValue({accountDiscriminator:Ws,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(ke.byteSize(t),r)}pretty(){return{bump:this.bump,ephemeralSignerBumps:this.ephemeralSignerBumps,message:this.message}}}const xn=new c.FixableBeetStruct([["accountDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["bump",c.u8],["ephemeralSignerBumps",c.bytes],["message",Fo]],ke.fromArgs,"VaultBatchTransaction"),Vs=[168,250,162,100,81,14,162,207];class Ie{multisig;creator;index;bump;vaultIndex;vaultBump;ephemeralSignerBumps;message;constructor(t,e,r,s,o,i,u,a){this.multisig=t,this.creator=e,this.index=r,this.bump=s,this.vaultIndex=o,this.vaultBump=i,this.ephemeralSignerBumps=u,this.message=a}static fromArgs(t){return new Ie(t.multisig,t.creator,t.index,t.bump,t.vaultIndex,t.vaultBump,t.ephemeralSignerBumps,t.message)}static fromAccountInfo(t,e=0){return Ie.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find VaultTransaction account at ${e}`);return Ie.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new z("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(t,An)}static deserialize(t,e=0){return An.deserialize(t,e)}serialize(){return An.serialize({accountDiscriminator:Vs,...this})}static byteSize(t){const e=Ie.fromArgs(t);return An.toFixedFromValue({accountDiscriminator:Vs,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(Ie.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const t=this.index;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,vaultIndex:this.vaultIndex,vaultBump:this.vaultBump,ephemeralSignerBumps:this.ephemeralSignerBumps,message:this.message}}}const An=new c.FixableBeetStruct([["accountDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["multisig",F.publicKey],["creator",F.publicKey],["index",c.u64],["bump",c.u8],["vaultIndex",c.u8],["vaultBump",c.u8],["ephemeralSignerBumps",c.bytes],["message",Fo]],Ie.fromArgs,"VaultTransaction"),j=new Map,Z=new Map;class $n extends Error{code=6e3;name="DuplicateMember";constructor(){super("Found multiple members with the same pubkey"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$n)}}j.set(6e3,()=>new $n);Z.set("DuplicateMember",()=>new $n);class On extends Error{code=6001;name="EmptyMembers";constructor(){super("Members array is empty"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,On)}}j.set(6001,()=>new On);Z.set("EmptyMembers",()=>new On);class Hn extends Error{code=6002;name="TooManyMembers";constructor(){super("Too many members, can be up to 65535"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Hn)}}j.set(6002,()=>new Hn);Z.set("TooManyMembers",()=>new Hn);class Wn extends Error{code=6003;name="InvalidThreshold";constructor(){super("Invalid threshold, must be between 1 and number of members with Vote permission"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Wn)}}j.set(6003,()=>new Wn);Z.set("InvalidThreshold",()=>new Wn);class Vn extends Error{code=6004;name="Unauthorized";constructor(){super("Attempted to perform an unauthorized action"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Vn)}}j.set(6004,()=>new Vn);Z.set("Unauthorized",()=>new Vn);class jn extends Error{code=6005;name="NotAMember";constructor(){super("Provided pubkey is not a member of multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,jn)}}j.set(6005,()=>new jn);Z.set("NotAMember",()=>new jn);class Gn extends Error{code=6006;name="InvalidTransactionMessage";constructor(){super("TransactionMessage is malformed."),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Gn)}}j.set(6006,()=>new Gn);Z.set("InvalidTransactionMessage",()=>new Gn);class Zn extends Error{code=6007;name="StaleProposal";constructor(){super("Proposal is stale"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Zn)}}j.set(6007,()=>new Zn);Z.set("StaleProposal",()=>new Zn);class Yn extends Error{code=6008;name="InvalidProposalStatus";constructor(){super("Invalid proposal status"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Yn)}}j.set(6008,()=>new Yn);Z.set("InvalidProposalStatus",()=>new Yn);class Qn extends Error{code=6009;name="InvalidTransactionIndex";constructor(){super("Invalid transaction index"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Qn)}}j.set(6009,()=>new Qn);Z.set("InvalidTransactionIndex",()=>new Qn);class Xn extends Error{code=6010;name="AlreadyApproved";constructor(){super("Member already approved the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Xn)}}j.set(6010,()=>new Xn);Z.set("AlreadyApproved",()=>new Xn);class Jn extends Error{code=6011;name="AlreadyRejected";constructor(){super("Member already rejected the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Jn)}}j.set(6011,()=>new Jn);Z.set("AlreadyRejected",()=>new Jn);class tr extends Error{code=6012;name="AlreadyCancelled";constructor(){super("Member already cancelled the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,tr)}}j.set(6012,()=>new tr);Z.set("AlreadyCancelled",()=>new tr);class er extends Error{code=6013;name="InvalidNumberOfAccounts";constructor(){super("Wrong number of accounts provided"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,er)}}j.set(6013,()=>new er);Z.set("InvalidNumberOfAccounts",()=>new er);class nr extends Error{code=6014;name="InvalidAccount";constructor(){super("Invalid account provided"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,nr)}}j.set(6014,()=>new nr);Z.set("InvalidAccount",()=>new nr);class rr extends Error{code=6015;name="RemoveLastMember";constructor(){super("Cannot remove last member"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,rr)}}j.set(6015,()=>new rr);Z.set("RemoveLastMember",()=>new rr);class sr extends Error{code=6016;name="NoVoters";constructor(){super("Members don't include any voters"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,sr)}}j.set(6016,()=>new sr);Z.set("NoVoters",()=>new sr);class or extends Error{code=6017;name="NoProposers";constructor(){super("Members don't include any proposers"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,or)}}j.set(6017,()=>new or);Z.set("NoProposers",()=>new or);class ir extends Error{code=6018;name="NoExecutors";constructor(){super("Members don't include any executors"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ir)}}j.set(6018,()=>new ir);Z.set("NoExecutors",()=>new ir);class ar extends Error{code=6019;name="InvalidStaleTransactionIndex";constructor(){super("`stale_transaction_index` must be <= `transaction_index`"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ar)}}j.set(6019,()=>new ar);Z.set("InvalidStaleTransactionIndex",()=>new ar);class cr extends Error{code=6020;name="NotSupportedForControlled";constructor(){super("Instruction not supported for controlled multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,cr)}}j.set(6020,()=>new cr);Z.set("NotSupportedForControlled",()=>new cr);class ur extends Error{code=6021;name="TimeLockNotReleased";constructor(){super("Proposal time lock has not been released"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ur)}}j.set(6021,()=>new ur);Z.set("TimeLockNotReleased",()=>new ur);class lr extends Error{code=6022;name="NoActions";constructor(){super("Config transaction must have at least one action"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,lr)}}j.set(6022,()=>new lr);Z.set("NoActions",()=>new lr);class dr extends Error{code=6023;name="MissingAccount";constructor(){super("Missing account"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,dr)}}j.set(6023,()=>new dr);Z.set("MissingAccount",()=>new dr);class fr extends Error{code=6024;name="InvalidMint";constructor(){super("Invalid mint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,fr)}}j.set(6024,()=>new fr);Z.set("InvalidMint",()=>new fr);class hr extends Error{code=6025;name="InvalidDestination";constructor(){super("Invalid destination"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,hr)}}j.set(6025,()=>new hr);Z.set("InvalidDestination",()=>new hr);class gr extends Error{code=6026;name="SpendingLimitExceeded";constructor(){super("Spending limit exceeded"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,gr)}}j.set(6026,()=>new gr);Z.set("SpendingLimitExceeded",()=>new gr);class pr extends Error{code=6027;name="DecimalsMismatch";constructor(){super("Decimals don't match the mint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pr)}}j.set(6027,()=>new pr);Z.set("DecimalsMismatch",()=>new pr);class mr extends Error{code=6028;name="UnknownPermission";constructor(){super("Member has unknown permission"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,mr)}}j.set(6028,()=>new mr);Z.set("UnknownPermission",()=>new mr);class yr extends Error{code=6029;name="ProtectedAccount";constructor(){super("Account is protected, it cannot be passed into a CPI as writable"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,yr)}}j.set(6029,()=>new yr);Z.set("ProtectedAccount",()=>new yr);class br extends Error{code=6030;name="TimeLockExceedsMaxAllowed";constructor(){super("Time lock exceeds the maximum allowed (90 days)"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,br)}}j.set(6030,()=>new br);Z.set("TimeLockExceedsMaxAllowed",()=>new br);class wr extends Error{code=6031;name="IllegalAccountOwner";constructor(){super("Account is not owned by Multisig program"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,wr)}}j.set(6031,()=>new wr);Z.set("IllegalAccountOwner",()=>new wr);class xr extends Error{code=6032;name="RentReclamationDisabled";constructor(){super("Rent reclamation is disabled for this multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,xr)}}j.set(6032,()=>new xr);Z.set("RentReclamationDisabled",()=>new xr);class Ar extends Error{code=6033;name="InvalidRentCollector";constructor(){super("Invalid rent collector address"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ar)}}j.set(6033,()=>new Ar);Z.set("InvalidRentCollector",()=>new Ar);class Sr extends Error{code=6034;name="ProposalForAnotherMultisig";constructor(){super("Proposal is for another multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Sr)}}j.set(6034,()=>new Sr);Z.set("ProposalForAnotherMultisig",()=>new Sr);class kr extends Error{code=6035;name="TransactionForAnotherMultisig";constructor(){super("Transaction is for another multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,kr)}}j.set(6035,()=>new kr);Z.set("TransactionForAnotherMultisig",()=>new kr);class Ir extends Error{code=6036;name="TransactionNotMatchingProposal";constructor(){super("Transaction doesn't match proposal"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ir)}}j.set(6036,()=>new Ir);Z.set("TransactionNotMatchingProposal",()=>new Ir);class Br extends Error{code=6037;name="TransactionNotLastInBatch";constructor(){super("Transaction is not last in batch"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Br)}}j.set(6037,()=>new Br);Z.set("TransactionNotLastInBatch",()=>new Br);class vr extends Error{code=6038;name="BatchNotEmpty";constructor(){super("Batch is not empty"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,vr)}}j.set(6038,()=>new vr);Z.set("BatchNotEmpty",()=>new vr);class Er extends Error{code=6039;name="SpendingLimitInvalidAmount";constructor(){super("Invalid SpendingLimit amount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Er)}}j.set(6039,()=>new Er);Z.set("SpendingLimitInvalidAmount",()=>new Er);function Nc(n){const t=j.get(n);return t!=null?t():null}new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)]],"BatchAccountsCloseInstructionArgs");const qc=new c.FixableBeetArgsStruct([["ephemeralSigners",c.u8],["transactionMessage",c.bytes]],"BatchAddTransactionArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",qc]],"BatchAddTransactionInstructionArgs");const Uc=new c.FixableBeetArgsStruct([["vaultIndex",c.u8],["memo",c.coption(c.utf8String)]],"BatchCreateArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",Uc]],"BatchCreateInstructionArgs");new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)]],"BatchExecuteTransactionInstructionArgs");new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)]],"ConfigTransactionAccountsCloseInstructionArgs");const $c=new c.FixableBeetArgsStruct([["actions",c.array(Po)],["memo",c.coption(c.utf8String)]],"ConfigTransactionCreateArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",$c]],"ConfigTransactionCreateInstructionArgs");new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)]],"ConfigTransactionExecuteInstructionArgs");const Oc=new c.FixableBeetArgsStruct([["newMember",cn],["memo",c.coption(c.utf8String)]],"MultisigAddMemberArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",Oc]],"MultisigAddMemberInstructionArgs");const Hc=new c.FixableBeetArgsStruct([["createKey",F.publicKey],["vaultIndex",c.u8],["mint",F.publicKey],["amount",c.u64],["period",cs],["members",c.array(F.publicKey)],["destinations",c.array(F.publicKey)],["memo",c.coption(c.utf8String)]],"MultisigAddSpendingLimitArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",Hc]],"MultisigAddSpendingLimitInstructionArgs");const Wc=new c.FixableBeetArgsStruct([["newThreshold",c.u16],["memo",c.coption(c.utf8String)]],"MultisigChangeThresholdArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",Wc]],"MultisigChangeThresholdInstructionArgs");const Vc=new c.FixableBeetArgsStruct([["configAuthority",c.coption(F.publicKey)],["threshold",c.u16],["members",c.array(cn)],["timeLock",c.u32],["memo",c.coption(c.utf8String)]],"MultisigCreateArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",Vc]],"MultisigCreateInstructionArgs");const jc=new c.FixableBeetArgsStruct([["configAuthority",c.coption(F.publicKey)],["threshold",c.u16],["members",c.array(cn)],["timeLock",c.u32],["rentCollector",c.coption(F.publicKey)],["memo",c.coption(c.utf8String)]],"MultisigCreateArgsV2");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",jc]],"MultisigCreateV2InstructionArgs");const Gc=new c.FixableBeetArgsStruct([["oldMember",F.publicKey],["memo",c.coption(c.utf8String)]],"MultisigRemoveMemberArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",Gc]],"MultisigRemoveMemberInstructionArgs");const Zc=new c.FixableBeetArgsStruct([["memo",c.coption(c.utf8String)]],"MultisigRemoveSpendingLimitArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",Zc]],"MultisigRemoveSpendingLimitInstructionArgs");const Yc=new c.FixableBeetArgsStruct([["configAuthority",F.publicKey],["memo",c.coption(c.utf8String)]],"MultisigSetConfigAuthorityArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",Yc]],"MultisigSetConfigAuthorityInstructionArgs");const Qc=new c.FixableBeetArgsStruct([["rentCollector",c.coption(F.publicKey)],["memo",c.coption(c.utf8String)]],"MultisigSetRentCollectorArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",Qc]],"MultisigSetRentCollectorInstructionArgs");const Xc=new c.FixableBeetArgsStruct([["timeLock",c.u32],["memo",c.coption(c.utf8String)]],"MultisigSetTimeLockArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",Xc]],"MultisigSetTimeLockInstructionArgs");const Jc=new c.BeetArgsStruct([["authority",F.publicKey],["multisigCreationFee",c.u64],["treasury",F.publicKey]],"ProgramConfigInitArgs");new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",Jc]],"ProgramConfigInitInstructionArgs");const tu=new c.BeetArgsStruct([["newAuthority",F.publicKey]],"ProgramConfigSetAuthorityArgs");new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",tu]],"ProgramConfigSetAuthorityInstructionArgs");const eu=new c.BeetArgsStruct([["newMultisigCreationFee",c.u64]],"ProgramConfigSetMultisigCreationFeeArgs");new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",eu]],"ProgramConfigSetMultisigCreationFeeInstructionArgs");const nu=new c.BeetArgsStruct([["newTreasury",F.publicKey]],"ProgramConfigSetTreasuryArgs");new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",nu]],"ProgramConfigSetTreasuryInstructionArgs");new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)]],"ProposalActivateInstructionArgs");const us=new c.FixableBeetArgsStruct([["memo",c.coption(c.utf8String)]],"ProposalVoteArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",us]],"ProposalApproveInstructionArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",us]],"ProposalCancelInstructionArgs");const ru=new c.BeetArgsStruct([["transactionIndex",c.u64],["draft",c.bool]],"ProposalCreateArgs");new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",ru]],"ProposalCreateInstructionArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",us]],"ProposalRejectInstructionArgs");const su=new c.FixableBeetArgsStruct([["amount",c.u64],["decimals",c.u8],["memo",c.coption(c.utf8String)]],"SpendingLimitUseArgs");new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",su]],"SpendingLimitUseInstructionArgs");new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)]],"VaultBatchTransactionAccountCloseInstructionArgs");new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)]],"VaultTransactionAccountsCloseInstructionArgs");const ou=new c.FixableBeetArgsStruct([["vaultIndex",c.u8],["ephemeralSigners",c.u8],["transactionMessage",c.bytes],["memo",c.coption(c.utf8String)]],"VaultTransactionCreateArgs"),iu=new c.FixableBeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)],["args",ou]],"VaultTransactionCreateInstructionArgs"),au=[48,250,78,168,208,226,218,211];function cu(n,t,e=new z("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){const[r]=iu.serialize({instructionDiscriminator:au,...t}),s=[{pubkey:n.multisig,isWritable:!0,isSigner:!1},{pubkey:n.transaction,isWritable:!0,isSigner:!1},{pubkey:n.creator,isWritable:!1,isSigner:!0},{pubkey:n.rentPayer,isWritable:!0,isSigner:!0},{pubkey:n.systemProgram??en.programId,isWritable:!1,isSigner:!1}];if(n.anchorRemainingAccounts!=null)for(const i of n.anchorRemainingAccounts)s.push(i);return new qt({programId:e,keys:s,data:r})}new c.BeetArgsStruct([["instructionDiscriminator",c.uniformFixedSizeArray(c.u8,8)]],"VaultTransactionExecuteInstructionArgs");var Vr;(function(n){n[n.Approve=0]="Approve",n[n.Reject=1]="Reject",n[n.Cancel=2]="Cancel"})(Vr||(Vr={}));c.fixedScalarEnum(Vr);const uu="SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf",ls=new z(uu);ci.initCusper(Nc);var lu=function(n,t,e,r,s,o,i,u){if(!n){var a;if(t===void 0)a=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var l=[e,r,s,o,i,u],d=0;a=new Error(t.replace(/%s/g,function(){return l[d++]})),a.name="Invariant Violation"}throw a.framesToPop=1,a}},zn=lu;function js(n,t,e){const r=t.length,s=r===0?"<EMPTY>":t[0].description;return{write:function(o,i,u){zn(u.length===r,`array length ${u.length} should match len ${r}`),n.write(o,i,r);let a=i+n.byteSize;for(let l=0;l<r;l++){const d=t[l];d.write(o,a,u[l]),a+=d.byteSize}},read:function(o,i){const u=n.read(o,i);zn(u===r,"invalid byte size");let a=i+n.byteSize;const l=new Array(r);for(let d=0;d<r;d++){const f=t[d];l[d]=f.read(o,a),a+=f.byteSize}return l},byteSize:n.byteSize+e,length:r,description:`Array<${s}>(${r})[ ${n.byteSize} + ${e} ]`}}function Ee(n,t){return{toFixedFromData(e,r){const s=n.read(e,r),o=r+n.byteSize;let i=o;const u=new Array(s);for(let a=0;a<s;a++){const l=c.fixBeetFromData(t,e,i);u[a]=l,i+=l.byteSize}return js(n,u,i-o)},toFixedFromValue(e){zn(Array.isArray(e),`${e} should be an array`);let r=0;const s=new Array(e.length);for(let o=0;o<e.length;o++){const i=c.fixBeetFromValue(t,e[o]);s[o]=i,r+=i.byteSize}return js(n,s,r)},description:"smallArray"}}const du=new c.FixableBeetArgsStruct([["programIdIndex",c.u8],["accountIndexes",Ee(c.u8,c.u8)],["data",Ee(c.u16,c.u8)]],"CompiledMsInstruction"),fu=new c.FixableBeetArgsStruct([["accountKey",F.publicKey],["writableIndexes",Ee(c.u8,c.u8)],["readonlyIndexes",Ee(c.u8,c.u8)]],"MessageAddressTableLookup"),hu=new c.FixableBeetArgsStruct([["numSigners",c.u8],["numWritableSigners",c.u8],["numWritableNonSigners",c.u8],["accountKeys",Ee(c.u8,F.publicKey)],["instructions",Ee(c.u8,du)],["addressTableLookups",Ee(c.u8,fu)]],"TransactionMessage");class ds{payer;keyMetaMap;constructor(t,e){this.payer=t,this.keyMetaMap=e}static compile(t,e){const r=new Map,s=i=>{const u=i.toBase58();let a=r.get(u);return a===void 0&&(a={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(u,a)),a},o=s(e);o.isSigner=!0,o.isWritable=!0;for(const i of t){s(i.programId).isInvoked=!1;for(const u of i.keys){const a=s(u.pubkey);a.isSigner||=u.isSigner,a.isWritable||=u.isWritable}}return new ds(e,r)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];ln(t.length<=256,"Max static account keys length exceeded");const e=t.filter(([,a])=>a.isSigner&&a.isWritable),r=t.filter(([,a])=>a.isSigner&&!a.isWritable),s=t.filter(([,a])=>!a.isSigner&&a.isWritable),o=t.filter(([,a])=>!a.isSigner&&!a.isWritable),i={numRequiredSignatures:e.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{ln(e.length>0,"Expected at least one writable signer key");const[a]=e[0];ln(a===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const u=[...e.map(([a])=>new z(a)),...r.map(([a])=>new z(a)),...s.map(([a])=>new z(a)),...o.map(([a])=>new z(a))];return[i,u]}extractTableLookup(t){const[e,r]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(e.length===0&&s.length===0))return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:s},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(t,e){const r=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(e(i)){const u=new z(o),a=t.findIndex(l=>l.equals(u));a>=0&&(ln(a<256,"Max lookup table index exceeded"),r.push(a),s.push(u),this.keyMetaMap.delete(o))}return[r,s]}}function gu({payerKey:n,recentBlockhash:t,instructions:e,addressLookupTableAccounts:r}){const s=ds.compile(e,n),o=new Array,i={writable:[],readonly:[]},u=r||[];for(const A of u){const I=s.extractTableLookup(A);if(I!==void 0){const[b,{writable:h,readonly:p}]=I;o.push(b),i.writable.push(...h),i.readonly.push(...p)}}const[a,l]=s.getMessageComponents(),f=new Je(l,i).compileInstructions(e);return new Tn({header:a,staticAccountKeys:l,recentBlockhash:t,compiledInstructions:f,addressTableLookups:o})}function ie(n){return new TextEncoder().encode(n)}function pu(n){const t=V.Buffer.alloc(1);return c.u8.write(t,0,n),t}function mu(n){const t=V.Buffer.alloc(8);return c.u64.write(t,0,n),t}function yu({message:n,addressLookupTableAccounts:t,vaultPda:e}){const r=gu({payerKey:n.payerKey,recentBlockhash:n.recentBlockhash,instructions:n.instructions,addressLookupTableAccounts:t}),[s]=hu.serialize({numSigners:r.header.numRequiredSignatures,numWritableSigners:r.header.numRequiredSignatures-r.header.numReadonlySignedAccounts,numWritableNonSigners:r.staticAccountKeys.length-r.header.numRequiredSignatures-r.header.numReadonlyUnsignedAccounts,accountKeys:r.staticAccountKeys,instructions:r.compiledInstructions.map(o=>({programIdIndex:o.programIdIndex,accountIndexes:o.accountKeyIndexes,data:Array.from(o.data)})),addressTableLookups:r.addressTableLookups});return s}const Do=ie("multisig");ie("program_config");ie("multisig");const bu=ie("vault"),wu=ie("transaction");ie("proposal");ie("batch_transaction");ie("ephemeral_signer");ie("spending_limit");function Cn({multisigPda:n,index:t,programId:e=ls}){return zn(t>=0&&t<256,"Invalid vault index"),z.findProgramAddressSync([Do,n.toBytes(),bu,pu(t)],e)}function xu({multisigPda:n,index:t,programId:e=ls}){return z.findProgramAddressSync([Do,n.toBytes(),wu,mu(t)],e)}function Au({multisigPda:n,transactionIndex:t,creator:e,rentPayer:r,vaultIndex:s,ephemeralSigners:o,transactionMessage:i,addressLookupTableAccounts:u,memo:a,programId:l=ls}){const[d]=Cn({multisigPda:n,index:s,programId:l}),[f]=xu({multisigPda:n,index:t,programId:l}),A=yu({message:i,addressLookupTableAccounts:u,vaultPda:d});return cu({multisig:n,transaction:f,creator:e,rentPayer:r??e},{args:{vaultIndex:s,ephemeralSigners:o,transactionMessage:A,memo:a??null}},l)}const Sn=new Lt("ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx"),Gs=new Lt("poLisWXnNRwC6oBu1vHiuKQzFjGL4XDSu4g9qjz9qVk"),Su=new Lt("ATLkZsBofSKG845dNFpNoUyMciGpeH29BCbMqYFUoxzU"),de=new Lt("ATLocKpzDbTokxgvnLew3d7drZkEzLzDpzwgrgWKDbmc");class ku{multisigPDA;vaultPDA;registeredStakeAtlas;stakingAccountAtlas;async init(t){this.multisigPDA=t,this._setVaultPDA(),await this._setRegisteredStakeAtlas(),await this._setStakingAccountAtlas()}_setVaultPDA(){const[t]=Cn({multisigPda:new Lt(this.multisigPDA),index:0});this.vaultPDA=t}async _setRegisteredStakeAtlas(){const[t]=await Ut.getRegisteredStake(de,Su,Sn,Gs);this.registeredStakeAtlas=t}async _setStakingAccountAtlas(){const[t]=await Ut.getStakingAccount(de,this.vaultPDA,this.registeredStakeAtlas);this.stakingAccountAtlas=t}async buildCreateStatingAccount(){return await Ut.createStakingAccountInstruction({connection:_t().connection,user:this.vaultPDA,registeredStake:this.registeredStakeAtlas,programId:de})}async buildStakeTokens(t){const[e]=Lt.findProgramAddressSync([this.vaultPDA.toBuffer(),fi.toBuffer(),Sn.toBuffer()],di.ASSOCIATED_PROGRAM_ID);return await Ut.stakeTokensInstruction({connection:_t().connection,user:this.vaultPDA,stakeMint:Sn,tokenSource:e,stakingAccount:this.stakingAccountAtlas,stakeQuantity:new Dr(parseFloat(t.toString())*Math.pow(10,No)),registeredStake:this.registeredStakeAtlas,programId:de})}async buildHarvestRewards(){return await Ut.harvestRewardsInstruction({connection:_t().connection,user:this.vaultPDA,rewardMint:Gs,registeredStake:this.registeredStakeAtlas,stakingAccount:this.stakingAccountAtlas,programId:de})}async buildWithdrawTokens(){return await Ut.withdrawTokensInstruction({connection:_t().connection,user:this.vaultPDA,authority:this.vaultPDA,stakeMint:Sn,registeredStake:this.registeredStakeAtlas,stakingAccount:this.stakingAccountAtlas,programId:de})}async buildUnstakeTokens(){return await Ut.unstakeTokensInstruction({connection:_t().connection,user:this.vaultPDA,registeredStake:this.registeredStakeAtlas,stakingAccount:this.stakingAccountAtlas,programId:de})}async buildCancelUnstake(){return await Ut.cancelUnstakeInstruction({connection:_t().connection,user:this.vaultPDA,registeredStake:this.registeredStakeAtlas,programId:de})}}const Ke="[ATLAS-LOCKER] ",No=8,Ge=new Lt("ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx"),Kn=new Lt("poLisWXnNRwC6oBu1vHiuKQzFjGL4XDSu4g9qjz9qVk"),kn=new Lt("ATLocKpzDbTokxgvnLew3d7drZkEzLzDpzwgrgWKDbmc"),Zs=new Lt("ATLkZsBofSKG845dNFpNoUyMciGpeH29BCbMqYFUoxzU"),P=ei("globalStarAtlasLockerStore",{state:()=>({multisigPDA:ni("multisigPDA",""),vaultPDA:{},multisigInfo:{},registeredStakeAtlas:{},registeredStakePolis:{},stakingAccountAtlas:{},stakingAccountAtlasInfo:{},atlas_balance_wallet:"0",polis_balance_wallet:"0",atlas_balance_squads:"0",polis_balance_squads:"0",atlas_balance_locker:"0",polis_balance_locker:"0",SAFactory_LockerAtlas:new ku}),getters:{getMultisigPDA(n){return new Lt(n.multisigPDA)},getVaultPDA(){try{const[n]=Cn({multisigPda:new Lt(this.multisigPDA),index:0});return n}catch{return""}},getNewTransactionIndex(n){const t=Number(n.multisigInfo.transactionIndex);return BigInt(t+1)}},actions:{async setAccounts(){P().atlas_balance_wallet="0",P().polis_balance_wallet="0",P().atlas_balance_squads="0",P().polis_balance_squads="0",P().atlas_balance_locker="0",P().polis_balance_locker="0",P().stakingAccountAtlasInfo=void 0;const[n]=Cn({multisigPda:new Lt(this.multisigPDA),index:0});this.vaultPDA=n,this.multisigInfo=await he.fromAccountAddress(_t().connection,new Lt(this.multisigPDA));const[t]=await Ut.getRegisteredStake(kn,Zs,Ge,Kn);this.registeredStakeAtlas=t;const[e]=await Ut.getRegisteredStake(kn,Zs,Ge,Kn);this.registeredStakePolis=e;try{const[r]=await Ut.getStakingAccount(kn,this.vaultPDA,this.registeredStakeAtlas);this.stakingAccountAtlas=r}catch{}try{this.stakingAccountAtlasInfo=await Ut.getStakingAccountInfo(_t().connection,this.stakingAccountAtlas,kn)}catch{}await Iu()},async build_CreateStatingAccount(){await this.SAFactory_LockerAtlas.init(this.multisigPDA),await Me(Ke+"CreateStatingAccount: "+ui,[(await this.SAFactory_LockerAtlas.buildCreateStatingAccount()).instructions[0]])},async build_StakeTokens(n){await this.SAFactory_LockerAtlas.init(this.multisigPDA),await Me(Ke+"StakeTokens: "+n,[(await this.SAFactory_LockerAtlas.buildStakeTokens(n)).instructions[0]])},async build_harvestRewards(){await this.SAFactory_LockerAtlas.init(this.multisigPDA),await Me(Ke+"HarvestRewards",[(await this.SAFactory_LockerAtlas.buildHarvestRewards()).instructions[0]])},async build_withdrawTokens(){await this.SAFactory_LockerAtlas.init(this.multisigPDA),await Me(Ke+"WithdrawTokens",[(await this.SAFactory_LockerAtlas.buildWithdrawTokens()).instructions[0]])},async build_unstakeTokens(){await this.SAFactory_LockerAtlas.init(this.multisigPDA),await Me(Ke+"UnstakeTokens",[(await this.SAFactory_LockerAtlas.buildUnstakeTokens()).instructions[0]])},async build_cancelUnstake(){await this.SAFactory_LockerAtlas.init(this.multisigPDA),await Me(Ke+"CancelUnstake",[(await this.SAFactory_LockerAtlas.buildCancelUnstake()).instructions[0]])}}});async function Me(n,t){const{sendTransaction:e,publicKey:r}=Ze(),s=new ri({payerKey:P().vaultPDA,recentBlockhash:(await _t().connection.getLatestBlockhash()).blockhash,instructions:t}),o=Au({multisigPda:new Lt(P().multisigPDA),transactionIndex:P().getNewTransactionIndex,creator:r.value,vaultIndex:0,ephemeralSigners:0,transactionMessage:s,memo:n});console.log("build: "+n);const i=await e(new si().add(o),_t().connection);await li(i)}async function Iu(){const{publicKey:n}=Ze();if(!n.value)return;const t=await je(Ge,n.value),e=await je(Kn,n.value),r=await je(Ge,P().vaultPDA,!0),s=await je(Kn,P().vaultPDA,!0),o=await je(Ge,P().stakingAccountAtlas,!0);try{P().atlas_balance_wallet=(await _t().connection.getTokenAccountBalance(t)).value.uiAmountString??"0"}catch{P().atlas_balance_wallet="-"}try{P().polis_balance_wallet=(await _t().connection.getTokenAccountBalance(e)).value.uiAmountString??"0"}catch{P().polis_balance_wallet="-"}try{P().atlas_balance_squads=(await _t().connection.getTokenAccountBalance(r)).value.uiAmountString??"0"}catch{P().atlas_balance_squads="-"}try{P().polis_balance_squads=(await _t().connection.getTokenAccountBalance(s)).value.uiAmountString??"0"}catch{P().polis_balance_squads="-"}try{P().atlas_balance_locker=(await _t().connection.getTokenAccountBalance(o)).value.uiAmountString??""}catch{P().atlas_balance_locker="-"}}const Bu=w("div",{class:"text-h6 text-weight-thin"}," This Tool is build for easy interaction between StarAtlasLockers using a Squads.so multi signature account! ",-1),vu=w("div",{class:"text-subtitle1"}," Please enter the required information so send instructions to your Squads Account ",-1),Eu=w("div",{class:"text-subtitle2 text-weight-thin text-orange-5"}," You will still need to approve the transaction in you squads account! ",-1),Tu={class:"row q-gutter-x-sm items-center"},_u={class:"col"},Lu=w("div",{class:"col text-weight-light"}," Squads.so -> Settings -> Multisig Account ",-1),Ru={class:"row q-gutter-x-sm items-center"},zu={class:"col"},Cu=w("div",{class:"col text-weight-light"},"Your Squads Account",-1),Ku={class:"row items-center"},Mu=w("div",{class:"text-subtitle1"},"Squads Multisig Info",-1),Pu={key:0},Fu=w("div",{class:"text-subtitle2"},"Members",-1),Du=w("div",{class:"row"},[w("div",{class:"col"},"Member Address"),w("div",null,"Permission")],-1),Nu={class:"row"},qu={class:"col"},Uu=Mn({__name:"SetupLockerView",setup(n){return(t,e)=>(ht(),se(jr,{flat:""},{default:St(()=>[tt(ge,null,{default:St(()=>[Bu]),_:1}),tt(ge,null,{default:St(()=>[vu,Eu]),_:1}),tt(ge,{class:"q-gutter-y-sm"},{default:St(()=>[w("div",Tu,[w("div",_u,[tt(Fr,{dense:"",standout:"",modelValue:rt(P)().multisigPDA,"onUpdate:modelValue":e[0]||(e[0]=r=>rt(P)().multisigPDA=r),label:"MultisigPDA"},null,8,["modelValue"])]),Lu]),w("div",Ru,[w("div",zu,[tt(Fr,{disable:"",dense:"",standout:"",modelValue:rt(P)().getVaultPDA,"onUpdate:modelValue":e[1]||(e[1]=r=>rt(P)().getVaultPDA=r),label:"VaultPDA"},null,8,["modelValue"])]),Cu])]),_:1}),tt(ge,null,{default:St(()=>{var r,s;return[w("div",Ku,[Mu,tt(Zo),tt(me,{square:"",color:"primary",label:"Update Squads info",onClick:e[2]||(e[2]=o=>rt(P)().setAccounts())})]),(s=(r=rt(P)().multisigInfo)==null?void 0:r.members)!=null&&s.length?(ht(),Pt("div",Pu,[Fu,tt(ai,{dense:"",bordered:"",padding:"",class:"rounded-borders"},{default:St(()=>[ws((ht(),se(As,null,{default:St(()=>[tt(Ss,null,{default:St(()=>[Du]),_:1})]),_:1})),[[xs]]),(ht(!0),Pt(Qs,null,Xs(rt(P)().multisigInfo.members,o=>ws((ht(),se(As,{clickable:"",key:o.key},{default:St(()=>[tt(Ss,null,{default:St(()=>[w("div",Nu,[w("div",qu,Et(o.key),1),w("div",null,Et(o.permissions.mask),1)])]),_:2},1024)]),_:2},1024)),[[xs]])),128))]),_:1})])):In("",!0)]}),_:1})]),_:1}))}}),$u={class:"row"},Ou={class:"col-1"},Hu={class:"col"},Wu={class:"row q-pr-md items-center"},Vu=w("div",{class:"col text-right text-subtitle2 text-weight-light"},[w("div",null,"Squads Vault Account")],-1),ju={class:"col text-right text-subtitle1"},Gu={class:"row q-pr-md items-center"},Zu=w("div",{class:"col text-right text-subtitle2 text-weight-light"},[w("div",null,"Squads Registered Stake")],-1),Yu={class:"col text-right text-subtitle1"},Qu={class:"row q-pr-md items-center"},Xu=w("div",{class:"col text-right text-subtitle2 text-weight-light"},[w("div",null,"Squads Staking Account")],-1),Ju={class:"col text-right text-subtitle1"},tl=w("div",{class:"row items-center q-mx-md"},[w("div",{class:"col"},[w("div",{class:"text-h4"},"Instruction")]),w("div",{class:"col-4"},[w("div",{class:"text-h4 text-center"},"Action")])],-1),el={class:"row items-center q-mx-md"},nl=w("div",{class:"col"},[w("div",{class:"text-h6"},"Create Staking Account"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will create a new locker instance for you ")],-1),rl={class:"col-4"},sl={class:"row items-center q-mx-md"},ol=w("div",{class:"col"},[w("div",{class:"text-h6"},"Stake Tokens"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will stake additional tokens ")],-1),il={class:"col-4"},al={class:"row q-gutter-x-xs"},cl={class:"row items-center q-mx-md"},ul=w("div",{class:"col"},[w("div",{class:"col text-h6"},"Harvest"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will claim your rewards ")],-1),ll={class:"col-4"},dl={class:"row items-center q-mx-md"},fl=w("div",{class:"col"},[w("div",{class:"text-h6"},"Unstake Tokens"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will initiate unstake of all tokens ")],-1),hl={class:"col-4"},gl={class:"row items-center q-mx-md"},pl=w("div",{class:"col"},[w("div",{class:"text-h6"},"Cancel Unstake"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will cancel unstake of all tokens ")],-1),ml={class:"col-4"},yl={class:"row items-center q-mx-md"},bl=w("div",{class:"col"},[w("div",{class:"text-h6"},"Withdraw Tokens"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will withdraw of all tokens after unstake ")],-1),wl={class:"col-4"},xl={class:"row items-center"},Al=w("div",{class:"col-1 text-h5"},"Locker Info",-1),Sl={key:0,class:"col"},kl={class:"col text-right text-subtitle2 text-weight-light"},Il={class:"col text-right text-subtitle1"},Bl={key:0},vl={key:1},El={key:0},Tl={key:1},_l={key:2},Ll={key:1,class:"text-subtitle2 text-center"},Rl=Mn({__name:"AtlasLockerView",setup(n){const t=Js(0);return to(async()=>{await P().setAccounts()}),(e,r)=>(ht(),se(jr,{flat:""},{default:St(()=>[tt(ge,null,{default:St(()=>[w("div",$u,[w("div",Ou,[tt(hi,{src:"/currencies/ATLAS.webp"})]),tt(dn,{class:"q-mx-sm",vertical:""}),w("div",Hu,[w("div",Wu,[Vu,w("div",ju,[w("div",null,Et(rt(P)().vaultPDA),1)])]),w("div",Gu,[Zu,w("div",Yu,[w("div",null,Et(rt(P)().registeredStakeAtlas),1)])]),w("div",Qu,[Xu,w("div",Ju,[w("div",null,Et(rt(P)().stakingAccountAtlas),1)])])])])]),_:1}),tt(ge,null,{default:St(()=>[tl,tt(dn,{class:"q-my-sm"}),w("div",el,[nl,w("div",rl,[tt(me,{class:"full-width",square:"",label:"Sign",color:"primary",onClick:r[0]||(r[0]=s=>rt(P)().build_CreateStatingAccount())})])]),w("div",sl,[ol,w("div",il,[w("div",al,[tt(Fr,{dense:"",square:"",class:"col",standout:"",type:"number",modelValue:t.value,"onUpdate:modelValue":r[1]||(r[1]=s=>t.value=s),label:"Amount to stake"},null,8,["modelValue"]),tt(me,{square:"",class:"col-3",label:"Sign",color:"primary",onClick:r[2]||(r[2]=s=>rt(P)().build_StakeTokens(t.value))})])])]),w("div",cl,[ul,w("div",ll,[tt(me,{class:"full-width",label:"Sign",color:"primary",onClick:r[3]||(r[3]=s=>rt(P)().build_harvestRewards())})])]),w("div",dl,[fl,w("div",hl,[tt(me,{class:"full-width",label:"Sign",color:"primary",onClick:r[4]||(r[4]=s=>rt(P)().build_unstakeTokens())})])]),w("div",gl,[pl,w("div",ml,[tt(me,{class:"full-width",label:"Sign",color:"primary",onClick:r[5]||(r[5]=s=>rt(P)().build_cancelUnstake())})])]),w("div",yl,[bl,w("div",wl,[tt(me,{class:"full-width",label:"Sign",color:"primary",onClick:r[6]||(r[6]=s=>rt(P)().build_withdrawTokens())})])])]),_:1}),tt(ge,null,{default:St(()=>[tt(dn,{class:"q-my-sm"}),w("div",xl,[Al,tt(dn,{class:"q-mx-sm",vertical:""}),rt(P)().stakingAccountAtlasInfo?(ht(),Pt("div",Sl,[(ht(!0),Pt(Qs,null,Xs(Object.keys(rt(P)().stakingAccountAtlasInfo),(s,o)=>(ht(),Pt("div",{class:"row q-pr-md items-center",key:o},[w("div",kl,[w("div",null,Et(s),1)]),w("div",Il,[["totalStake","activeStake","paidRewards","pendingRewards"].includes(s)?(ht(),Pt("div",Bl,Et(parseInt(rt(P)().stakingAccountAtlasInfo[s])*Math.pow(10,-rt(No))),1)):["stakedAtTs","lastPendingRewardCalcTs","lastHarvestTs","unstakedTs"].includes(s)?(ht(),Pt("div",vl,[parseInt(rt(P)().stakingAccountAtlasInfo[s])==0?(ht(),Pt("div",El," - ")):(ht(),Pt("div",Tl,Et(new Date(parseInt(rt(P)().stakingAccountAtlasInfo[s])*1e3).toLocaleString()),1))])):(ht(),Pt("div",_l,Et(rt(P)().stakingAccountAtlasInfo[s]),1))])]))),128))])):(ht(),Pt("div",Ll,"No Locker found!"))])]),_:1})]),_:1}))}}),zl={};function Cl(n,t){return"!Under construction!"}var Kl=gi(zl,[["render",Cl]]);const Ml={class:"row"},Pl=w("div",{class:"col-3"},"Wallet",-1),Fl={class:"col"},Dl={class:"row q-gutter-x-xs no-wrap justify-end"},Nl=w("div",null,"Atlas",-1),ql={class:"col"},Ul={class:"row q-gutter-x-xs no-wrap justify-end"},$l=w("div",null,"Polis",-1),Ol={class:"row"},Hl=w("div",{class:"col-3"},"Squads",-1),Wl={class:"col"},Vl={class:"row q-gutter-x-xs no-wrap justify-end"},jl=w("div",null,"Atlas",-1),Gl={class:"col"},Zl={class:"row q-gutter-x-xs no-wrap justify-end"},Yl=w("div",null,"Polis",-1),Ql={class:"row"},Xl=w("div",{class:"col-3"},"Locker",-1),Jl={class:"col"},td={class:"row q-gutter-x-xs no-wrap justify-end"},ed=w("div",null,"Atlas",-1),nd={class:"col"},rd={class:"row q-gutter-x-xs no-wrap justify-end"},sd=w("div",null,"Polis",-1),od=Mn({__name:"TokenLockerBalances",setup(n){return to(async()=>{Ze().publicKey.value&&await P().setAccounts()}),oi(()=>Ze().publicKey.value,async()=>{await P().setAccounts()}),(t,e)=>(ht(),se(jr,{class:""},{default:St(()=>[tt(ge,null,{default:St(()=>[w("div",Ml,[Pl,w("div",Fl,[w("div",Dl,[w("div",null,Et(rt(P)().atlas_balance_wallet),1),Nl])]),w("div",ql,[w("div",Ul,[w("div",null,Et(rt(P)().polis_balance_wallet),1),$l])])]),w("div",Ol,[Hl,w("div",Wl,[w("div",Vl,[w("div",null,Et(rt(P)().atlas_balance_squads),1),jl])]),w("div",Gl,[w("div",Zl,[w("div",null,Et(rt(P)().polis_balance_squads),1),Yl])])]),w("div",Ql,[Xl,w("div",Jl,[w("div",td,[w("div",null,Et(rt(P)().atlas_balance_locker),1),ed])]),w("div",nd,[w("div",rd,[w("div",null,Et(rt(P)().polis_balance_locker),1),sd])])])]),_:1})]),_:1}))}}),id={key:0,class:"col absolute-center"},ad={key:1},cd=w("div",{class:"col"},null,-1),Td=Mn({__name:"StarAtlasLocker",setup(n){const t=Js("setup");return(e,r)=>(ht(),se(Go,{class:"bg-black"},{default:St(()=>{var s,o;return[(o=(s=rt(Ze)().publicKey)==null?void 0:s.value)!=null&&o.toString()?(ht(),Pt("div",ad,[tt(jo,{modelValue:t.value,"onUpdate:modelValue":r[0]||(r[0]=i=>t.value=i),align:"left",class:""},{default:St(()=>[tt(_r,{name:"setup",label:"Setup"}),tt(_r,{name:"atlas",label:"Atlas"}),tt(_r,{name:"polis",label:"Polis"}),cd,tt(od,{class:"q-pr-md col"})]),_:1},8,["modelValue"]),t.value=="setup"?(ht(),se(Uu,{key:0})):In("",!0),t.value=="atlas"?(ht(),se(Rl,{key:1})):In("",!0),t.value=="polis"?(ht(),se(Kl,{key:2})):In("",!0)])):(ht(),Pt("div",id,[tt(rt(ii),{dark:""})]))]}),_:1}))}});export{Td as default};
