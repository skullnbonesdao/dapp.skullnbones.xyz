import{cY as k,cZ as T,c_ as w,c$ as P,d0 as y,cV as h,cU as B,cj as i,cp as e,d1 as b,P as d,cP as M}from"./index.c26d9c43.js";function V({multisigPda:n,transactionIndex:c,creator:o,rentPayer:t,vaultIndex:a,ephemeralSigners:s,transactionMessage:r,addressLookupTableAccounts:l,memo:g,programId:u=y}){const[m]=k({multisigPda:n,index:a,programId:u}),[f]=T({multisigPda:n,index:c,programId:u}),p=w({message:r,addressLookupTableAccounts:l,vaultPda:m});return P({multisig:n,transaction:f,creator:o,rentPayer:t??o},{args:{vaultIndex:a,ephemeralSigners:s,transactionMessage:p,memo:g??null}},u)}const S=async(n,c="Unlabeled transaction")=>{const{sendTransaction:o}=h(),t=B.create({group:!1,timeout:0,spinner:!0,message:c,position:"bottom-right"});try{t({caption:"Waiting for user to sign..."});let a="";if(!i().useSquads)a=await o(n,e().connection);else{console.log(n.instructions);const r=await e().connection.getLatestBlockhash(),l=new b({payerKey:new d(i().vaultPDA),recentBlockhash:r.blockhash,instructions:n.instructions});await i().loadMultisigInfo();const g=V({multisigPda:new d(i().multisigPDA),transactionIndex:i().getNewTransactionIndex,creator:h().publicKey.value,vaultIndex:0,ephemeralSigners:0,transactionMessage:l,memo:c});a=await o(new M().add(g),e().connection)}t({color:"green-5",message:"[1/2] Waiting for confirmation...",caption:`${a}`});const s=await e().connection.getLatestBlockhash();return await e().connection.confirmTransaction({blockhash:s.blockhash,lastValidBlockHeight:s.lastValidBlockHeight,signature:a},"confirmed"),t({color:"green-8",message:"[2/2]  Waiting for finalization...",caption:`${a}`}),await e().connection.confirmTransaction({blockhash:s.blockhash,lastValidBlockHeight:s.lastValidBlockHeight,signature:a},"finalized"),t({color:"positive",timeout:5e3,icon:"done",spinner:!1,message:"Finalized",caption:`${a}`}),0}catch(a){t({progress:!0,spinner:!1,icon:"error",color:"negative",timeout:5e3,caption:`Error handling transaction: ${a.toString()}`})}};export{S as h};
