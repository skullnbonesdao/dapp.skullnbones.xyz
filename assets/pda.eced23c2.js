import{b as i,a as F,c as oo,d as _t}from"./cusper.636a8d31.js";import{cQ as hs,cR as $,cS as xe,cT as K,cU as N,cV as Re,cW as ee,cX as ve,cY as wt,cZ as Ue,c_ as le,c$ as Se,d0 as Hr,d1 as io,d2 as co,d3 as ao,d4 as uo,d5 as lo}from"./index.fa0f5368.js";function Wr(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function fo(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function un(n,...e){if(!fo(n))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(n.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${n.length}`)}function ho(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Wr(n.outputLen),Wr(n.blockLen)}function tn(n,e=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(e&&n.finished)throw new Error("Hash#digest() has already been called")}function po(n,e){un(n);const t=e.outputLen;if(n.length<t)throw new Error(`digestInto() expects output buffer of length at least ${t}`)}const nr=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const rr=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),He=(n,e)=>n<<32-e|n>>>e;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function go(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function yr(n){return typeof n=="string"&&(n=go(n)),un(n),n}function mo(...n){let e=0;for(let r=0;r<n.length;r++){const s=n[r];un(s),e+=s.length}const t=new Uint8Array(e);for(let r=0,s=0;r<n.length;r++){const o=n[r];t.set(o,s),s+=o.length}return t}class ps{clone(){return this._cloneInto()}}function gs(n){const e=r=>n().update(yr(r)).digest(),t=n();return e.outputLen=t.outputLen,e.blockLen=t.blockLen,e.create=()=>n(),e}function ms(n=32){if(nr&&typeof nr.getRandomValues=="function")return nr.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function yo(n,e,t,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(e,t,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(t>>s&o),u=Number(t&o),c=r?4:0,d=r?0:4;n.setUint32(e+c,a,r),n.setUint32(e+d,u,r)}const bo=(n,e,t)=>n&e^~n&t,xo=(n,e,t)=>n&e^n&t^e&t;class ys extends ps{constructor(e,t,r,s){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=rr(this.buffer)}update(e){tn(this);const{view:t,buffer:r,blockLen:s}=this;e=yr(e);const o=e.length;for(let a=0;a<o;){const u=Math.min(s-this.pos,o-a);if(u===s){const c=rr(e);for(;s<=o-a;a+=s)this.process(c,a);continue}r.set(e.subarray(a,a+u),this.pos),this.pos+=u,a+=u,this.pos===s&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){tn(this),po(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;t[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>s-a&&(this.process(r,0),a=0);for(let f=a;f<s;f++)t[f]=0;yo(r,s-8,BigInt(this.length*8),o),this.process(r,0);const u=rr(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=c/4,l=this.get();if(d>l.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<d;f++)u.setUint32(4*f,l[f],o)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:s,finished:o,destroyed:a,pos:u}=this;return e.length=s,e.pos=u,e.finished=o,e.destroyed=a,s%t&&e.buffer.set(r),e}}const $t=BigInt(2**32-1),ur=BigInt(32);function bs(n,e=!1){return e?{h:Number(n&$t),l:Number(n>>ur&$t)}:{h:Number(n>>ur&$t)|0,l:Number(n&$t)|0}}function wo(n,e=!1){let t=new Uint32Array(n.length),r=new Uint32Array(n.length);for(let s=0;s<n.length;s++){const{h:o,l:a}=bs(n[s],e);[t[s],r[s]]=[o,a]}return[t,r]}const So=(n,e)=>BigInt(n>>>0)<<ur|BigInt(e>>>0),Ao=(n,e,t)=>n>>>t,Bo=(n,e,t)=>n<<32-t|e>>>t,Io=(n,e,t)=>n>>>t|e<<32-t,ko=(n,e,t)=>n<<32-t|e>>>t,Eo=(n,e,t)=>n<<64-t|e>>>t-32,vo=(n,e,t)=>n>>>t-32|e<<64-t,To=(n,e)=>e,Lo=(n,e)=>n,zo=(n,e,t)=>n<<t|e>>>32-t,Ro=(n,e,t)=>e<<t|n>>>32-t,Ko=(n,e,t)=>e<<t-32|n>>>64-t,Mo=(n,e,t)=>n<<t-32|e>>>64-t;function Co(n,e,t,r){const s=(e>>>0)+(r>>>0);return{h:n+t+(s/2**32|0)|0,l:s|0}}const Fo=(n,e,t)=>(n>>>0)+(e>>>0)+(t>>>0),Po=(n,e,t,r)=>e+t+r+(n/2**32|0)|0,No=(n,e,t,r)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0),Do=(n,e,t,r,s)=>e+t+r+s+(n/2**32|0)|0,Uo=(n,e,t,r,s)=>(n>>>0)+(e>>>0)+(t>>>0)+(r>>>0)+(s>>>0),Oo=(n,e,t,r,s,o)=>e+t+r+s+o+(n/2**32|0)|0,Ho={fromBig:bs,split:wo,toBig:So,shrSH:Ao,shrSL:Bo,rotrSH:Io,rotrSL:ko,rotrBH:Eo,rotrBL:vo,rotr32H:To,rotr32L:Lo,rotlSH:zo,rotlSL:Ro,rotlBH:Ko,rotlBL:Mo,add:Co,add3L:Fo,add3H:Po,add4L:No,add4H:Do,add5H:Oo,add5L:Uo};var j=Ho;const[Wo,_o]=(()=>j.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))))(),Ze=new Uint32Array(80),Ye=new Uint32Array(80);class $o extends ys{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:s,Ch:o,Cl:a,Dh:u,Dl:c,Eh:d,El:l,Fh:f,Fl:S,Gh:B,Gl:b,Hh:h,Hl:g}=this;return[e,t,r,s,o,a,u,c,d,l,f,S,B,b,h,g]}set(e,t,r,s,o,a,u,c,d,l,f,S,B,b,h,g){this.Ah=e|0,this.Al=t|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=a|0,this.Dh=u|0,this.Dl=c|0,this.Eh=d|0,this.El=l|0,this.Fh=f|0,this.Fl=S|0,this.Gh=B|0,this.Gl=b|0,this.Hh=h|0,this.Hl=g|0}process(e,t){for(let w=0;w<16;w++,t+=4)Ze[w]=e.getUint32(t),Ye[w]=e.getUint32(t+=4);for(let w=16;w<80;w++){const W=Ze[w-15]|0,M=Ye[w-15]|0,C=j.rotrSH(W,M,1)^j.rotrSH(W,M,8)^j.shrSH(W,M,7),O=j.rotrSL(W,M,1)^j.rotrSL(W,M,8)^j.shrSL(W,M,7),P=Ze[w-2]|0,re=Ye[w-2]|0,Y=j.rotrSH(P,re,19)^j.rotrBH(P,re,61)^j.shrSH(P,re,6),X=j.rotrSL(P,re,19)^j.rotrBL(P,re,61)^j.shrSL(P,re,6),de=j.add4L(O,X,Ye[w-7],Ye[w-16]),fe=j.add4H(de,C,Y,Ze[w-7],Ze[w-16]);Ze[w]=fe|0,Ye[w]=de|0}let{Ah:r,Al:s,Bh:o,Bl:a,Ch:u,Cl:c,Dh:d,Dl:l,Eh:f,El:S,Fh:B,Fl:b,Gh:h,Gl:g,Hh:A,Hl:I}=this;for(let w=0;w<80;w++){const W=j.rotrSH(f,S,14)^j.rotrSH(f,S,18)^j.rotrBH(f,S,41),M=j.rotrSL(f,S,14)^j.rotrSL(f,S,18)^j.rotrBL(f,S,41),C=f&B^~f&h,O=S&b^~S&g,P=j.add5L(I,M,O,_o[w],Ye[w]),re=j.add5H(P,A,W,C,Wo[w],Ze[w]),Y=P|0,X=j.rotrSH(r,s,28)^j.rotrBH(r,s,34)^j.rotrBH(r,s,39),de=j.rotrSL(r,s,28)^j.rotrBL(r,s,34)^j.rotrBL(r,s,39),fe=r&o^r&u^o&u,z=s&a^s&c^a&c;A=h|0,I=g|0,h=B|0,g=b|0,B=f|0,b=S|0,{h:f,l:S}=j.add(d|0,l|0,re|0,Y|0),d=u|0,l=c|0,u=o|0,c=a|0,o=r|0,a=s|0;const y=j.add3L(Y,de,z);r=j.add3H(y,re,X,fe),s=y|0}({h:r,l:s}=j.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:a}=j.add(this.Bh|0,this.Bl|0,o|0,a|0),{h:u,l:c}=j.add(this.Ch|0,this.Cl|0,u|0,c|0),{h:d,l}=j.add(this.Dh|0,this.Dl|0,d|0,l|0),{h:f,l:S}=j.add(this.Eh|0,this.El|0,f|0,S|0),{h:B,l:b}=j.add(this.Fh|0,this.Fl|0,B|0,b|0),{h,l:g}=j.add(this.Gh|0,this.Gl|0,h|0,g|0),{h:A,l:I}=j.add(this.Hh|0,this.Hl|0,A|0,I|0),this.set(r,s,o,a,u,c,d,l,f,S,B,b,h,g,A,I)}roundClean(){Ze.fill(0),Ye.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const qo=gs(()=>new $o);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const br=BigInt(0),ln=BigInt(1),jo=BigInt(2);function ht(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function Pt(n){if(!ht(n))throw new Error("Uint8Array expected")}function Ve(n,e){if(typeof e!="boolean")throw new Error(`${n} must be valid boolean, got "${e}".`)}const Vo=Array.from({length:256},(n,e)=>e.toString(16).padStart(2,"0"));function pt(n){Pt(n);let e="";for(let t=0;t<n.length;t++)e+=Vo[n[t]];return e}function xs(n){const e=n.toString(16);return e.length&1?`0${e}`:e}function xr(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}const qe={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function _r(n){if(n>=qe._0&&n<=qe._9)return n-qe._0;if(n>=qe._A&&n<=qe._F)return n-(qe._A-10);if(n>=qe._a&&n<=qe._f)return n-(qe._a-10)}function Bt(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const e=n.length,t=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(t);for(let s=0,o=0;s<t;s++,o+=2){const a=_r(n.charCodeAt(o)),u=_r(n.charCodeAt(o+1));if(a===void 0||u===void 0){const c=n[o]+n[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}r[s]=a*16+u}return r}function dt(n){return xr(pt(n))}function St(n){return Pt(n),xr(pt(Uint8Array.from(n).reverse()))}function It(n,e){return Bt(n.toString(16).padStart(e*2,"0"))}function zt(n,e){return It(n,e).reverse()}function Go(n){return Bt(xs(n))}function pe(n,e,t){let r;if(typeof e=="string")try{r=Bt(e)}catch(o){throw new Error(`${n} must be valid hex string, got "${e}". Cause: ${o}`)}else if(ht(e))r=Uint8Array.from(e);else throw new Error(`${n} must be hex string or Uint8Array`);const s=r.length;if(typeof t=="number"&&s!==t)throw new Error(`${n} expected ${t} bytes, got ${s}`);return r}function gt(...n){let e=0;for(let r=0;r<n.length;r++){const s=n[r];Pt(s),e+=s.length}const t=new Uint8Array(e);for(let r=0,s=0;r<n.length;r++){const o=n[r];t.set(o,s),s+=o.length}return t}function Zo(n,e){if(n.length!==e.length)return!1;let t=0;for(let r=0;r<n.length;r++)t|=n[r]^e[r];return t===0}function Yo(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}const sr=n=>typeof n=="bigint"&&br<=n;function dn(n,e,t){return sr(n)&&sr(e)&&sr(t)&&e<=n&&n<t}function Fe(n,e,t,r){if(!dn(e,t,r))throw new Error(`expected valid ${n}: ${t} <= n < ${r}, got ${typeof e} ${e}`)}function Xo(n){let e;for(e=0;n>br;n>>=ln,e+=1);return e}function Jo(n,e){return n>>BigInt(e)&ln}function Qo(n,e,t){return n|(t?ln:br)<<BigInt(e)}const wr=n=>(jo<<BigInt(n-1))-ln,or=n=>new Uint8Array(n),$r=n=>Uint8Array.from(n);function ws(n,e,t){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=or(n),s=or(n),o=0;const a=()=>{r.fill(1),s.fill(0),o=0},u=(...f)=>t(s,r,...f),c=(f=or())=>{s=u($r([0]),f),r=u(),f.length!==0&&(s=u($r([1]),f),r=u())},d=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const S=[];for(;f<e;){r=u();const B=r.slice();S.push(B),f+=r.length}return gt(...S)};return(f,S)=>{a(),c(f);let B;for(;!(B=S(d()));)c();return a(),B}}const ei={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||ht(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,e)=>e.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function Et(n,e,t={}){const r=(s,o,a)=>{const u=ei[o];if(typeof u!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=n[s];if(!(a&&c===void 0)&&!u(c,n))throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${o}`)};for(const[s,o]of Object.entries(e))r(s,o,!1);for(const[s,o]of Object.entries(t))r(s,o,!0);return n}const ti=()=>{throw new Error("not implemented")};function Rt(n){const e=new WeakMap;return(t,...r)=>{const s=e.get(t);if(s!==void 0)return s;const o=n(t,...r);return e.set(t,o),o}}var ni=Object.freeze(Object.defineProperty({__proto__:null,isBytes:ht,abytes:Pt,abool:Ve,bytesToHex:pt,numberToHexUnpadded:xs,hexToNumber:xr,hexToBytes:Bt,bytesToNumberBE:dt,bytesToNumberLE:St,numberToBytesBE:It,numberToBytesLE:zt,numberToVarBytesBE:Go,ensureBytes:pe,concatBytes:gt,equalBytes:Zo,utf8ToBytes:Yo,inRange:dn,aInRange:Fe,bitLen:Xo,bitGet:Jo,bitSet:Qo,bitMask:wr,createHmacDrbg:ws,validateObject:Et,notImplemented:ti,memoized:Rt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ye=BigInt(0),ce=BigInt(1),tt=BigInt(2),ri=BigInt(3),lr=BigInt(4),qr=BigInt(5),jr=BigInt(8);BigInt(9);BigInt(16);function ne(n,e){const t=n%e;return t>=ye?t:e+t}function si(n,e,t){if(t<=ye||e<ye)throw new Error("Expected power/modulo > 0");if(t===ce)return ye;let r=ce;for(;e>ye;)e&ce&&(r=r*n%t),n=n*n%t,e>>=ce;return r}function ae(n,e,t){let r=n;for(;e-- >ye;)r*=r,r%=t;return r}function dr(n,e){if(n===ye||e<=ye)throw new Error(`invert: expected positive integers, got n=${n} mod=${e}`);let t=ne(n,e),r=e,s=ye,o=ce;for(;t!==ye;){const u=r/t,c=r%t,d=s-o*u;r=t,t=c,s=o,o=d}if(r!==ce)throw new Error("invert: does not exist");return ne(s,e)}function oi(n){const e=(n-ce)/tt;let t,r,s;for(t=n-ce,r=0;t%tt===ye;t/=tt,r++);for(s=tt;s<n&&si(s,e,n)!==n-ce;s++);if(r===1){const a=(n+ce)/lr;return function(c,d){const l=c.pow(d,a);if(!c.eql(c.sqr(l),d))throw new Error("Cannot find square root");return l}}const o=(t+ce)/tt;return function(u,c){if(u.pow(c,e)===u.neg(u.ONE))throw new Error("Cannot find square root");let d=r,l=u.pow(u.mul(u.ONE,s),t),f=u.pow(c,o),S=u.pow(c,t);for(;!u.eql(S,u.ONE);){if(u.eql(S,u.ZERO))return u.ZERO;let B=1;for(let h=u.sqr(S);B<d&&!u.eql(h,u.ONE);B++)h=u.sqr(h);const b=u.pow(l,ce<<BigInt(d-B-1));l=u.sqr(b),f=u.mul(f,b),S=u.mul(S,l),d=B}return f}}function ii(n){if(n%lr===ri){const e=(n+ce)/lr;return function(r,s){const o=r.pow(s,e);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(n%jr===qr){const e=(n-qr)/jr;return function(r,s){const o=r.mul(s,tt),a=r.pow(o,e),u=r.mul(s,a),c=r.mul(r.mul(u,tt),a),d=r.mul(u,r.sub(c,r.ONE));if(!r.eql(r.sqr(d),s))throw new Error("Cannot find square root");return d}}return oi(n)}const ci=(n,e)=>(ne(n,e)&ce)===ce,ai=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ui(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=ai.reduce((r,s)=>(r[s]="function",r),e);return Et(n,t)}function li(n,e,t){if(t<ye)throw new Error("Expected power > 0");if(t===ye)return n.ONE;if(t===ce)return e;let r=n.ONE,s=e;for(;t>ye;)t&ce&&(r=n.mul(r,s)),s=n.sqr(s),t>>=ce;return r}function di(n,e){const t=new Array(e.length),r=e.reduce((o,a,u)=>n.is0(a)?o:(t[u]=o,n.mul(o,a)),n.ONE),s=n.inv(r);return e.reduceRight((o,a,u)=>n.is0(a)?o:(t[u]=n.mul(o,t[u]),n.mul(o,a)),s),t}function Ss(n,e){const t=e!==void 0?e:n.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function As(n,e,t=!1,r={}){if(n<=ye)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:s,nByteLength:o}=Ss(n,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const a=ii(n),u=Object.freeze({ORDER:n,BITS:s,BYTES:o,MASK:wr(s),ZERO:ye,ONE:ce,create:c=>ne(c,n),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return ye<=c&&c<n},is0:c=>c===ye,isOdd:c=>(c&ce)===ce,neg:c=>ne(-c,n),eql:(c,d)=>c===d,sqr:c=>ne(c*c,n),add:(c,d)=>ne(c+d,n),sub:(c,d)=>ne(c-d,n),mul:(c,d)=>ne(c*d,n),pow:(c,d)=>li(u,c,d),div:(c,d)=>ne(c*dr(d,n),n),sqrN:c=>c*c,addN:(c,d)=>c+d,subN:(c,d)=>c-d,mulN:(c,d)=>c*d,inv:c=>dr(c,n),sqrt:r.sqrt||(c=>a(u,c)),invertBatch:c=>di(u,c),cmov:(c,d,l)=>l?d:c,toBytes:c=>t?zt(c,o):It(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return t?St(c):dt(c)}});return Object.freeze(u)}function Bs(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function Is(n){const e=Bs(n);return e+Math.ceil(e/2)}function fi(n,e,t=!1){const r=n.length,s=Bs(e),o=Is(e);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const a=t?dt(n):St(n),u=ne(a,e-ce)+ce;return t?zt(u,s):It(u,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const hi=BigInt(0),ir=BigInt(1),cr=new WeakMap,Vr=new WeakMap;function ks(n,e){const t=(o,a)=>{const u=a.negate();return o?u:a},r=o=>{if(!Number.isSafeInteger(o)||o<=0||o>e)throw new Error(`Wrong window size=${o}, should be [1..${e}]`)},s=o=>{r(o);const a=Math.ceil(e/o)+1,u=2**(o-1);return{windows:a,windowSize:u}};return{constTimeNegate:t,unsafeLadder(o,a){let u=n.ZERO,c=o;for(;a>hi;)a&ir&&(u=u.add(c)),c=c.double(),a>>=ir;return u},precomputeWindow(o,a){const{windows:u,windowSize:c}=s(a),d=[];let l=o,f=l;for(let S=0;S<u;S++){f=l,d.push(f);for(let B=1;B<c;B++)f=f.add(l),d.push(f);l=f.double()}return d},wNAF(o,a,u){const{windows:c,windowSize:d}=s(o);let l=n.ZERO,f=n.BASE;const S=BigInt(2**o-1),B=2**o,b=BigInt(o);for(let h=0;h<c;h++){const g=h*d;let A=Number(u&S);u>>=b,A>d&&(A-=B,u+=ir);const I=g,w=g+Math.abs(A)-1,W=h%2!==0,M=A<0;A===0?f=f.add(t(W,a[I])):l=l.add(t(M,a[w]))}return{p:l,f}},wNAFCached(o,a,u){const c=Vr.get(o)||1;let d=cr.get(o);return d||(d=this.precomputeWindow(o,c),c!==1&&cr.set(o,u(d))),this.wNAF(c,d,a)},setWindowSize(o,a){r(a),Vr.set(o,a),cr.delete(o)}}}function Sr(n){return ui(n.Fp),Et(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ss(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const De=BigInt(0),ke=BigInt(1),qt=BigInt(2),pi=BigInt(8),gi={zip215:!0};function mi(n){const e=Sr(n);return Et(n,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function yi(n){const e=mi(n),{Fp:t,n:r,prehash:s,hash:o,randomBytes:a,nByteLength:u,h:c}=e,d=qt<<BigInt(u*8)-ke,l=t.create,f=e.uvRatio||((y,m)=>{try{return{isValid:!0,value:t.sqrt(y*t.inv(m))}}catch{return{isValid:!1,value:De}}}),S=e.adjustScalarBytes||(y=>y),B=e.domain||((y,m,E)=>{if(Ve("phflag",E),m.length||E)throw new Error("Contexts/pre-hash are not supported");return y});function b(y,m){Fe("coordinate "+y,m,De,d)}function h(y){if(!(y instanceof I))throw new Error("ExtendedPoint expected")}const g=Rt((y,m)=>{const{ex:E,ey:L,ez:D}=y,H=y.is0();m==null&&(m=H?pi:t.inv(D));const _=l(E*m),J=l(L*m),G=l(D*m);if(H)return{x:De,y:ke};if(G!==ke)throw new Error("invZ was invalid");return{x:_,y:J}}),A=Rt(y=>{const{a:m,d:E}=e;if(y.is0())throw new Error("bad point: ZERO");const{ex:L,ey:D,ez:H,et:_}=y,J=l(L*L),G=l(D*D),Q=l(H*H),se=l(Q*Q),oe=l(J*m),Be=l(Q*l(oe+G)),ge=l(se+l(E*l(J*G)));if(Be!==ge)throw new Error("bad point: equation left != right (1)");const he=l(L*D),Ne=l(H*_);if(he!==Ne)throw new Error("bad point: equation left != right (2)");return!0});class I{constructor(m,E,L,D){this.ex=m,this.ey=E,this.ez=L,this.et=D,b("x",m),b("y",E),b("z",L),b("t",D),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(m){if(m instanceof I)throw new Error("extended point not allowed");const{x:E,y:L}=m||{};return b("x",E),b("y",L),new I(E,L,ke,l(E*L))}static normalizeZ(m){const E=t.invertBatch(m.map(L=>L.ez));return m.map((L,D)=>L.toAffine(E[D])).map(I.fromAffine)}_setWindowSize(m){M.setWindowSize(this,m)}assertValidity(){A(this)}equals(m){h(m);const{ex:E,ey:L,ez:D}=this,{ex:H,ey:_,ez:J}=m,G=l(E*J),Q=l(H*D),se=l(L*J),oe=l(_*D);return G===Q&&se===oe}is0(){return this.equals(I.ZERO)}negate(){return new I(l(-this.ex),this.ey,this.ez,l(-this.et))}double(){const{a:m}=e,{ex:E,ey:L,ez:D}=this,H=l(E*E),_=l(L*L),J=l(qt*l(D*D)),G=l(m*H),Q=E+L,se=l(l(Q*Q)-H-_),oe=G+_,Be=oe-J,ge=G-_,he=l(se*Be),Ne=l(oe*ge),Ie=l(se*ge),be=l(Be*oe);return new I(he,Ne,be,Ie)}add(m){h(m);const{a:E,d:L}=e,{ex:D,ey:H,ez:_,et:J}=this,{ex:G,ey:Q,ez:se,et:oe}=m;if(E===BigInt(-1)){const Cr=l((H-D)*(Q+G)),Fr=l((H+D)*(Q-G)),tr=l(Fr-Cr);if(tr===De)return this.double();const Pr=l(_*qt*oe),Nr=l(J*qt*se),Dr=Nr+Pr,Ur=Fr+Cr,Or=Nr-Pr,to=l(Dr*tr),no=l(Ur*Or),ro=l(Dr*Or),so=l(tr*Ur);return new I(to,no,so,ro)}const Be=l(D*G),ge=l(H*Q),he=l(J*L*oe),Ne=l(_*se),Ie=l((D+H)*(G+Q)-Be-ge),be=Ne-he,$e=Ne+he,Lt=l(ge-E*Be),Wt=l(Ie*be),Js=l($e*Lt),Qs=l(Ie*Lt),eo=l(be*$e);return new I(Wt,Js,eo,Qs)}subtract(m){return this.add(m.negate())}wNAF(m){return M.wNAFCached(this,m,I.normalizeZ)}multiply(m){const E=m;Fe("scalar",E,ke,r);const{p:L,f:D}=this.wNAF(E);return I.normalizeZ([L,D])[0]}multiplyUnsafe(m){const E=m;return Fe("scalar",E,De,r),E===De?W:this.equals(W)||E===ke?this:this.equals(w)?this.wNAF(E).p:M.unsafeLadder(this,E)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return M.unsafeLadder(this,r).is0()}toAffine(m){return g(this,m)}clearCofactor(){const{h:m}=e;return m===ke?this:this.multiplyUnsafe(m)}static fromHex(m,E=!1){const{d:L,a:D}=e,H=t.BYTES;m=pe("pointHex",m,H),Ve("zip215",E);const _=m.slice(),J=m[H-1];_[H-1]=J&-129;const G=St(_),Q=E?d:t.ORDER;Fe("pointHex.y",G,De,Q);const se=l(G*G),oe=l(se-ke),Be=l(L*se-D);let{isValid:ge,value:he}=f(oe,Be);if(!ge)throw new Error("Point.fromHex: invalid y coordinate");const Ne=(he&ke)===ke,Ie=(J&128)!==0;if(!E&&he===De&&Ie)throw new Error("Point.fromHex: x=0 and x_0=1");return Ie!==Ne&&(he=l(-he)),I.fromAffine({x:he,y:G})}static fromPrivateKey(m){return P(m).point}toRawBytes(){const{x:m,y:E}=this.toAffine(),L=zt(E,t.BYTES);return L[L.length-1]|=m&ke?128:0,L}toHex(){return pt(this.toRawBytes())}}I.BASE=new I(e.Gx,e.Gy,ke,l(e.Gx*e.Gy)),I.ZERO=new I(De,ke,ke,De);const{BASE:w,ZERO:W}=I,M=ks(I,u*8);function C(y){return ne(y,r)}function O(y){return C(St(y))}function P(y){const m=u;y=pe("private key",y,m);const E=pe("hashed private key",o(y),2*m),L=S(E.slice(0,m)),D=E.slice(m,2*m),H=O(L),_=w.multiply(H),J=_.toRawBytes();return{head:L,prefix:D,scalar:H,point:_,pointBytes:J}}function re(y){return P(y).pointBytes}function Y(y=new Uint8Array,...m){const E=gt(...m);return O(o(B(E,pe("context",y),!!s)))}function X(y,m,E={}){y=pe("message",y),s&&(y=s(y));const{prefix:L,scalar:D,pointBytes:H}=P(m),_=Y(E.context,L,y),J=w.multiply(_).toRawBytes(),G=Y(E.context,J,H,y),Q=C(_+G*D);Fe("signature.s",Q,De,r);const se=gt(J,zt(Q,t.BYTES));return pe("result",se,u*2)}const de=gi;function fe(y,m,E,L=de){const{context:D,zip215:H}=L,_=t.BYTES;y=pe("signature",y,2*_),m=pe("message",m),H!==void 0&&Ve("zip215",H),s&&(m=s(m));const J=St(y.slice(_,2*_));let G,Q,se;try{G=I.fromHex(E,H),Q=I.fromHex(y.slice(0,_),H),se=w.multiplyUnsafe(J)}catch{return!1}if(!H&&G.isSmallOrder())return!1;const oe=Y(D,Q.toRawBytes(),G.toRawBytes(),m);return Q.add(G.multiplyUnsafe(oe)).subtract(se).clearCofactor().equals(I.ZERO)}return w._setWindowSize(8),{CURVE:e,getPublicKey:re,sign:X,verify:fe,ExtendedPoint:I,utils:{getExtendedPublicKey:P,randomPrivateKey:()=>a(t.BYTES),precompute(y=8,m=I.BASE){return m._setWindowSize(y),m.multiply(BigInt(3)),m}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ar=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Gr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const bi=BigInt(1),Zr=BigInt(2);BigInt(3);const xi=BigInt(5),wi=BigInt(8);function Si(n){const e=BigInt(10),t=BigInt(20),r=BigInt(40),s=BigInt(80),o=Ar,u=n*n%o*n%o,c=ae(u,Zr,o)*u%o,d=ae(c,bi,o)*n%o,l=ae(d,xi,o)*d%o,f=ae(l,e,o)*l%o,S=ae(f,t,o)*f%o,B=ae(S,r,o)*S%o,b=ae(B,s,o)*B%o,h=ae(b,s,o)*B%o,g=ae(h,e,o)*l%o;return{pow_p_5_8:ae(g,Zr,o)*n%o,b2:u}}function Ai(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}function Bi(n,e){const t=Ar,r=ne(e*e*e,t),s=ne(r*r*e,t),o=Si(n*s).pow_p_5_8;let a=ne(n*r*o,t);const u=ne(e*a*a,t),c=a,d=ne(a*Gr,t),l=u===n,f=u===ne(-n,t),S=u===ne(-n*Gr,t);return l&&(a=c),(f||S)&&(a=d),ci(a,t)&&(a=ne(-a,t)),{isValid:l||f,value:a}}const Ii=(()=>As(Ar,void 0,!0))(),ki=(()=>({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Ii,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:wi,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:qo,randomBytes:ms,adjustScalarBytes:Ai,uvRatio:Bi}))(),Nt=(()=>yi(ki))(),Ei=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),Xe=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),Je=new Uint32Array(64);class vi extends ys{constructor(){super(64,32,8,!1),this.A=Xe[0]|0,this.B=Xe[1]|0,this.C=Xe[2]|0,this.D=Xe[3]|0,this.E=Xe[4]|0,this.F=Xe[5]|0,this.G=Xe[6]|0,this.H=Xe[7]|0}get(){const{A:e,B:t,C:r,D:s,E:o,F:a,G:u,H:c}=this;return[e,t,r,s,o,a,u,c]}set(e,t,r,s,o,a,u,c){this.A=e|0,this.B=t|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=u|0,this.H=c|0}process(e,t){for(let f=0;f<16;f++,t+=4)Je[f]=e.getUint32(t,!1);for(let f=16;f<64;f++){const S=Je[f-15],B=Je[f-2],b=He(S,7)^He(S,18)^S>>>3,h=He(B,17)^He(B,19)^B>>>10;Je[f]=h+Je[f-7]+b+Je[f-16]|0}let{A:r,B:s,C:o,D:a,E:u,F:c,G:d,H:l}=this;for(let f=0;f<64;f++){const S=He(u,6)^He(u,11)^He(u,25),B=l+S+bo(u,c,d)+Ei[f]+Je[f]|0,h=(He(r,2)^He(r,13)^He(r,22))+xo(r,s,o)|0;l=d,d=c,c=u,u=a+B|0,a=o,o=s,s=r,r=B+h|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,u=u+this.E|0,c=c+this.F|0,d=d+this.G|0,l=l+this.H|0,this.set(r,s,o,a,u,c,d,l)}roundClean(){Je.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const fr=gs(()=>new vi);class Ti extends TypeError{constructor(e,t){let r;const{message:s,explanation:o,...a}=e,{path:u}=e,c=u.length===0?s:`At path: ${u.join(".")} -- ${s}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,a),this.name=this.constructor.name,this.failures=()=>r??(r=[e,...t()])}}function Li(n){return Dt(n)&&typeof n[Symbol.iterator]=="function"}function Dt(n){return typeof n=="object"&&n!=null}function nn(n){return Dt(n)&&!Array.isArray(n)}function Oe(n){return typeof n=="symbol"?n.toString():typeof n=="string"?JSON.stringify(n):`${n}`}function zi(n){const{done:e,value:t}=n.next();return e?void 0:t}function Ri(n,e,t,r){if(n===!0)return;n===!1?n={}:typeof n=="string"&&(n={message:n});const{path:s,branch:o}=e,{type:a}=t,{refinement:u,message:c=`Expected a value of type \`${a}\`${u?` with refinement \`${u}\``:""}, but received: \`${Oe(r)}\``}=n;return{value:r,type:a,refinement:u,key:s[s.length-1],path:s,branch:o,...n,message:c}}function*Yr(n,e,t,r){Li(n)||(n=[n]);for(const s of n){const o=Ri(s,e,t,r);o&&(yield o)}}function*Br(n,e,t={}){const{path:r=[],branch:s=[n],coerce:o=!1,mask:a=!1}=t,u={path:r,branch:s,mask:a};o&&(n=e.coercer(n,u));let c="valid";for(const d of e.validator(n,u))d.explanation=t.message,c="not_valid",yield[d,void 0];for(let[d,l,f]of e.entries(n,u)){const S=Br(l,f,{path:d===void 0?r:[...r,d],branch:d===void 0?s:[...s,l],coerce:o,mask:a,message:t.message});for(const B of S)B[0]?(c=B[0].refinement!=null?"not_refined":"not_valid",yield[B[0],void 0]):o&&(l=B[1],d===void 0?n=l:n instanceof Map?n.set(d,l):n instanceof Set?n.add(l):Dt(n)&&(l!==void 0||d in n)&&(n[d]=l))}if(c!=="not_valid")for(const d of e.refiner(n,u))d.explanation=t.message,c="not_refined",yield[d,void 0];c==="valid"&&(yield[void 0,n])}class _e{constructor(e){const{type:t,schema:r,validator:s,refiner:o,coercer:a=c=>c,entries:u=function*(){}}=e;this.type=t,this.schema=r,this.entries=u,this.coercer=a,s?this.validator=(c,d)=>{const l=s(c,d);return Yr(l,d,this,c)}:this.validator=()=>[],o?this.refiner=(c,d)=>{const l=o(c,d);return Yr(l,d,this,c)}:this.refiner=()=>[]}assert(e,t){return Ki(e,this,t)}create(e,t){return Kt(e,this,t)}is(e){return Es(e,this)}mask(e,t){return Mi(e,this,t)}validate(e,t={}){return Ut(e,this,t)}}function Ki(n,e,t){const r=Ut(n,e,{message:t});if(r[0])throw r[0]}function Kt(n,e,t){const r=Ut(n,e,{coerce:!0,message:t});if(r[0])throw r[0];return r[1]}function Mi(n,e,t){const r=Ut(n,e,{coerce:!0,mask:!0,message:t});if(r[0])throw r[0];return r[1]}function Es(n,e){return!Ut(n,e)[0]}function Ut(n,e,t={}){const r=Br(n,e,t),s=zi(r);if(s[0])return[new Ti(s[0],function*(){for(const a of r)a[0]&&(yield a[0])}),void 0];{const o=s[1];return[void 0,o]}}function mt(n,e){return new _e({type:n,schema:null,validator:e})}function Ci(){return mt("any",()=>!0)}function v(n){return new _e({type:"array",schema:n,*entries(e){if(n&&Array.isArray(e))for(const[t,r]of e.entries())yield[t,r,n]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${Oe(e)}`}})}function We(){return mt("boolean",n=>typeof n=="boolean")}function Ir(n){return mt("instance",e=>e instanceof n||`Expected a \`${n.name}\` instance, but received: ${Oe(e)}`)}function ie(n){const e=Oe(n),t=typeof n;return new _e({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?n:null,validator(r){return r===n||`Expected the literal \`${e}\`, but received: ${Oe(r)}`}})}function Fi(){return mt("never",()=>!1)}function T(n){return new _e({...n,validator:(e,t)=>e===null||n.validator(e,t),refiner:(e,t)=>e===null||n.refiner(e,t)})}function p(){return mt("number",n=>typeof n=="number"&&!isNaN(n)||`Expected a number, but received: ${Oe(n)}`)}function U(n){return new _e({...n,validator:(e,t)=>e===void 0||n.validator(e,t),refiner:(e,t)=>e===void 0||n.refiner(e,t)})}function vs(n,e){return new _e({type:"record",schema:null,*entries(t){if(Dt(t))for(const r in t){const s=t[r];yield[r,r,n],yield[r,s,e]}},validator(t){return nn(t)||`Expected an object, but received: ${Oe(t)}`},coercer(t){return nn(t)?{...t}:t}})}function k(){return mt("string",n=>typeof n=="string"||`Expected a string, but received: ${Oe(n)}`)}function kr(n){const e=Fi();return new _e({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const r=Math.max(n.length,t.length);for(let s=0;s<r;s++)yield[s,t[s],n[s]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${Oe(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function x(n){const e=Object.keys(n);return new _e({type:"type",schema:n,*entries(t){if(Dt(t))for(const r of e)yield[r,t[r],n[r]]},validator(t){return nn(t)||`Expected an object, but received: ${Oe(t)}`},coercer(t){return nn(t)?{...t}:t}})}function Ae(n){const e=n.map(t=>t.type).join(" | ");return new _e({type:"union",schema:null,coercer(t,r){for(const s of n){const[o,a]=s.validate(t,{coerce:!0,mask:r.mask});if(!o)return a}return t},validator(t,r){const s=[];for(const o of n){const[...a]=Br(t,o,r),[u]=a;if(u[0])for(const[c]of a)c&&s.push(c);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${Oe(t)}`,...s]}})}function vt(){return mt("unknown",()=>!0)}function Ot(n,e,t){return new _e({...n,coercer:(r,s)=>Es(r,e)?n.coercer(t(r,s),s):n.coercer(r,s)})}hs.v4;hs.v4;var Pi={exports:{}};(function(n){var e=Object.prototype.hasOwnProperty,t="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(t=!1));function s(c,d,l){this.fn=c,this.context=d,this.once=l||!1}function o(c,d,l,f,S){if(typeof l!="function")throw new TypeError("The listener must be a function");var B=new s(l,f||c,S),b=t?t+d:d;return c._events[b]?c._events[b].fn?c._events[b]=[c._events[b],B]:c._events[b].push(B):(c._events[b]=B,c._eventsCount++),c}function a(c,d){--c._eventsCount===0?c._events=new r:delete c._events[d]}function u(){this._events=new r,this._eventsCount=0}u.prototype.eventNames=function(){var d=[],l,f;if(this._eventsCount===0)return d;for(f in l=this._events)e.call(l,f)&&d.push(t?f.slice(1):f);return Object.getOwnPropertySymbols?d.concat(Object.getOwnPropertySymbols(l)):d},u.prototype.listeners=function(d){var l=t?t+d:d,f=this._events[l];if(!f)return[];if(f.fn)return[f.fn];for(var S=0,B=f.length,b=new Array(B);S<B;S++)b[S]=f[S].fn;return b},u.prototype.listenerCount=function(d){var l=t?t+d:d,f=this._events[l];return f?f.fn?1:f.length:0},u.prototype.emit=function(d,l,f,S,B,b){var h=t?t+d:d;if(!this._events[h])return!1;var g=this._events[h],A=arguments.length,I,w;if(g.fn){switch(g.once&&this.removeListener(d,g.fn,void 0,!0),A){case 1:return g.fn.call(g.context),!0;case 2:return g.fn.call(g.context,l),!0;case 3:return g.fn.call(g.context,l,f),!0;case 4:return g.fn.call(g.context,l,f,S),!0;case 5:return g.fn.call(g.context,l,f,S,B),!0;case 6:return g.fn.call(g.context,l,f,S,B,b),!0}for(w=1,I=new Array(A-1);w<A;w++)I[w-1]=arguments[w];g.fn.apply(g.context,I)}else{var W=g.length,M;for(w=0;w<W;w++)switch(g[w].once&&this.removeListener(d,g[w].fn,void 0,!0),A){case 1:g[w].fn.call(g[w].context);break;case 2:g[w].fn.call(g[w].context,l);break;case 3:g[w].fn.call(g[w].context,l,f);break;case 4:g[w].fn.call(g[w].context,l,f,S);break;default:if(!I)for(M=1,I=new Array(A-1);M<A;M++)I[M-1]=arguments[M];g[w].fn.apply(g[w].context,I)}}return!0},u.prototype.on=function(d,l,f){return o(this,d,l,f,!1)},u.prototype.once=function(d,l,f){return o(this,d,l,f,!0)},u.prototype.removeListener=function(d,l,f,S){var B=t?t+d:d;if(!this._events[B])return this;if(!l)return a(this,B),this;var b=this._events[B];if(b.fn)b.fn===l&&(!S||b.once)&&(!f||b.context===f)&&a(this,B);else{for(var h=0,g=[],A=b.length;h<A;h++)(b[h].fn!==l||S&&!b[h].once||f&&b[h].context!==f)&&g.push(b[h]);g.length?this._events[B]=g.length===1?g[0]:g:a(this,B)}return this},u.prototype.removeAllListeners=function(d){var l;return d?(l=t?t+d:d,this._events[l]&&a(this,l)):(this._events=new r,this._eventsCount=0),this},u.prototype.off=u.prototype.removeListener,u.prototype.addListener=u.prototype.on,u.prefixed=t,u.EventEmitter=u,n.exports=u})(Pi);class Ts extends ps{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,ho(e);const r=yr(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return tn(this),this.iHash.update(e),this}digestInto(e){tn(this),un(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:s,destroyed:o,blockLen:a,outputLen:u}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=a,e.outputLen=u,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ls=(n,e,t)=>new Ts(n,e).update(t).digest();Ls.create=(n,e)=>new Ts(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Xr(n){n.lowS!==void 0&&Ve("lowS",n.lowS),n.prehash!==void 0&&Ve("prehash",n.prehash)}function Ni(n){const e=Sr(n);Et(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:r,a:s}=e;if(t){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Di,hexToBytes:Ui}=ni,lt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(n){const{Err:e}=lt;if(n.length<2||n[0]!==2)throw new e("Invalid signature integer tag");const t=n[1],r=n.subarray(2,t+2);if(!t||r.length!==t)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Di(r),l:n.subarray(t+2)}},toSig(n){const{Err:e}=lt,t=typeof n=="string"?Ui(n):n;Pt(t);let r=t.length;if(r<2||t[0]!=48)throw new e("Invalid signature tag");if(t[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:s,l:o}=lt._parseInt(t.subarray(2)),{d:a,l:u}=lt._parseInt(o);if(u.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:a}},hexFromSig(n){const e=d=>Number.parseInt(d[0],16)&8?"00"+d:d,t=d=>{const l=d.toString(16);return l.length&1?`0${l}`:l},r=e(t(n.s)),s=e(t(n.r)),o=r.length/2,a=s.length/2,u=t(o),c=t(a);return`30${t(a+o+4)}02${c}${s}02${u}${r}`}},Qe=BigInt(0),me=BigInt(1);BigInt(2);const Jr=BigInt(3);BigInt(4);function Oi(n){const e=Ni(n),{Fp:t}=e,r=e.toBytes||((b,h,g)=>{const A=h.toAffine();return gt(Uint8Array.from([4]),t.toBytes(A.x),t.toBytes(A.y))}),s=e.fromBytes||(b=>{const h=b.subarray(1),g=t.fromBytes(h.subarray(0,t.BYTES)),A=t.fromBytes(h.subarray(t.BYTES,2*t.BYTES));return{x:g,y:A}});function o(b){const{a:h,b:g}=e,A=t.sqr(b),I=t.mul(A,b);return t.add(t.add(I,t.mul(b,h)),g)}if(!t.eql(t.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function a(b){return dn(b,me,e.n)}function u(b){const{allowedPrivateKeyLengths:h,nByteLength:g,wrapPrivateKey:A,n:I}=e;if(h&&typeof b!="bigint"){if(ht(b)&&(b=pt(b)),typeof b!="string"||!h.includes(b.length))throw new Error("Invalid key");b=b.padStart(g*2,"0")}let w;try{w=typeof b=="bigint"?b:dt(pe("private key",b,g))}catch{throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof b}`)}return A&&(w=ne(w,I)),Fe("private key",w,me,I),w}function c(b){if(!(b instanceof f))throw new Error("ProjectivePoint expected")}const d=Rt((b,h)=>{const{px:g,py:A,pz:I}=b;if(t.eql(I,t.ONE))return{x:g,y:A};const w=b.is0();h==null&&(h=w?t.ONE:t.inv(I));const W=t.mul(g,h),M=t.mul(A,h),C=t.mul(I,h);if(w)return{x:t.ZERO,y:t.ZERO};if(!t.eql(C,t.ONE))throw new Error("invZ was invalid");return{x:W,y:M}}),l=Rt(b=>{if(b.is0()){if(e.allowInfinityPoint&&!t.is0(b.py))return;throw new Error("bad point: ZERO")}const{x:h,y:g}=b.toAffine();if(!t.isValid(h)||!t.isValid(g))throw new Error("bad point: x or y not FE");const A=t.sqr(g),I=o(h);if(!t.eql(A,I))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class f{constructor(h,g,A){if(this.px=h,this.py=g,this.pz=A,h==null||!t.isValid(h))throw new Error("x required");if(g==null||!t.isValid(g))throw new Error("y required");if(A==null||!t.isValid(A))throw new Error("z required");Object.freeze(this)}static fromAffine(h){const{x:g,y:A}=h||{};if(!h||!t.isValid(g)||!t.isValid(A))throw new Error("invalid affine point");if(h instanceof f)throw new Error("projective point not allowed");const I=w=>t.eql(w,t.ZERO);return I(g)&&I(A)?f.ZERO:new f(g,A,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const g=t.invertBatch(h.map(A=>A.pz));return h.map((A,I)=>A.toAffine(g[I])).map(f.fromAffine)}static fromHex(h){const g=f.fromAffine(s(pe("pointHex",h)));return g.assertValidity(),g}static fromPrivateKey(h){return f.BASE.multiply(u(h))}_setWindowSize(h){B.setWindowSize(this,h)}assertValidity(){l(this)}hasEvenY(){const{y:h}=this.toAffine();if(t.isOdd)return!t.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){c(h);const{px:g,py:A,pz:I}=this,{px:w,py:W,pz:M}=h,C=t.eql(t.mul(g,M),t.mul(w,I)),O=t.eql(t.mul(A,M),t.mul(W,I));return C&&O}negate(){return new f(this.px,t.neg(this.py),this.pz)}double(){const{a:h,b:g}=e,A=t.mul(g,Jr),{px:I,py:w,pz:W}=this;let M=t.ZERO,C=t.ZERO,O=t.ZERO,P=t.mul(I,I),re=t.mul(w,w),Y=t.mul(W,W),X=t.mul(I,w);return X=t.add(X,X),O=t.mul(I,W),O=t.add(O,O),M=t.mul(h,O),C=t.mul(A,Y),C=t.add(M,C),M=t.sub(re,C),C=t.add(re,C),C=t.mul(M,C),M=t.mul(X,M),O=t.mul(A,O),Y=t.mul(h,Y),X=t.sub(P,Y),X=t.mul(h,X),X=t.add(X,O),O=t.add(P,P),P=t.add(O,P),P=t.add(P,Y),P=t.mul(P,X),C=t.add(C,P),Y=t.mul(w,W),Y=t.add(Y,Y),P=t.mul(Y,X),M=t.sub(M,P),O=t.mul(Y,re),O=t.add(O,O),O=t.add(O,O),new f(M,C,O)}add(h){c(h);const{px:g,py:A,pz:I}=this,{px:w,py:W,pz:M}=h;let C=t.ZERO,O=t.ZERO,P=t.ZERO;const re=e.a,Y=t.mul(e.b,Jr);let X=t.mul(g,w),de=t.mul(A,W),fe=t.mul(I,M),z=t.add(g,A),y=t.add(w,W);z=t.mul(z,y),y=t.add(X,de),z=t.sub(z,y),y=t.add(g,I);let m=t.add(w,M);return y=t.mul(y,m),m=t.add(X,fe),y=t.sub(y,m),m=t.add(A,I),C=t.add(W,M),m=t.mul(m,C),C=t.add(de,fe),m=t.sub(m,C),P=t.mul(re,y),C=t.mul(Y,fe),P=t.add(C,P),C=t.sub(de,P),P=t.add(de,P),O=t.mul(C,P),de=t.add(X,X),de=t.add(de,X),fe=t.mul(re,fe),y=t.mul(Y,y),de=t.add(de,fe),fe=t.sub(X,fe),fe=t.mul(re,fe),y=t.add(y,fe),X=t.mul(de,y),O=t.add(O,X),X=t.mul(m,y),C=t.mul(z,C),C=t.sub(C,X),X=t.mul(z,de),P=t.mul(m,P),P=t.add(P,X),new f(C,O,P)}subtract(h){return this.add(h.negate())}is0(){return this.equals(f.ZERO)}wNAF(h){return B.wNAFCached(this,h,f.normalizeZ)}multiplyUnsafe(h){Fe("scalar",h,Qe,e.n);const g=f.ZERO;if(h===Qe)return g;if(h===me)return this;const{endo:A}=e;if(!A)return B.unsafeLadder(this,h);let{k1neg:I,k1:w,k2neg:W,k2:M}=A.splitScalar(h),C=g,O=g,P=this;for(;w>Qe||M>Qe;)w&me&&(C=C.add(P)),M&me&&(O=O.add(P)),P=P.double(),w>>=me,M>>=me;return I&&(C=C.negate()),W&&(O=O.negate()),O=new f(t.mul(O.px,A.beta),O.py,O.pz),C.add(O)}multiply(h){const{endo:g,n:A}=e;Fe("scalar",h,me,A);let I,w;if(g){const{k1neg:W,k1:M,k2neg:C,k2:O}=g.splitScalar(h);let{p:P,f:re}=this.wNAF(M),{p:Y,f:X}=this.wNAF(O);P=B.constTimeNegate(W,P),Y=B.constTimeNegate(C,Y),Y=new f(t.mul(Y.px,g.beta),Y.py,Y.pz),I=P.add(Y),w=re.add(X)}else{const{p:W,f:M}=this.wNAF(h);I=W,w=M}return f.normalizeZ([I,w])[0]}multiplyAndAddUnsafe(h,g,A){const I=f.BASE,w=(M,C)=>C===Qe||C===me||!M.equals(I)?M.multiplyUnsafe(C):M.multiply(C),W=w(this,g).add(w(h,A));return W.is0()?void 0:W}toAffine(h){return d(this,h)}isTorsionFree(){const{h,isTorsionFree:g}=e;if(h===me)return!0;if(g)return g(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:g}=e;return h===me?this:g?g(f,this):this.multiplyUnsafe(e.h)}toRawBytes(h=!0){return Ve("isCompressed",h),this.assertValidity(),r(f,this,h)}toHex(h=!0){return Ve("isCompressed",h),pt(this.toRawBytes(h))}}f.BASE=new f(e.Gx,e.Gy,t.ONE),f.ZERO=new f(t.ZERO,t.ONE,t.ZERO);const S=e.nBitLength,B=ks(f,e.endo?Math.ceil(S/2):S);return{CURVE:e,ProjectivePoint:f,normPrivateKeyToScalar:u,weierstrassEquation:o,isWithinCurveOrder:a}}function Hi(n){const e=Sr(n);return Et(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Wi(n){const e=Hi(n),{Fp:t,n:r}=e,s=t.BYTES+1,o=2*t.BYTES+1;function a(z){return ne(z,r)}function u(z){return dr(z,r)}const{ProjectivePoint:c,normPrivateKeyToScalar:d,weierstrassEquation:l,isWithinCurveOrder:f}=Oi({...e,toBytes(z,y,m){const E=y.toAffine(),L=t.toBytes(E.x),D=gt;return Ve("isCompressed",m),m?D(Uint8Array.from([y.hasEvenY()?2:3]),L):D(Uint8Array.from([4]),L,t.toBytes(E.y))},fromBytes(z){const y=z.length,m=z[0],E=z.subarray(1);if(y===s&&(m===2||m===3)){const L=dt(E);if(!dn(L,me,t.ORDER))throw new Error("Point is not on curve");const D=l(L);let H;try{H=t.sqrt(D)}catch(G){const Q=G instanceof Error?": "+G.message:"";throw new Error("Point is not on curve"+Q)}const _=(H&me)===me;return(m&1)===1!==_&&(H=t.neg(H)),{x:L,y:H}}else if(y===o&&m===4){const L=t.fromBytes(E.subarray(0,t.BYTES)),D=t.fromBytes(E.subarray(t.BYTES,2*t.BYTES));return{x:L,y:D}}else throw new Error(`Point of length ${y} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),S=z=>pt(It(z,e.nByteLength));function B(z){const y=r>>me;return z>y}function b(z){return B(z)?a(-z):z}const h=(z,y,m)=>dt(z.slice(y,m));class g{constructor(y,m,E){this.r=y,this.s=m,this.recovery=E,this.assertValidity()}static fromCompact(y){const m=e.nByteLength;return y=pe("compactSignature",y,m*2),new g(h(y,0,m),h(y,m,2*m))}static fromDER(y){const{r:m,s:E}=lt.toSig(pe("DER",y));return new g(m,E)}assertValidity(){Fe("r",this.r,me,r),Fe("s",this.s,me,r)}addRecoveryBit(y){return new g(this.r,this.s,y)}recoverPublicKey(y){const{r:m,s:E,recovery:L}=this,D=C(pe("msgHash",y));if(L==null||![0,1,2,3].includes(L))throw new Error("recovery id invalid");const H=L===2||L===3?m+e.n:m;if(H>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const _=(L&1)===0?"02":"03",J=c.fromHex(_+S(H)),G=u(H),Q=a(-D*G),se=a(E*G),oe=c.BASE.multiplyAndAddUnsafe(J,Q,se);if(!oe)throw new Error("point at infinify");return oe.assertValidity(),oe}hasHighS(){return B(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return Bt(this.toDERHex())}toDERHex(){return lt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Bt(this.toCompactHex())}toCompactHex(){return S(this.r)+S(this.s)}}const A={isValidPrivateKey(z){try{return d(z),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const z=Is(e.n);return fi(e.randomBytes(z),e.n)},precompute(z=8,y=c.BASE){return y._setWindowSize(z),y.multiply(BigInt(3)),y}};function I(z,y=!0){return c.fromPrivateKey(z).toRawBytes(y)}function w(z){const y=ht(z),m=typeof z=="string",E=(y||m)&&z.length;return y?E===s||E===o:m?E===2*s||E===2*o:z instanceof c}function W(z,y,m=!0){if(w(z))throw new Error("first arg must be private key");if(!w(y))throw new Error("second arg must be public key");return c.fromHex(y).multiply(d(z)).toRawBytes(m)}const M=e.bits2int||function(z){const y=dt(z),m=z.length*8-e.nBitLength;return m>0?y>>BigInt(m):y},C=e.bits2int_modN||function(z){return a(M(z))},O=wr(e.nBitLength);function P(z){return Fe(`num < 2^${e.nBitLength}`,z,Qe,O),It(z,e.nByteLength)}function re(z,y,m=Y){if(["recovered","canonical"].some(ge=>ge in m))throw new Error("sign() legacy options not supported");const{hash:E,randomBytes:L}=e;let{lowS:D,prehash:H,extraEntropy:_}=m;D==null&&(D=!0),z=pe("msgHash",z),Xr(m),H&&(z=pe("prehashed msgHash",E(z)));const J=C(z),G=d(y),Q=[P(G),P(J)];if(_!=null&&_!==!1){const ge=_===!0?L(t.BYTES):_;Q.push(pe("extraEntropy",ge))}const se=gt(...Q),oe=J;function Be(ge){const he=M(ge);if(!f(he))return;const Ne=u(he),Ie=c.BASE.multiply(he).toAffine(),be=a(Ie.x);if(be===Qe)return;const $e=a(Ne*a(oe+be*G));if($e===Qe)return;let Lt=(Ie.x===be?0:2)|Number(Ie.y&me),Wt=$e;return D&&B($e)&&(Wt=b($e),Lt^=1),new g(be,Wt,Lt)}return{seed:se,k2sig:Be}}const Y={lowS:e.lowS,prehash:!1},X={lowS:e.lowS,prehash:!1};function de(z,y,m=Y){const{seed:E,k2sig:L}=re(z,y,m),D=e;return ws(D.hash.outputLen,D.nByteLength,D.hmac)(E,L)}c.BASE._setWindowSize(8);function fe(z,y,m,E=X){var Ie;const L=z;if(y=pe("msgHash",y),m=pe("publicKey",m),"strict"in E)throw new Error("options.strict was renamed to lowS");Xr(E);const{lowS:D,prehash:H}=E;let _,J;try{if(typeof L=="string"||ht(L))try{_=g.fromDER(L)}catch(be){if(!(be instanceof lt.Err))throw be;_=g.fromCompact(L)}else if(typeof L=="object"&&typeof L.r=="bigint"&&typeof L.s=="bigint"){const{r:be,s:$e}=L;_=new g(be,$e)}else throw new Error("PARSE");J=c.fromHex(m)}catch(be){if(be.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(D&&_.hasHighS())return!1;H&&(y=e.hash(y));const{r:G,s:Q}=_,se=C(y),oe=u(Q),Be=a(se*oe),ge=a(G*oe),he=(Ie=c.BASE.multiplyAndAddUnsafe(J,Be,ge))==null?void 0:Ie.toAffine();return he?a(he.x)===G:!1}return{CURVE:e,getPublicKey:I,getSharedSecret:W,sign:de,verify:fe,ProjectivePoint:c,Signature:g,utils:A}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function _i(n){return{hash:n,hmac:(e,...t)=>Ls(n,e,mo(...t)),randomBytes:ms}}function $i(n,e){const t=r=>Wi({...n,..._i(r)});return Object.freeze({...t(e),create:t})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zs=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Qr=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),qi=BigInt(1),hr=BigInt(2),es=(n,e)=>(n+e/hr)/e;function ji(n){const e=zs,t=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),a=BigInt(23),u=BigInt(44),c=BigInt(88),d=n*n*n%e,l=d*d*n%e,f=ae(l,t,e)*l%e,S=ae(f,t,e)*l%e,B=ae(S,hr,e)*d%e,b=ae(B,s,e)*B%e,h=ae(b,o,e)*b%e,g=ae(h,u,e)*h%e,A=ae(g,c,e)*g%e,I=ae(A,u,e)*h%e,w=ae(I,t,e)*l%e,W=ae(w,a,e)*b%e,M=ae(W,r,e)*d%e,C=ae(M,hr,e);if(!pr.eql(pr.sqr(C),n))throw new Error("Cannot find square root");return C}const pr=As(zs,void 0,void 0,{sqrt:ji}),Er=$i({a:BigInt(0),b:BigInt(7),Fp:pr,n:Qr,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=Qr,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-qi*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=t,a=BigInt("0x100000000000000000000000000000000"),u=es(o*n,e),c=es(-r*n,e);let d=ne(n-u*t-c*s,e),l=ne(-u*r-c*o,e);const f=d>a,S=l>a;if(f&&(d=e-d),S&&(l=e-l),d>a||l>a)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:f,k1:d,k2neg:S,k2:l}}}},fr);BigInt(0);Er.ProjectivePoint;Nt.utils.randomPrivateKey;Nt.getPublicKey;function ts(n){try{return Nt.ExtendedPoint.fromHex(n),!0}catch{return!1}}const Vi=(n,e)=>Nt.sign(n,e.slice(0,32)),Gi=Nt.verify,Ee=n=>$.Buffer.isBuffer(n)?n:n instanceof Uint8Array?$.Buffer.from(n.buffer,n.byteOffset,n.byteLength):$.Buffer.from(n);class Zi{constructor(e){Object.assign(this,e)}encode(){return $.Buffer.from(io(en,this))}static decode(e){return co(en,this,e)}static decodeUnchecked(e){return ao(en,this,e)}}const en=new Map;var Rs;const Yi=32,et=32;function Xi(n){return n._bn!==void 0}let ns=1;class R extends Zi{constructor(e){if(super({}),this._bn=void 0,Xi(e))this._bn=e._bn;else{if(typeof e=="string"){const t=Se.decode(e);if(t.length!=et)throw new Error("Invalid public key input");this._bn=new Hr(t)}else this._bn=new Hr(e);if(this._bn.byteLength()>et)throw new Error("Invalid public key input")}}static unique(){const e=new R(ns);return ns+=1,new R(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return Se.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike($.Buffer);if(e.length===et)return e;const t=$.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,r){const s=$.Buffer.concat([e.toBuffer(),$.Buffer.from(t),r.toBuffer()]),o=fr(s);return new R(o)}static createProgramAddressSync(e,t){let r=$.Buffer.alloc(0);e.forEach(function(o){if(o.length>Yi)throw new TypeError("Max seed length exceeded");r=$.Buffer.concat([r,Ee(o)])}),r=$.Buffer.concat([r,t.toBuffer(),$.Buffer.from("ProgramDerivedAddress")]);const s=fr(r);if(ts(s))throw new Error("Invalid seeds, address must fall off the curve");return new R(s)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let r=255,s;for(;r!=0;){try{const o=e.concat($.Buffer.from([r]));s=this.createProgramAddressSync(o,t)}catch(o){if(o instanceof TypeError)throw o;r--;continue}return[s,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new R(e);return ts(t.toBytes())}}Rs=R;R.default=new Rs("11111111111111111111111111111111");en.set(R,{kind:"struct",fields:[["_bn","u256"]]});new R("BPFLoader1111111111111111111111111111111111");const At=1280-40-8,Ks=127,Ms=64;class Mt{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((o,a)=>{r.set(o.toBase58(),a)});const s=o=>{const a=r.get(o.toBase58());if(a===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return a};return e.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(a=>s(a.pubkey)),data:o.data}))}}const Z=(n="publicKey")=>le(32,n),xt=(n="string")=>{const e=K([N("length"),N("lengthPadding"),le(wt(N(),-8),"chars")],n),t=e.decode.bind(e),r=e.encode.bind(e),s=e;return s.decode=(o,a)=>t(o,a).chars.toString(),s.encode=(o,a,u)=>{const c={chars:$.Buffer.from(o,"utf8")};return r(c,a,u)},s.alloc=o=>N().span+N().span+$.Buffer.from(o,"utf8").length,s},Ji=(n="authorized")=>K([Z("staker"),Z("withdrawer")],n),Qi=(n="lockup")=>K([Re("unixTimestamp"),Re("epoch"),Z("custodian")],n),ec=(n="voteInit")=>K([Z("nodePubkey"),Z("authorizedVoter"),Z("authorizedWithdrawer"),ee("commission")],n),tc=(n="voteAuthorizeWithSeedArgs")=>K([N("voteAuthorizationType"),Z("currentAuthorityDerivedKeyOwnerPubkey"),xt("currentAuthorityDerivedKeySeed"),Z("newAuthorized")],n);function Cs(n,e){const t=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(e[s.property]);if("count"in s&&"elementLayout"in s){const o=e[s.property];if(Array.isArray(o))return o.length*t(s.elementLayout)}else if("fields"in s)return Cs({layout:s},e[s.property]);return 0};let r=0;return n.layout.fields.forEach(s=>{r+=t(s)}),r}function Ke(n){let e=0,t=0;for(;;){let r=n.shift();if(e|=(r&127)<<t*7,t+=1,(r&128)===0)break}return e}function Me(n,e){let t=e;for(;;){let r=t&127;if(t>>=7,t==0){n.push(r);break}else r|=128,n.push(r)}}function we(n,e){if(!n)throw new Error(e||"Assertion failed")}class fn{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,s=a=>{const u=a.toBase58();let c=r.get(u);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(u,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const a of e){s(a.programId).isInvoked=!0;for(const u of a.keys){const c=s(u.pubkey);c.isSigner||=u.isSigner,c.isWritable||=u.isWritable}}return new fn(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];we(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),r=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),a={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{we(t.length>0,"Expected at least one writable signer key");const[c]=t[0];we(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const u=[...t.map(([c])=>new R(c)),...r.map(([c])=>new R(c)),...s.map(([c])=>new R(c)),...o.map(([c])=>new R(c))];return[a,u]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,a=>!a.isSigner&&!a.isInvoked&&a.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,a=>!a.isSigner&&!a.isInvoked&&!a.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(e,t){const r=new Array,s=new Array;for(const[o,a]of this.keyMetaMap.entries())if(t(a)){const u=new R(o),c=e.findIndex(d=>d.equals(u));c>=0&&(we(c<256,"Max lookup table index exceeded"),r.push(c),s.push(u),this.keyMetaMap.delete(o))}return[r,s]}}const Fs="Reached end of buffer unexpectedly";function je(n){if(n.length===0)throw new Error(Fs);return n.shift()}function Ce(n,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>n.length:t>=n.length)throw new Error(Fs);return n.splice(...e)}class Ct{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new R(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:Se.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Mt(this.staticAccountKeys)}static compile(e){const t=fn.compile(e.instructions,e.payerKey),[r,s]=t.getMessageComponents(),a=new Mt(s).compileInstructions(e.instructions).map(u=>({programIdIndex:u.programIdIndex,accounts:u.accountKeyIndexes,data:Se.encode(u.data)}));return new Ct({header:r,accountKeys:s,recentBlockhash:e.recentBlockhash,instructions:a})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const r=e-t,o=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return r<o}else{const r=t-this.header.numReadonlySignedAccounts;return e<r}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Me(t,e);const r=this.instructions.map(f=>{const{accounts:S,programIdIndex:B}=f,b=Array.from(Se.decode(f.data));let h=[];Me(h,S.length);let g=[];return Me(g,b.length),{programIdIndex:B,keyIndicesCount:$.Buffer.from(h),keyIndices:S,dataLength:$.Buffer.from(g),data:b}});let s=[];Me(s,r.length);let o=$.Buffer.alloc(At);$.Buffer.from(s).copy(o);let a=s.length;r.forEach(f=>{a+=K([ee("programIdIndex"),le(f.keyIndicesCount.length,"keyIndicesCount"),ve(ee("keyIndex"),f.keyIndices.length,"keyIndices"),le(f.dataLength.length,"dataLength"),ve(ee("userdatum"),f.data.length,"data")]).encode(f,o,a)}),o=o.slice(0,a);const u=K([le(1,"numRequiredSignatures"),le(1,"numReadonlySignedAccounts"),le(1,"numReadonlyUnsignedAccounts"),le(t.length,"keyCount"),ve(Z("key"),e,"keys"),Z("recentBlockhash")]),c={numRequiredSignatures:$.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:$.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:$.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:$.Buffer.from(t),keys:this.accountKeys.map(f=>Ee(f.toBytes())),recentBlockhash:Se.decode(this.recentBlockhash)};let d=$.Buffer.alloc(2048);const l=u.encode(c,d);return o.copy(d,l),d.slice(0,l+o.length)}static from(e){let t=[...e];const r=je(t);if(r!==(r&Ks))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=je(t),o=je(t),a=Ke(t);let u=[];for(let S=0;S<a;S++){const B=Ce(t,0,et);u.push(new R($.Buffer.from(B)))}const c=Ce(t,0,et),d=Ke(t);let l=[];for(let S=0;S<d;S++){const B=je(t),b=Ke(t),h=Ce(t,0,b),g=Ke(t),A=Ce(t,0,g),I=Se.encode($.Buffer.from(A));l.push({programIdIndex:B,accounts:h,data:I})}const f={header:{numRequiredSignatures:r,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:Se.encode($.Buffer.from(c)),accountKeys:u,instructions:l};return new Ct(f)}}class rn{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Mt(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(e>=r){const s=e-r,o=this.addressTableLookups.reduce((a,u)=>a+u.writableIndexes.length,0);return s<o}else if(e>=this.header.numRequiredSignatures){const s=e-t,a=r-t-this.header.numReadonlyUnsignedAccounts;return s<a}else{const s=t-this.header.numReadonlySignedAccounts;return e<s}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const r of this.addressTableLookups){const s=e.find(o=>o.key.equals(r.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const o of r.writableIndexes)if(o<s.state.addresses.length)t.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`);for(const o of r.readonlyIndexes)if(o<s.state.addresses.length)t.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`)}return t}static compile(e){const t=fn.compile(e.instructions,e.payerKey),r=new Array,s={writable:new Array,readonly:new Array},o=e.addressLookupTableAccounts||[];for(const l of o){const f=t.extractTableLookup(l);if(f!==void 0){const[S,{writable:B,readonly:b}]=f;r.push(S),s.writable.push(...B),s.readonly.push(...b)}}const[a,u]=t.getMessageComponents(),d=new Mt(u,s).compileInstructions(e.instructions);return new rn({header:a,staticAccountKeys:u,recentBlockhash:e.recentBlockhash,compiledInstructions:d,addressTableLookups:r})}serialize(){const e=Array();Me(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),r=Array();Me(r,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();Me(o,this.addressTableLookups.length);const a=K([ee("prefix"),K([ee("numRequiredSignatures"),ee("numReadonlySignedAccounts"),ee("numReadonlyUnsignedAccounts")],"header"),le(e.length,"staticAccountKeysLength"),ve(Z(),this.staticAccountKeys.length,"staticAccountKeys"),Z("recentBlockhash"),le(r.length,"instructionsLength"),le(t.length,"serializedInstructions"),le(o.length,"addressTableLookupsLength"),le(s.length,"serializedAddressTableLookups")]),u=new Uint8Array(At),c=1<<7,d=a.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(l=>l.toBytes()),recentBlockhash:Se.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},u);return u.slice(0,d)}serializeInstructions(){let e=0;const t=new Uint8Array(At);for(const r of this.compiledInstructions){const s=Array();Me(s,r.accountKeyIndexes.length);const o=Array();Me(o,r.data.length),e+=K([ee("programIdIndex"),le(s.length,"encodedAccountKeyIndexesLength"),ve(ee(),r.accountKeyIndexes.length,"accountKeyIndexes"),le(o.length,"encodedDataLength"),le(r.data.length,"data")]).encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:r.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(At);for(const r of this.addressTableLookups){const s=Array();Me(s,r.writableIndexes.length);const o=Array();Me(o,r.readonlyIndexes.length),e+=K([Z("accountKey"),le(s.length,"encodedWritableIndexesLength"),ve(ee(),r.writableIndexes.length,"writableIndexes"),le(o.length,"encodedReadonlyIndexesLength"),ve(ee(),r.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:r.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const r=je(t),s=r&Ks;we(r!==s,"Expected versioned message but received legacy message");const o=s;we(o===0,`Expected versioned message with version 0 but found version ${o}`);const a={numRequiredSignatures:je(t),numReadonlySignedAccounts:je(t),numReadonlyUnsignedAccounts:je(t)},u=[],c=Ke(t);for(let b=0;b<c;b++)u.push(new R(Ce(t,0,et)));const d=Se.encode(Ce(t,0,et)),l=Ke(t),f=[];for(let b=0;b<l;b++){const h=je(t),g=Ke(t),A=Ce(t,0,g),I=Ke(t),w=new Uint8Array(Ce(t,0,I));f.push({programIdIndex:h,accountKeyIndexes:A,data:w})}const S=Ke(t),B=[];for(let b=0;b<S;b++){const h=new R(Ce(t,0,et)),g=Ke(t),A=Ce(t,0,g),I=Ke(t),w=Ce(t,0,I);B.push({accountKey:h,writableIndexes:A,readonlyIndexes:w})}return new rn({header:a,staticAccountKeys:u,recentBlockhash:d,compiledInstructions:f,addressTableLookups:B})}}const nc=$.Buffer.alloc(Ms).fill(0);class ze{constructor(e){this.keys=void 0,this.programId=void 0,this.data=$.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:r})=>({pubkey:e.toJSON(),isSigner:t,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class sn{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:r}=e;this.minNonceContextSlot=t,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:r}=e;this.recentBlockhash=t,this.lastValidBlockHeight=r}else{const{recentBlockhash:t,nonceInfo:r}=e;r&&(this.nonceInfo=r),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new ze(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let h=0;h<t.length;h++)if(t[h].programId===void 0)throw new Error(`Transaction instruction index ${h} has undefined program id`);const s=[],o=[];t.forEach(h=>{h.keys.forEach(A=>{o.push({...A})});const g=h.programId.toString();s.includes(g)||s.push(g)}),s.forEach(h=>{o.push({pubkey:new R(h),isSigner:!1,isWritable:!1})});const a=[];o.forEach(h=>{const g=h.pubkey.toString(),A=a.findIndex(I=>I.pubkey.toString()===g);A>-1?(a[A].isWritable=a[A].isWritable||h.isWritable,a[A].isSigner=a[A].isSigner||h.isSigner):a.push(h)}),a.sort(function(h,g){if(h.isSigner!==g.isSigner)return h.isSigner?-1:1;if(h.isWritable!==g.isWritable)return h.isWritable?-1:1;const A={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return h.pubkey.toBase58().localeCompare(g.pubkey.toBase58(),"en",A)});const u=a.findIndex(h=>h.pubkey.equals(r));if(u>-1){const[h]=a.splice(u,1);h.isSigner=!0,h.isWritable=!0,a.unshift(h)}else a.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const h of this.signatures){const g=a.findIndex(A=>A.pubkey.equals(h.publicKey));if(g>-1)a[g].isSigner||(a[g].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${h.publicKey.toString()}`)}let c=0,d=0,l=0;const f=[],S=[];a.forEach(({pubkey:h,isSigner:g,isWritable:A})=>{g?(f.push(h.toString()),c+=1,A||(d+=1)):(S.push(h.toString()),A||(l+=1))});const B=f.concat(S),b=t.map(h=>{const{data:g,programId:A}=h;return{programIdIndex:B.indexOf(A.toString()),accounts:h.keys.map(I=>B.indexOf(I.pubkey.toString())),data:Se.encode(g)}});return b.forEach(h=>{we(h.programIdIndex>=0),h.accounts.forEach(g=>we(g>=0))}),new Ct({header:{numRequiredSignatures:c,numReadonlySignedAccounts:d,numReadonlyUnsignedAccounts:l},accountKeys:B,recentBlockhash:e,instructions:b})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((s,o)=>t[o].equals(s.publicKey))||(this.signatures=t.map(r=>({signature:null,publicKey:r}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(r=>{const s=r.toString();return t.has(s)?!1:(t.add(s),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const o of e){const a=o.publicKey.toString();t.has(a)||(t.add(a),r.push(o))}this.signatures=r.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...r)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,r=[];for(const o of e){const a=o.publicKey.toString();t.has(a)||(t.add(a),r.push(o))}const s=this._compile();this._partialSign(s,...r)}_partialSign(e,...t){const r=e.serialize();t.forEach(s=>{const o=Vi(r,s.secretKey);this._addSignature(s.publicKey,Ee(o))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){we(t.length===64);const r=this.signatures.findIndex(s=>e.equals(s.publicKey));if(r<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[r].signature=$.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const r={};for(const{signature:s,publicKey:o}of this.signatures)s===null?t&&(r.missing||=[]).push(o):Gi(s,e,o.toBytes())||(r.invalid||=[]).push(o);return r.invalid||r.missing?r:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),s=this.serializeMessage();if(r){const o=this._getMessageSignednessErrors(s,t);if(o){let a="Signature verification failed.";throw o.invalid&&(a+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(u=>u.toBase58()).join("`, `")}\`].`),o.missing&&(a+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(u=>u.toBase58()).join("`, `")}\`].`),new Error(a)}}return this._serialize(s)}_serialize(e){const{signatures:t}=this,r=[];Me(r,t.length);const s=r.length+t.length*64+e.length,o=$.Buffer.alloc(s);return we(t.length<256),$.Buffer.from(r).copy(o,0),t.forEach(({signature:a},u)=>{a!==null&&(we(a.length===64,"signature has invalid length"),$.Buffer.from(a).copy(o,r.length+u*64))}),e.copy(o,r.length+t.length*64),we(o.length<=At,`Transaction too large: ${o.length} > ${At}`),o}get keys(){return we(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return we(this.instructions.length===1),this.instructions[0].programId}get data(){return we(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const r=Ke(t);let s=[];for(let o=0;o<r;o++){const a=Ce(t,0,Ms);s.push(Se.encode($.Buffer.from(a)))}return sn.populate(Ct.from(t),s)}static populate(e,t=[]){const r=new sn;return r.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(r.feePayer=e.accountKeys[0]),t.forEach((s,o)=>{const a={signature:s==Se.encode(nc)?null:Se.decode(s),publicKey:e.accountKeys[o]};r.signatures.push(a)}),e.instructions.forEach(s=>{const o=s.accounts.map(a=>{const u=e.accountKeys[a];return{pubkey:u,isSigner:r.signatures.some(c=>c.publicKey.toString()===u.toString())||e.isAccountSigner(a),isWritable:e.isAccountWritable(a)}});r.instructions.push(new ze({keys:o,programId:e.accountKeys[s.programIdIndex],data:Se.decode(s.data)}))}),r._message=e,r._json=r.toJSON(),r}}new R("SysvarC1ock11111111111111111111111111111111");new R("SysvarEpochSchedu1e111111111111111111111111");new R("Sysvar1nstructions1111111111111111111111111");const ar=new R("SysvarRecentB1ockHashes11111111111111111111"),rs=new R("SysvarRent111111111111111111111111111111111");new R("SysvarRewards111111111111111111111111111111");new R("SysvarS1otHashes111111111111111111111111111");new R("SysvarS1otHistory11111111111111111111111111");new R("SysvarStakeHistory1111111111111111111111111");function Te(n,e){const t=n.layout.span>=0?n.layout.span:Cs(n,e),r=$.Buffer.alloc(t),s=Object.assign({instruction:n.index},e);return n.layout.encode(s,r),r}const rc=xe("lamportsPerSignature"),sc=K([N("version"),N("state"),Z("authorizedPubkey"),Z("nonce"),K([rc],"feeCalculator")]),ss=sc.span,oc=n=>{const e=n.decode.bind(n),t=n.encode.bind(n);return{decode:e,encode:t}},ic=n=>e=>{const t=le(n,e),{encode:r,decode:s}=oc(t),o=t;return o.decode=(a,u)=>{const c=s(a,u);return uo($.Buffer.from(c))},o.encode=(a,u,c)=>{const d=lo(a,n);return r(d,u,c)},o},kt=ic(8),Le=Object.freeze({Create:{index:0,layout:K([N("instruction"),Re("lamports"),Re("space"),Z("programId")])},Assign:{index:1,layout:K([N("instruction"),Z("programId")])},Transfer:{index:2,layout:K([N("instruction"),kt("lamports")])},CreateWithSeed:{index:3,layout:K([N("instruction"),Z("base"),xt("seed"),Re("lamports"),Re("space"),Z("programId")])},AdvanceNonceAccount:{index:4,layout:K([N("instruction")])},WithdrawNonceAccount:{index:5,layout:K([N("instruction"),Re("lamports")])},InitializeNonceAccount:{index:6,layout:K([N("instruction"),Z("authorized")])},AuthorizeNonceAccount:{index:7,layout:K([N("instruction"),Z("authorized")])},Allocate:{index:8,layout:K([N("instruction"),Re("space")])},AllocateWithSeed:{index:9,layout:K([N("instruction"),Z("base"),xt("seed"),Re("space"),Z("programId")])},AssignWithSeed:{index:10,layout:K([N("instruction"),Z("base"),xt("seed"),Z("programId")])},TransferWithSeed:{index:11,layout:K([N("instruction"),kt("lamports"),xt("seed"),Z("programId")])},UpgradeNonceAccount:{index:12,layout:K([N("instruction")])}});class Ft{constructor(){}static createAccount(e){const t=Le.Create,r=Te(t,{lamports:e.lamports,space:e.space,programId:Ee(e.programId.toBuffer())});return new ze({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(e){let t,r;if("basePubkey"in e){const s=Le.TransferWithSeed;t=Te(s,{lamports:BigInt(e.lamports),seed:e.seed,programId:Ee(e.programId.toBuffer())}),r=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=Le.Transfer;t=Te(s,{lamports:BigInt(e.lamports)}),r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new ze({keys:r,programId:this.programId,data:t})}static assign(e){let t,r;if("basePubkey"in e){const s=Le.AssignWithSeed;t=Te(s,{base:Ee(e.basePubkey.toBuffer()),seed:e.seed,programId:Ee(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Le.Assign;t=Te(s,{programId:Ee(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ze({keys:r,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=Le.CreateWithSeed,r=Te(t,{base:Ee(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:Ee(e.programId.toBuffer())});let s=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||s.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new ze({keys:s,programId:this.programId,data:r})}static createNonceAccount(e){const t=new sn;"basePubkey"in e&&"seed"in e?t.add(Ft.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:ss,programId:this.programId})):t.add(Ft.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:ss,programId:this.programId}));const r={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(r)),t}static nonceInitialize(e){const t=Le.InitializeNonceAccount,r=Te(t,{authorized:Ee(e.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:rs,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new ze(s)}static nonceAdvance(e){const t=Le.AdvanceNonceAccount,r=Te(t),s={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new ze(s)}static nonceWithdraw(e){const t=Le.WithdrawNonceAccount,r=Te(t,{lamports:e.lamports});return new ze({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:ar,isSigner:!1,isWritable:!1},{pubkey:rs,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(e){const t=Le.AuthorizeNonceAccount,r=Te(t,{authorized:Ee(e.newAuthorizedPubkey.toBuffer())});return new ze({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(e){let t,r;if("basePubkey"in e){const s=Le.AllocateWithSeed;t=Te(s,{base:Ee(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:Ee(e.programId.toBuffer())}),r=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Le.Allocate;t=Te(s,{space:e.space}),r=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ze({keys:r,programId:this.programId,data:t})}}Ft.programId=new R("11111111111111111111111111111111");new R("BPFLoader2111111111111111111111111111111111");K([N("typeIndex"),kt("deactivationSlot"),xe("lastExtendedSlot"),ee("lastExtendedStartIndex"),ee(),ve(Z(),wt(ee(),-1),"authority")]);const ue=Ot(Ir(R),k(),n=>new R(n)),Ps=kr([k(),ie("base64")]),vr=Ot(Ir($.Buffer),Ps,n=>$.Buffer.from(n[0],"base64"));function Ns(n){return Ae([x({jsonrpc:ie("2.0"),id:k(),result:n}),x({jsonrpc:ie("2.0"),id:k(),error:x({code:vt(),message:k(),data:U(Ci())})})])}const cc=Ns(vt());function te(n){return Ot(Ns(n),cc,e=>"error"in e?e:{...e,result:Kt(e.result,n)})}function Pe(n){return te(x({context:x({slot:p()}),value:n}))}function hn(n){return x({context:x({slot:p()}),value:n})}const ac=x({foundation:p(),foundationTerm:p(),initial:p(),taper:p(),terminal:p()});te(v(T(x({epoch:p(),effectiveSlot:p(),amount:p(),postBalance:p(),commission:U(T(p()))}))));const uc=v(x({slot:p(),prioritizationFee:p()})),lc=x({total:p(),validator:p(),foundation:p(),epoch:p()}),dc=x({epoch:p(),slotIndex:p(),slotsInEpoch:p(),absoluteSlot:p(),blockHeight:U(p()),transactionCount:U(p())}),fc=x({slotsPerEpoch:p(),leaderScheduleSlotOffset:p(),warmup:We(),firstNormalEpoch:p(),firstNormalSlot:p()}),hc=vs(k(),v(p())),yt=T(Ae([x({}),k()])),pc=x({err:yt}),gc=ie("receivedSignature");x({"solana-core":k(),"feature-set":U(p())});const mc=x({program:k(),programId:ue,parsed:vt()}),yc=x({programId:ue,accounts:v(ue),data:k()});Pe(x({err:T(Ae([x({}),k()])),logs:T(v(k())),accounts:U(T(v(T(x({executable:We(),owner:k(),lamports:p(),data:v(k()),rentEpoch:U(p())}))))),unitsConsumed:U(p()),returnData:U(T(x({programId:k(),data:kr([k(),ie("base64")])}))),innerInstructions:U(T(v(x({index:p(),instructions:v(Ae([mc,yc]))}))))}));Pe(x({byIdentity:vs(k(),v(p())),range:x({firstSlot:p(),lastSlot:p()})}));te(ac);te(lc);te(uc);te(dc);te(fc);te(hc);te(p());Pe(x({total:p(),circulating:p(),nonCirculating:p(),nonCirculatingAccounts:v(ue)}));const bc=x({amount:k(),uiAmount:T(p()),decimals:p(),uiAmountString:U(k())});Pe(v(x({address:ue,amount:k(),uiAmount:T(p()),decimals:p(),uiAmountString:U(k())})));Pe(v(x({pubkey:ue,account:x({executable:We(),owner:ue,lamports:p(),data:vr,rentEpoch:p()})})));const gr=x({program:k(),parsed:vt(),space:p()});Pe(v(x({pubkey:ue,account:x({executable:We(),owner:ue,lamports:p(),data:gr,rentEpoch:p()})})));Pe(v(x({lamports:p(),address:ue})));const Tr=x({executable:We(),owner:ue,lamports:p(),data:vr,rentEpoch:p()});x({pubkey:ue,account:Tr});const xc=Ot(Ae([Ir($.Buffer),gr]),Ae([Ps,gr]),n=>Array.isArray(n)?Kt(n,vr):n),wc=x({executable:We(),owner:ue,lamports:p(),data:xc,rentEpoch:p()});x({pubkey:ue,account:wc});x({state:Ae([ie("active"),ie("inactive"),ie("activating"),ie("deactivating")]),active:p(),inactive:p()});te(v(x({signature:k(),slot:p(),err:yt,memo:T(k()),blockTime:U(T(p()))})));te(v(x({signature:k(),slot:p(),err:yt,memo:T(k()),blockTime:U(T(p()))})));x({subscription:p(),result:hn(Tr)});const Sc=x({pubkey:ue,account:Tr});x({subscription:p(),result:hn(Sc)});const Ac=x({parent:p(),slot:p(),root:p()});x({subscription:p(),result:Ac});const Bc=Ae([x({type:Ae([ie("firstShredReceived"),ie("completed"),ie("optimisticConfirmation"),ie("root")]),slot:p(),timestamp:p()}),x({type:ie("createdBank"),parent:p(),slot:p(),timestamp:p()}),x({type:ie("frozen"),slot:p(),timestamp:p(),stats:x({numTransactionEntries:p(),numSuccessfulTransactions:p(),numFailedTransactions:p(),maxTransactionsPerEntry:p()})}),x({type:ie("dead"),slot:p(),timestamp:p(),err:k()})]);x({subscription:p(),result:Bc});x({subscription:p(),result:hn(Ae([pc,gc]))});x({subscription:p(),result:p()});x({pubkey:k(),gossip:T(k()),tpu:T(k()),rpc:T(k()),version:T(k())});const os=x({votePubkey:k(),nodePubkey:k(),activatedStake:p(),epochVoteAccount:We(),epochCredits:v(kr([p(),p(),p()])),commission:p(),lastVote:p(),rootSlot:T(p())});te(x({current:v(os),delinquent:v(os)}));const Ic=Ae([ie("processed"),ie("confirmed"),ie("finalized")]),kc=x({slot:p(),confirmations:T(p()),err:yt,confirmationStatus:U(Ic)});Pe(v(T(kc)));te(p());const Ds=x({accountKey:ue,writableIndexes:v(p()),readonlyIndexes:v(p())}),Lr=x({signatures:v(k()),message:x({accountKeys:v(k()),header:x({numRequiredSignatures:p(),numReadonlySignedAccounts:p(),numReadonlyUnsignedAccounts:p()}),instructions:v(x({accounts:v(p()),data:k(),programIdIndex:p()})),recentBlockhash:k(),addressTableLookups:U(v(Ds))})}),Us=x({pubkey:ue,signer:We(),writable:We(),source:U(Ae([ie("transaction"),ie("lookupTable")]))}),Os=x({accountKeys:v(Us),signatures:v(k())}),Hs=x({parsed:vt(),program:k(),programId:ue}),Ws=x({accounts:v(ue),data:k(),programId:ue}),Ec=Ae([Ws,Hs]),vc=Ae([x({parsed:vt(),program:k(),programId:k()}),x({accounts:v(k()),data:k(),programId:k()})]),_s=Ot(Ec,vc,n=>"accounts"in n?Kt(n,Ws):Kt(n,Hs)),$s=x({signatures:v(k()),message:x({accountKeys:v(Us),instructions:v(_s),recentBlockhash:k(),addressTableLookups:U(T(v(Ds)))})}),on=x({accountIndex:p(),mint:k(),owner:U(k()),uiTokenAmount:bc}),qs=x({writable:v(ue),readonly:v(ue)}),pn=x({err:yt,fee:p(),innerInstructions:U(T(v(x({index:p(),instructions:v(x({accounts:v(p()),data:k(),programIdIndex:p()}))})))),preBalances:v(p()),postBalances:v(p()),logMessages:U(T(v(k()))),preTokenBalances:U(T(v(on))),postTokenBalances:U(T(v(on))),loadedAddresses:U(qs),computeUnitsConsumed:U(p())}),zr=x({err:yt,fee:p(),innerInstructions:U(T(v(x({index:p(),instructions:v(_s)})))),preBalances:v(p()),postBalances:v(p()),logMessages:U(T(v(k()))),preTokenBalances:U(T(v(on))),postTokenBalances:U(T(v(on))),loadedAddresses:U(qs),computeUnitsConsumed:U(p())}),Tt=Ae([ie(0),ie("legacy")]),bt=x({pubkey:k(),lamports:p(),postBalance:T(p()),rewardType:T(k()),commission:U(T(p()))});te(T(x({blockhash:k(),previousBlockhash:k(),parentSlot:p(),transactions:v(x({transaction:Lr,meta:T(pn),version:U(Tt)})),rewards:U(v(bt)),blockTime:T(p()),blockHeight:T(p())})));te(T(x({blockhash:k(),previousBlockhash:k(),parentSlot:p(),rewards:U(v(bt)),blockTime:T(p()),blockHeight:T(p())})));te(T(x({blockhash:k(),previousBlockhash:k(),parentSlot:p(),transactions:v(x({transaction:Os,meta:T(pn),version:U(Tt)})),rewards:U(v(bt)),blockTime:T(p()),blockHeight:T(p())})));te(T(x({blockhash:k(),previousBlockhash:k(),parentSlot:p(),transactions:v(x({transaction:$s,meta:T(zr),version:U(Tt)})),rewards:U(v(bt)),blockTime:T(p()),blockHeight:T(p())})));te(T(x({blockhash:k(),previousBlockhash:k(),parentSlot:p(),transactions:v(x({transaction:Os,meta:T(zr),version:U(Tt)})),rewards:U(v(bt)),blockTime:T(p()),blockHeight:T(p())})));te(T(x({blockhash:k(),previousBlockhash:k(),parentSlot:p(),rewards:U(v(bt)),blockTime:T(p()),blockHeight:T(p())})));te(T(x({blockhash:k(),previousBlockhash:k(),parentSlot:p(),transactions:v(x({transaction:Lr,meta:T(pn)})),rewards:U(v(bt)),blockTime:T(p())})));te(T(x({blockhash:k(),previousBlockhash:k(),parentSlot:p(),signatures:v(k()),blockTime:T(p())})));te(T(x({slot:p(),meta:T(pn),blockTime:U(T(p())),transaction:Lr,version:U(Tt)})));te(T(x({slot:p(),transaction:$s,meta:T(zr),blockTime:U(T(p())),version:U(Tt)})));Pe(x({blockhash:k(),feeCalculator:x({lamportsPerSignature:p()})}));Pe(x({blockhash:k(),lastValidBlockHeight:p()}));Pe(We());const Tc=x({slot:p(),numTransactions:p(),numSlots:p(),samplePeriodSecs:p()});te(v(Tc));Pe(T(x({feeCalculator:x({lamportsPerSignature:p()})})));te(k());te(k());const Lc=x({err:yt,logs:v(k()),signature:k()});x({result:hn(Lc),subscription:p()});Object.freeze({CreateLookupTable:{index:0,layout:K([N("instruction"),kt("recentSlot"),ee("bumpSeed")])},FreezeLookupTable:{index:1,layout:K([N("instruction")])},ExtendLookupTable:{index:2,layout:K([N("instruction"),kt(),ve(Z(),wt(N(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:K([N("instruction")])},CloseLookupTable:{index:4,layout:K([N("instruction")])}});new R("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:K([ee("instruction"),N("units"),N("additionalFee")])},RequestHeapFrame:{index:1,layout:K([ee("instruction"),N("bytes")])},SetComputeUnitLimit:{index:2,layout:K([ee("instruction"),N("units")])},SetComputeUnitPrice:{index:3,layout:K([ee("instruction"),kt("microLamports")])}});new R("ComputeBudget111111111111111111111111111111");K([ee("numSignatures"),ee("padding"),Ue("signatureOffset"),Ue("signatureInstructionIndex"),Ue("publicKeyOffset"),Ue("publicKeyInstructionIndex"),Ue("messageDataOffset"),Ue("messageDataSize"),Ue("messageInstructionIndex")]);new R("Ed25519SigVerify111111111111111111111111111");Er.utils.isValidPrivateKey;Er.getPublicKey;K([ee("numSignatures"),Ue("signatureOffset"),ee("signatureInstructionIndex"),Ue("ethAddressOffset"),ee("ethAddressInstructionIndex"),Ue("messageDataOffset"),Ue("messageDataSize"),ee("messageInstructionIndex"),le(20,"ethAddress"),le(64,"signature"),ee("recoveryId")]);new R("KeccakSecp256k11111111111111111111111111111");var js;new R("StakeConfig11111111111111111111111111111111");class Vs{constructor(e,t,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=r}}js=Vs;Vs.default=new js(0,0,R.default);Object.freeze({Initialize:{index:0,layout:K([N("instruction"),Ji(),Qi()])},Authorize:{index:1,layout:K([N("instruction"),Z("newAuthorized"),N("stakeAuthorizationType")])},Delegate:{index:2,layout:K([N("instruction")])},Split:{index:3,layout:K([N("instruction"),Re("lamports")])},Withdraw:{index:4,layout:K([N("instruction"),Re("lamports")])},Deactivate:{index:5,layout:K([N("instruction")])},Merge:{index:7,layout:K([N("instruction")])},AuthorizeWithSeed:{index:8,layout:K([N("instruction"),Z("newAuthorized"),N("stakeAuthorizationType"),xt("authoritySeed"),Z("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});new R("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:K([N("instruction"),ec()])},Authorize:{index:1,layout:K([N("instruction"),Z("newAuthorized"),N("voteAuthorizationType")])},Withdraw:{index:3,layout:K([N("instruction"),Re("lamports")])},UpdateValidatorIdentity:{index:4,layout:K([N("instruction")])},AuthorizeWithSeed:{index:10,layout:K([N("instruction"),tc()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});new R("Vote111111111111111111111111111111111111111");new R("Va1idator1nfo111111111111111111111111111111");x({name:k(),website:U(k()),details:U(k()),iconUrl:U(k()),keybaseUsername:U(k())});new R("Vote111111111111111111111111111111111111111");K([Z("nodePubkey"),Z("authorizedWithdrawer"),ee("commission"),xe(),ve(K([xe("slot"),N("confirmationCount")]),wt(N(),-8),"votes"),ee("rootSlotValid"),xe("rootSlot"),xe(),ve(K([xe("epoch"),Z("authorizedVoter")]),wt(N(),-8),"authorizedVoters"),K([ve(K([Z("authorizedPubkey"),xe("epochOfLastAuthorizedSwitch"),xe("targetEpoch")]),32,"buf"),xe("idx"),ee("isEmpty")],"priorVoters"),xe(),ve(K([xe("epoch"),xe("credits"),xe("prevCredits")]),wt(N(),-8),"epochCredits"),K([xe("slot"),xe("timestamp")],"lastTimestamp")]);const zc=[156,194,70,44,22,88,137,44];class nt{multisig;creator;index;bump;vaultIndex;vaultBump;size;executedTransactionIndex;constructor(e,t,r,s,o,a,u,c){this.multisig=e,this.creator=t,this.index=r,this.bump=s,this.vaultIndex=o,this.vaultBump=a,this.size=u,this.executedTransactionIndex=c}static fromArgs(e){return new nt(e.multisig,e.creator,e.index,e.bump,e.vaultIndex,e.vaultBump,e.size,e.executedTransactionIndex)}static fromAccountInfo(e,t=0){return nt.deserialize(e.data,t)}static async fromAccountAddress(e,t,r){const s=await e.getAccountInfo(t,r);if(s==null)throw new Error(`Unable to find Batch account at ${t}`);return nt.fromAccountInfo(s,0)[0]}static gpaBuilder(e=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(e,jt)}static deserialize(e,t=0){return jt.deserialize(e,t)}serialize(){return jt.serialize({accountDiscriminator:zc,...this})}static get byteSize(){return jt.byteSize}static async getMinimumBalanceForRentExemption(e,t){return e.getMinimumBalanceForRentExemption(nt.byteSize,t)}static hasCorrectByteSize(e,t=0){return e.byteLength-t===nt.byteSize}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const e=this.index;if(typeof e.toNumber=="function")try{return e.toNumber()}catch{return e}return e})(),bump:this.bump,vaultIndex:this.vaultIndex,vaultBump:this.vaultBump,size:this.size,executedTransactionIndex:this.executedTransactionIndex}}}const jt=new i.BeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["multisig",F.publicKey],["creator",F.publicKey],["index",i.u64],["bump",i.u8],["vaultIndex",i.u8],["vaultBump",i.u8],["size",i.u32],["executedTransactionIndex",i.u32]],nt.fromArgs,"Batch"),Rc=new i.BeetArgsStruct([["mask",i.u8]],"Permissions"),Ht=new i.BeetArgsStruct([["key",F.publicKey],["permissions",Rc]],"Member");var cn;(function(n){n[n.OneTime=0]="OneTime",n[n.Day=1]="Day",n[n.Week=2]="Week",n[n.Month=3]="Month"})(cn||(cn={}));const Rr=i.fixedScalarEnum(cn),Gs=i.dataEnum([["AddMember",new i.BeetArgsStruct([["newMember",Ht]],'ConfigActionRecord["AddMember"]')],["RemoveMember",new i.BeetArgsStruct([["oldMember",F.publicKey]],'ConfigActionRecord["RemoveMember"]')],["ChangeThreshold",new i.BeetArgsStruct([["newThreshold",i.u16]],'ConfigActionRecord["ChangeThreshold"]')],["SetTimeLock",new i.BeetArgsStruct([["newTimeLock",i.u32]],'ConfigActionRecord["SetTimeLock"]')],["AddSpendingLimit",new i.FixableBeetArgsStruct([["createKey",F.publicKey],["vaultIndex",i.u8],["mint",F.publicKey],["amount",i.u64],["period",Rr],["members",i.array(F.publicKey)],["destinations",i.array(F.publicKey)]],'ConfigActionRecord["AddSpendingLimit"]')],["RemoveSpendingLimit",new i.BeetArgsStruct([["spendingLimit",F.publicKey]],'ConfigActionRecord["RemoveSpendingLimit"]')],["SetRentCollector",new i.FixableBeetArgsStruct([["newRentCollector",i.coption(F.publicKey)]],'ConfigActionRecord["SetRentCollector"]')]]),is=[94,8,4,35,113,139,139,112];class rt{multisig;creator;index;bump;actions;constructor(e,t,r,s,o){this.multisig=e,this.creator=t,this.index=r,this.bump=s,this.actions=o}static fromArgs(e){return new rt(e.multisig,e.creator,e.index,e.bump,e.actions)}static fromAccountInfo(e,t=0){return rt.deserialize(e.data,t)}static async fromAccountAddress(e,t,r){const s=await e.getAccountInfo(t,r);if(s==null)throw new Error(`Unable to find ConfigTransaction account at ${t}`);return rt.fromAccountInfo(s,0)[0]}static gpaBuilder(e=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(e,Vt)}static deserialize(e,t=0){return Vt.deserialize(e,t)}serialize(){return Vt.serialize({accountDiscriminator:is,...this})}static byteSize(e){const t=rt.fromArgs(e);return Vt.toFixedFromValue({accountDiscriminator:is,...t}).byteSize}static async getMinimumBalanceForRentExemption(e,t,r){return t.getMinimumBalanceForRentExemption(rt.byteSize(e),r)}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const e=this.index;if(typeof e.toNumber=="function")try{return e.toNumber()}catch{return e}return e})(),bump:this.bump,actions:this.actions}}}const Vt=new i.FixableBeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["multisig",F.publicKey],["creator",F.publicKey],["index",i.u64],["bump",i.u8],["actions",i.array(Gs)]],rt.fromArgs,"ConfigTransaction"),cs=[224,116,121,186,68,161,79,236];class st{createKey;configAuthority;threshold;timeLock;transactionIndex;staleTransactionIndex;rentCollector;bump;members;constructor(e,t,r,s,o,a,u,c,d){this.createKey=e,this.configAuthority=t,this.threshold=r,this.timeLock=s,this.transactionIndex=o,this.staleTransactionIndex=a,this.rentCollector=u,this.bump=c,this.members=d}static fromArgs(e){return new st(e.createKey,e.configAuthority,e.threshold,e.timeLock,e.transactionIndex,e.staleTransactionIndex,e.rentCollector,e.bump,e.members)}static fromAccountInfo(e,t=0){return st.deserialize(e.data,t)}static async fromAccountAddress(e,t,r){const s=await e.getAccountInfo(t,r);if(s==null)throw new Error(`Unable to find Multisig account at ${t}`);return st.fromAccountInfo(s,0)[0]}static gpaBuilder(e=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(e,Gt)}static deserialize(e,t=0){return Gt.deserialize(e,t)}serialize(){return Gt.serialize({accountDiscriminator:cs,...this})}static byteSize(e){const t=st.fromArgs(e);return Gt.toFixedFromValue({accountDiscriminator:cs,...t}).byteSize}static async getMinimumBalanceForRentExemption(e,t,r){return t.getMinimumBalanceForRentExemption(st.byteSize(e),r)}pretty(){return{createKey:this.createKey.toBase58(),configAuthority:this.configAuthority.toBase58(),threshold:this.threshold,timeLock:this.timeLock,transactionIndex:(()=>{const e=this.transactionIndex;if(typeof e.toNumber=="function")try{return e.toNumber()}catch{return e}return e})(),staleTransactionIndex:(()=>{const e=this.staleTransactionIndex;if(typeof e.toNumber=="function")try{return e.toNumber()}catch{return e}return e})(),rentCollector:this.rentCollector,bump:this.bump,members:this.members}}}const Gt=new i.FixableBeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["createKey",F.publicKey],["configAuthority",F.publicKey],["threshold",i.u16],["timeLock",i.u32],["transactionIndex",i.u64],["staleTransactionIndex",i.u64],["rentCollector",i.coption(F.publicKey)],["bump",i.u8],["members",i.array(Ht)]],st.fromArgs,"Multisig"),Kc=[196,210,90,231,144,149,140,63];class ot{authority;multisigCreationFee;treasury;reserved;constructor(e,t,r,s){this.authority=e,this.multisigCreationFee=t,this.treasury=r,this.reserved=s}static fromArgs(e){return new ot(e.authority,e.multisigCreationFee,e.treasury,e.reserved)}static fromAccountInfo(e,t=0){return ot.deserialize(e.data,t)}static async fromAccountAddress(e,t,r){const s=await e.getAccountInfo(t,r);if(s==null)throw new Error(`Unable to find ProgramConfig account at ${t}`);return ot.fromAccountInfo(s,0)[0]}static gpaBuilder(e=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(e,Zt)}static deserialize(e,t=0){return Zt.deserialize(e,t)}serialize(){return Zt.serialize({accountDiscriminator:Kc,...this})}static get byteSize(){return Zt.byteSize}static async getMinimumBalanceForRentExemption(e,t){return e.getMinimumBalanceForRentExemption(ot.byteSize,t)}static hasCorrectByteSize(e,t=0){return e.byteLength-t===ot.byteSize}pretty(){return{authority:this.authority.toBase58(),multisigCreationFee:(()=>{const e=this.multisigCreationFee;if(typeof e.toNumber=="function")try{return e.toNumber()}catch{return e}return e})(),treasury:this.treasury.toBase58(),reserved:this.reserved}}}const Zt=new i.BeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["authority",F.publicKey],["multisigCreationFee",i.u64],["treasury",F.publicKey],["reserved",i.uniformFixedSizeArray(i.u8,64)]],ot.fromArgs,"ProgramConfig"),Mc=i.dataEnum([["Draft",new i.BeetArgsStruct([["timestamp",i.i64]],'ProposalStatusRecord["Draft"]')],["Active",new i.BeetArgsStruct([["timestamp",i.i64]],'ProposalStatusRecord["Active"]')],["Rejected",new i.BeetArgsStruct([["timestamp",i.i64]],'ProposalStatusRecord["Rejected"]')],["Approved",new i.BeetArgsStruct([["timestamp",i.i64]],'ProposalStatusRecord["Approved"]')],["Executing",i.unit],["Executed",new i.BeetArgsStruct([["timestamp",i.i64]],'ProposalStatusRecord["Executed"]')],["Cancelled",new i.BeetArgsStruct([["timestamp",i.i64]],'ProposalStatusRecord["Cancelled"]')]]),as=[26,94,189,187,116,136,53,33];class it{multisig;transactionIndex;status;bump;approved;rejected;cancelled;constructor(e,t,r,s,o,a,u){this.multisig=e,this.transactionIndex=t,this.status=r,this.bump=s,this.approved=o,this.rejected=a,this.cancelled=u}static fromArgs(e){return new it(e.multisig,e.transactionIndex,e.status,e.bump,e.approved,e.rejected,e.cancelled)}static fromAccountInfo(e,t=0){return it.deserialize(e.data,t)}static async fromAccountAddress(e,t,r){const s=await e.getAccountInfo(t,r);if(s==null)throw new Error(`Unable to find Proposal account at ${t}`);return it.fromAccountInfo(s,0)[0]}static gpaBuilder(e=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(e,Yt)}static deserialize(e,t=0){return Yt.deserialize(e,t)}serialize(){return Yt.serialize({accountDiscriminator:as,...this})}static byteSize(e){const t=it.fromArgs(e);return Yt.toFixedFromValue({accountDiscriminator:as,...t}).byteSize}static async getMinimumBalanceForRentExemption(e,t,r){return t.getMinimumBalanceForRentExemption(it.byteSize(e),r)}pretty(){return{multisig:this.multisig.toBase58(),transactionIndex:(()=>{const e=this.transactionIndex;if(typeof e.toNumber=="function")try{return e.toNumber()}catch{return e}return e})(),status:this.status.__kind,bump:this.bump,approved:this.approved,rejected:this.rejected,cancelled:this.cancelled}}}const Yt=new i.FixableBeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["multisig",F.publicKey],["transactionIndex",i.u64],["status",Mc],["bump",i.u8],["approved",i.array(F.publicKey)],["rejected",i.array(F.publicKey)],["cancelled",i.array(F.publicKey)]],it.fromArgs,"Proposal"),us=[10,201,27,160,218,195,222,152];class ct{multisig;createKey;vaultIndex;mint;amount;period;remainingAmount;lastReset;bump;members;destinations;constructor(e,t,r,s,o,a,u,c,d,l,f){this.multisig=e,this.createKey=t,this.vaultIndex=r,this.mint=s,this.amount=o,this.period=a,this.remainingAmount=u,this.lastReset=c,this.bump=d,this.members=l,this.destinations=f}static fromArgs(e){return new ct(e.multisig,e.createKey,e.vaultIndex,e.mint,e.amount,e.period,e.remainingAmount,e.lastReset,e.bump,e.members,e.destinations)}static fromAccountInfo(e,t=0){return ct.deserialize(e.data,t)}static async fromAccountAddress(e,t,r){const s=await e.getAccountInfo(t,r);if(s==null)throw new Error(`Unable to find SpendingLimit account at ${t}`);return ct.fromAccountInfo(s,0)[0]}static gpaBuilder(e=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(e,Xt)}static deserialize(e,t=0){return Xt.deserialize(e,t)}serialize(){return Xt.serialize({accountDiscriminator:us,...this})}static byteSize(e){const t=ct.fromArgs(e);return Xt.toFixedFromValue({accountDiscriminator:us,...t}).byteSize}static async getMinimumBalanceForRentExemption(e,t,r){return t.getMinimumBalanceForRentExemption(ct.byteSize(e),r)}pretty(){return{multisig:this.multisig.toBase58(),createKey:this.createKey.toBase58(),vaultIndex:this.vaultIndex,mint:this.mint.toBase58(),amount:(()=>{const e=this.amount;if(typeof e.toNumber=="function")try{return e.toNumber()}catch{return e}return e})(),period:"Period."+cn[this.period],remainingAmount:(()=>{const e=this.remainingAmount;if(typeof e.toNumber=="function")try{return e.toNumber()}catch{return e}return e})(),lastReset:(()=>{const e=this.lastReset;if(typeof e.toNumber=="function")try{return e.toNumber()}catch{return e}return e})(),bump:this.bump,members:this.members,destinations:this.destinations}}}const Xt=new i.FixableBeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["multisig",F.publicKey],["createKey",F.publicKey],["vaultIndex",i.u8],["mint",F.publicKey],["amount",i.u64],["period",Rr],["remainingAmount",i.u64],["lastReset",i.i64],["bump",i.u8],["members",i.array(F.publicKey)],["destinations",i.array(F.publicKey)]],ct.fromArgs,"SpendingLimit"),Cc=new i.FixableBeetArgsStruct([["programIdIndex",i.u8],["accountIndexes",i.bytes],["data",i.bytes]],"MultisigCompiledInstruction"),Fc=new i.FixableBeetArgsStruct([["accountKey",F.publicKey],["writableIndexes",i.bytes],["readonlyIndexes",i.bytes]],"MultisigMessageAddressTableLookup"),Zs=new i.FixableBeetArgsStruct([["numSigners",i.u8],["numWritableSigners",i.u8],["numWritableNonSigners",i.u8],["accountKeys",i.array(F.publicKey)],["instructions",i.array(Cc)],["addressTableLookups",i.array(Fc)]],"VaultTransactionMessage"),ls=[196,121,46,36,12,19,252,7];class at{bump;ephemeralSignerBumps;message;constructor(e,t,r){this.bump=e,this.ephemeralSignerBumps=t,this.message=r}static fromArgs(e){return new at(e.bump,e.ephemeralSignerBumps,e.message)}static fromAccountInfo(e,t=0){return at.deserialize(e.data,t)}static async fromAccountAddress(e,t,r){const s=await e.getAccountInfo(t,r);if(s==null)throw new Error(`Unable to find VaultBatchTransaction account at ${t}`);return at.fromAccountInfo(s,0)[0]}static gpaBuilder(e=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(e,Jt)}static deserialize(e,t=0){return Jt.deserialize(e,t)}serialize(){return Jt.serialize({accountDiscriminator:ls,...this})}static byteSize(e){const t=at.fromArgs(e);return Jt.toFixedFromValue({accountDiscriminator:ls,...t}).byteSize}static async getMinimumBalanceForRentExemption(e,t,r){return t.getMinimumBalanceForRentExemption(at.byteSize(e),r)}pretty(){return{bump:this.bump,ephemeralSignerBumps:this.ephemeralSignerBumps,message:this.message}}}const Jt=new i.FixableBeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["bump",i.u8],["ephemeralSignerBumps",i.bytes],["message",Zs]],at.fromArgs,"VaultBatchTransaction"),ds=[168,250,162,100,81,14,162,207];class ut{multisig;creator;index;bump;vaultIndex;vaultBump;ephemeralSignerBumps;message;constructor(e,t,r,s,o,a,u,c){this.multisig=e,this.creator=t,this.index=r,this.bump=s,this.vaultIndex=o,this.vaultBump=a,this.ephemeralSignerBumps=u,this.message=c}static fromArgs(e){return new ut(e.multisig,e.creator,e.index,e.bump,e.vaultIndex,e.vaultBump,e.ephemeralSignerBumps,e.message)}static fromAccountInfo(e,t=0){return ut.deserialize(e.data,t)}static async fromAccountAddress(e,t,r){const s=await e.getAccountInfo(t,r);if(s==null)throw new Error(`Unable to find VaultTransaction account at ${t}`);return ut.fromAccountInfo(s,0)[0]}static gpaBuilder(e=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return F.GpaBuilder.fromStruct(e,Qt)}static deserialize(e,t=0){return Qt.deserialize(e,t)}serialize(){return Qt.serialize({accountDiscriminator:ds,...this})}static byteSize(e){const t=ut.fromArgs(e);return Qt.toFixedFromValue({accountDiscriminator:ds,...t}).byteSize}static async getMinimumBalanceForRentExemption(e,t,r){return t.getMinimumBalanceForRentExemption(ut.byteSize(e),r)}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const e=this.index;if(typeof e.toNumber=="function")try{return e.toNumber()}catch{return e}return e})(),bump:this.bump,vaultIndex:this.vaultIndex,vaultBump:this.vaultBump,ephemeralSignerBumps:this.ephemeralSignerBumps,message:this.message}}}const Qt=new i.FixableBeetStruct([["accountDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["multisig",F.publicKey],["creator",F.publicKey],["index",i.u64],["bump",i.u8],["vaultIndex",i.u8],["vaultBump",i.u8],["ephemeralSignerBumps",i.bytes],["message",Zs]],ut.fromArgs,"VaultTransaction"),q=new Map,V=new Map;class gn extends Error{code=6e3;name="DuplicateMember";constructor(){super("Found multiple members with the same pubkey"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,gn)}}q.set(6e3,()=>new gn);V.set("DuplicateMember",()=>new gn);class mn extends Error{code=6001;name="EmptyMembers";constructor(){super("Members array is empty"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,mn)}}q.set(6001,()=>new mn);V.set("EmptyMembers",()=>new mn);class yn extends Error{code=6002;name="TooManyMembers";constructor(){super("Too many members, can be up to 65535"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,yn)}}q.set(6002,()=>new yn);V.set("TooManyMembers",()=>new yn);class bn extends Error{code=6003;name="InvalidThreshold";constructor(){super("Invalid threshold, must be between 1 and number of members with Vote permission"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,bn)}}q.set(6003,()=>new bn);V.set("InvalidThreshold",()=>new bn);class xn extends Error{code=6004;name="Unauthorized";constructor(){super("Attempted to perform an unauthorized action"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,xn)}}q.set(6004,()=>new xn);V.set("Unauthorized",()=>new xn);class wn extends Error{code=6005;name="NotAMember";constructor(){super("Provided pubkey is not a member of multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,wn)}}q.set(6005,()=>new wn);V.set("NotAMember",()=>new wn);class Sn extends Error{code=6006;name="InvalidTransactionMessage";constructor(){super("TransactionMessage is malformed."),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Sn)}}q.set(6006,()=>new Sn);V.set("InvalidTransactionMessage",()=>new Sn);class An extends Error{code=6007;name="StaleProposal";constructor(){super("Proposal is stale"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,An)}}q.set(6007,()=>new An);V.set("StaleProposal",()=>new An);class Bn extends Error{code=6008;name="InvalidProposalStatus";constructor(){super("Invalid proposal status"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Bn)}}q.set(6008,()=>new Bn);V.set("InvalidProposalStatus",()=>new Bn);class In extends Error{code=6009;name="InvalidTransactionIndex";constructor(){super("Invalid transaction index"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,In)}}q.set(6009,()=>new In);V.set("InvalidTransactionIndex",()=>new In);class kn extends Error{code=6010;name="AlreadyApproved";constructor(){super("Member already approved the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,kn)}}q.set(6010,()=>new kn);V.set("AlreadyApproved",()=>new kn);class En extends Error{code=6011;name="AlreadyRejected";constructor(){super("Member already rejected the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,En)}}q.set(6011,()=>new En);V.set("AlreadyRejected",()=>new En);class vn extends Error{code=6012;name="AlreadyCancelled";constructor(){super("Member already cancelled the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,vn)}}q.set(6012,()=>new vn);V.set("AlreadyCancelled",()=>new vn);class Tn extends Error{code=6013;name="InvalidNumberOfAccounts";constructor(){super("Wrong number of accounts provided"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Tn)}}q.set(6013,()=>new Tn);V.set("InvalidNumberOfAccounts",()=>new Tn);class Ln extends Error{code=6014;name="InvalidAccount";constructor(){super("Invalid account provided"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ln)}}q.set(6014,()=>new Ln);V.set("InvalidAccount",()=>new Ln);class zn extends Error{code=6015;name="RemoveLastMember";constructor(){super("Cannot remove last member"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,zn)}}q.set(6015,()=>new zn);V.set("RemoveLastMember",()=>new zn);class Rn extends Error{code=6016;name="NoVoters";constructor(){super("Members don't include any voters"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Rn)}}q.set(6016,()=>new Rn);V.set("NoVoters",()=>new Rn);class Kn extends Error{code=6017;name="NoProposers";constructor(){super("Members don't include any proposers"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Kn)}}q.set(6017,()=>new Kn);V.set("NoProposers",()=>new Kn);class Mn extends Error{code=6018;name="NoExecutors";constructor(){super("Members don't include any executors"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Mn)}}q.set(6018,()=>new Mn);V.set("NoExecutors",()=>new Mn);class Cn extends Error{code=6019;name="InvalidStaleTransactionIndex";constructor(){super("`stale_transaction_index` must be <= `transaction_index`"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Cn)}}q.set(6019,()=>new Cn);V.set("InvalidStaleTransactionIndex",()=>new Cn);class Fn extends Error{code=6020;name="NotSupportedForControlled";constructor(){super("Instruction not supported for controlled multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Fn)}}q.set(6020,()=>new Fn);V.set("NotSupportedForControlled",()=>new Fn);class Pn extends Error{code=6021;name="TimeLockNotReleased";constructor(){super("Proposal time lock has not been released"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Pn)}}q.set(6021,()=>new Pn);V.set("TimeLockNotReleased",()=>new Pn);class Nn extends Error{code=6022;name="NoActions";constructor(){super("Config transaction must have at least one action"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Nn)}}q.set(6022,()=>new Nn);V.set("NoActions",()=>new Nn);class Dn extends Error{code=6023;name="MissingAccount";constructor(){super("Missing account"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Dn)}}q.set(6023,()=>new Dn);V.set("MissingAccount",()=>new Dn);class Un extends Error{code=6024;name="InvalidMint";constructor(){super("Invalid mint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Un)}}q.set(6024,()=>new Un);V.set("InvalidMint",()=>new Un);class On extends Error{code=6025;name="InvalidDestination";constructor(){super("Invalid destination"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,On)}}q.set(6025,()=>new On);V.set("InvalidDestination",()=>new On);class Hn extends Error{code=6026;name="SpendingLimitExceeded";constructor(){super("Spending limit exceeded"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Hn)}}q.set(6026,()=>new Hn);V.set("SpendingLimitExceeded",()=>new Hn);class Wn extends Error{code=6027;name="DecimalsMismatch";constructor(){super("Decimals don't match the mint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Wn)}}q.set(6027,()=>new Wn);V.set("DecimalsMismatch",()=>new Wn);class _n extends Error{code=6028;name="UnknownPermission";constructor(){super("Member has unknown permission"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,_n)}}q.set(6028,()=>new _n);V.set("UnknownPermission",()=>new _n);class $n extends Error{code=6029;name="ProtectedAccount";constructor(){super("Account is protected, it cannot be passed into a CPI as writable"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$n)}}q.set(6029,()=>new $n);V.set("ProtectedAccount",()=>new $n);class qn extends Error{code=6030;name="TimeLockExceedsMaxAllowed";constructor(){super("Time lock exceeds the maximum allowed (90 days)"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,qn)}}q.set(6030,()=>new qn);V.set("TimeLockExceedsMaxAllowed",()=>new qn);class jn extends Error{code=6031;name="IllegalAccountOwner";constructor(){super("Account is not owned by Multisig program"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,jn)}}q.set(6031,()=>new jn);V.set("IllegalAccountOwner",()=>new jn);class Vn extends Error{code=6032;name="RentReclamationDisabled";constructor(){super("Rent reclamation is disabled for this multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Vn)}}q.set(6032,()=>new Vn);V.set("RentReclamationDisabled",()=>new Vn);class Gn extends Error{code=6033;name="InvalidRentCollector";constructor(){super("Invalid rent collector address"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Gn)}}q.set(6033,()=>new Gn);V.set("InvalidRentCollector",()=>new Gn);class Zn extends Error{code=6034;name="ProposalForAnotherMultisig";constructor(){super("Proposal is for another multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Zn)}}q.set(6034,()=>new Zn);V.set("ProposalForAnotherMultisig",()=>new Zn);class Yn extends Error{code=6035;name="TransactionForAnotherMultisig";constructor(){super("Transaction is for another multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Yn)}}q.set(6035,()=>new Yn);V.set("TransactionForAnotherMultisig",()=>new Yn);class Xn extends Error{code=6036;name="TransactionNotMatchingProposal";constructor(){super("Transaction doesn't match proposal"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Xn)}}q.set(6036,()=>new Xn);V.set("TransactionNotMatchingProposal",()=>new Xn);class Jn extends Error{code=6037;name="TransactionNotLastInBatch";constructor(){super("Transaction is not last in batch"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Jn)}}q.set(6037,()=>new Jn);V.set("TransactionNotLastInBatch",()=>new Jn);class Qn extends Error{code=6038;name="BatchNotEmpty";constructor(){super("Batch is not empty"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Qn)}}q.set(6038,()=>new Qn);V.set("BatchNotEmpty",()=>new Qn);class er extends Error{code=6039;name="SpendingLimitInvalidAmount";constructor(){super("Invalid SpendingLimit amount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,er)}}q.set(6039,()=>new er);V.set("SpendingLimitInvalidAmount",()=>new er);function Pc(n){const e=q.get(n);return e!=null?e():null}new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)]],"BatchAccountsCloseInstructionArgs");const Nc=new i.FixableBeetArgsStruct([["ephemeralSigners",i.u8],["transactionMessage",i.bytes]],"BatchAddTransactionArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Nc]],"BatchAddTransactionInstructionArgs");const Dc=new i.FixableBeetArgsStruct([["vaultIndex",i.u8],["memo",i.coption(i.utf8String)]],"BatchCreateArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Dc]],"BatchCreateInstructionArgs");new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)]],"BatchExecuteTransactionInstructionArgs");new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)]],"ConfigTransactionAccountsCloseInstructionArgs");const Uc=new i.FixableBeetArgsStruct([["actions",i.array(Gs)],["memo",i.coption(i.utf8String)]],"ConfigTransactionCreateArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Uc]],"ConfigTransactionCreateInstructionArgs");new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)]],"ConfigTransactionExecuteInstructionArgs");const Oc=new i.FixableBeetArgsStruct([["newMember",Ht],["memo",i.coption(i.utf8String)]],"MultisigAddMemberArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Oc]],"MultisigAddMemberInstructionArgs");const Hc=new i.FixableBeetArgsStruct([["createKey",F.publicKey],["vaultIndex",i.u8],["mint",F.publicKey],["amount",i.u64],["period",Rr],["members",i.array(F.publicKey)],["destinations",i.array(F.publicKey)],["memo",i.coption(i.utf8String)]],"MultisigAddSpendingLimitArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Hc]],"MultisigAddSpendingLimitInstructionArgs");const Wc=new i.FixableBeetArgsStruct([["newThreshold",i.u16],["memo",i.coption(i.utf8String)]],"MultisigChangeThresholdArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Wc]],"MultisigChangeThresholdInstructionArgs");const _c=new i.FixableBeetArgsStruct([["configAuthority",i.coption(F.publicKey)],["threshold",i.u16],["members",i.array(Ht)],["timeLock",i.u32],["memo",i.coption(i.utf8String)]],"MultisigCreateArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",_c]],"MultisigCreateInstructionArgs");const $c=new i.FixableBeetArgsStruct([["configAuthority",i.coption(F.publicKey)],["threshold",i.u16],["members",i.array(Ht)],["timeLock",i.u32],["rentCollector",i.coption(F.publicKey)],["memo",i.coption(i.utf8String)]],"MultisigCreateArgsV2");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",$c]],"MultisigCreateV2InstructionArgs");const qc=new i.FixableBeetArgsStruct([["oldMember",F.publicKey],["memo",i.coption(i.utf8String)]],"MultisigRemoveMemberArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",qc]],"MultisigRemoveMemberInstructionArgs");const jc=new i.FixableBeetArgsStruct([["memo",i.coption(i.utf8String)]],"MultisigRemoveSpendingLimitArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",jc]],"MultisigRemoveSpendingLimitInstructionArgs");const Vc=new i.FixableBeetArgsStruct([["configAuthority",F.publicKey],["memo",i.coption(i.utf8String)]],"MultisigSetConfigAuthorityArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Vc]],"MultisigSetConfigAuthorityInstructionArgs");const Gc=new i.FixableBeetArgsStruct([["rentCollector",i.coption(F.publicKey)],["memo",i.coption(i.utf8String)]],"MultisigSetRentCollectorArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Gc]],"MultisigSetRentCollectorInstructionArgs");const Zc=new i.FixableBeetArgsStruct([["timeLock",i.u32],["memo",i.coption(i.utf8String)]],"MultisigSetTimeLockArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Zc]],"MultisigSetTimeLockInstructionArgs");const Yc=new i.BeetArgsStruct([["authority",F.publicKey],["multisigCreationFee",i.u64],["treasury",F.publicKey]],"ProgramConfigInitArgs");new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Yc]],"ProgramConfigInitInstructionArgs");const Xc=new i.BeetArgsStruct([["newAuthority",F.publicKey]],"ProgramConfigSetAuthorityArgs");new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Xc]],"ProgramConfigSetAuthorityInstructionArgs");const Jc=new i.BeetArgsStruct([["newMultisigCreationFee",i.u64]],"ProgramConfigSetMultisigCreationFeeArgs");new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Jc]],"ProgramConfigSetMultisigCreationFeeInstructionArgs");const Qc=new i.BeetArgsStruct([["newTreasury",F.publicKey]],"ProgramConfigSetTreasuryArgs");new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Qc]],"ProgramConfigSetTreasuryInstructionArgs");new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)]],"ProposalActivateInstructionArgs");const Kr=new i.FixableBeetArgsStruct([["memo",i.coption(i.utf8String)]],"ProposalVoteArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Kr]],"ProposalApproveInstructionArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Kr]],"ProposalCancelInstructionArgs");const ea=new i.BeetArgsStruct([["transactionIndex",i.u64],["draft",i.bool]],"ProposalCreateArgs");new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",ea]],"ProposalCreateInstructionArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",Kr]],"ProposalRejectInstructionArgs");const ta=new i.FixableBeetArgsStruct([["amount",i.u64],["decimals",i.u8],["memo",i.coption(i.utf8String)]],"SpendingLimitUseArgs");new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",ta]],"SpendingLimitUseInstructionArgs");new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)]],"VaultBatchTransactionAccountCloseInstructionArgs");new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)]],"VaultTransactionAccountsCloseInstructionArgs");const na=new i.FixableBeetArgsStruct([["vaultIndex",i.u8],["ephemeralSigners",i.u8],["transactionMessage",i.bytes],["memo",i.coption(i.utf8String)]],"VaultTransactionCreateArgs"),ra=new i.FixableBeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)],["args",na]],"VaultTransactionCreateInstructionArgs"),sa=[48,250,78,168,208,226,218,211];function ba(n,e,t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){const[r]=ra.serialize({instructionDiscriminator:sa,...e}),s=[{pubkey:n.multisig,isWritable:!0,isSigner:!1},{pubkey:n.transaction,isWritable:!0,isSigner:!1},{pubkey:n.creator,isWritable:!1,isSigner:!0},{pubkey:n.rentPayer,isWritable:!0,isSigner:!0},{pubkey:n.systemProgram??Ft.programId,isWritable:!1,isSigner:!1}];if(n.anchorRemainingAccounts!=null)for(const a of n.anchorRemainingAccounts)s.push(a);return new ze({programId:t,keys:s,data:r})}new i.BeetArgsStruct([["instructionDiscriminator",i.uniformFixedSizeArray(i.u8,8)]],"VaultTransactionExecuteInstructionArgs");var mr;(function(n){n[n.Approve=0]="Approve",n[n.Reject=1]="Reject",n[n.Cancel=2]="Cancel"})(mr||(mr={}));i.fixedScalarEnum(mr);const oa="SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf",Ys=new R(oa);oo.initCusper(Pc);var ia=function(n,e,t,r,s,o,a,u){if(!n){var c;if(e===void 0)c=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var d=[t,r,s,o,a,u],l=0;c=new Error(e.replace(/%s/g,function(){return d[l++]})),c.name="Invariant Violation"}throw c.framesToPop=1,c}},an=ia;function fs(n,e,t){const r=e.length,s=r===0?"<EMPTY>":e[0].description;return{write:function(o,a,u){an(u.length===r,`array length ${u.length} should match len ${r}`),n.write(o,a,r);let c=a+n.byteSize;for(let d=0;d<r;d++){const l=e[d];l.write(o,c,u[d]),c+=l.byteSize}},read:function(o,a){const u=n.read(o,a);an(u===r,"invalid byte size");let c=a+n.byteSize;const d=new Array(r);for(let l=0;l<r;l++){const f=e[l];d[l]=f.read(o,c),c+=f.byteSize}return d},byteSize:n.byteSize+t,length:r,description:`Array<${s}>(${r})[ ${n.byteSize} + ${t} ]`}}function ft(n,e){return{toFixedFromData(t,r){const s=n.read(t,r),o=r+n.byteSize;let a=o;const u=new Array(s);for(let c=0;c<s;c++){const d=i.fixBeetFromData(e,t,a);u[c]=d,a+=d.byteSize}return fs(n,u,a-o)},toFixedFromValue(t){an(Array.isArray(t),`${t} should be an array`);let r=0;const s=new Array(t.length);for(let o=0;o<t.length;o++){const a=i.fixBeetFromValue(e,t[o]);s[o]=a,r+=a.byteSize}return fs(n,s,r)},description:"smallArray"}}const ca=new i.FixableBeetArgsStruct([["programIdIndex",i.u8],["accountIndexes",ft(i.u8,i.u8)],["data",ft(i.u16,i.u8)]],"CompiledMsInstruction"),aa=new i.FixableBeetArgsStruct([["accountKey",F.publicKey],["writableIndexes",ft(i.u8,i.u8)],["readonlyIndexes",ft(i.u8,i.u8)]],"MessageAddressTableLookup"),ua=new i.FixableBeetArgsStruct([["numSigners",i.u8],["numWritableSigners",i.u8],["numWritableNonSigners",i.u8],["accountKeys",ft(i.u8,F.publicKey)],["instructions",ft(i.u8,ca)],["addressTableLookups",ft(i.u8,aa)]],"TransactionMessage");class Mr{payer;keyMetaMap;constructor(e,t){this.payer=e,this.keyMetaMap=t}static compile(e,t){const r=new Map,s=a=>{const u=a.toBase58();let c=r.get(u);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(u,c)),c},o=s(t);o.isSigner=!0,o.isWritable=!0;for(const a of e){s(a.programId).isInvoked=!1;for(const u of a.keys){const c=s(u.pubkey);c.isSigner||=u.isSigner,c.isWritable||=u.isWritable}}return new Mr(t,r)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];_t(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),r=e.filter(([,c])=>c.isSigner&&!c.isWritable),s=e.filter(([,c])=>!c.isSigner&&c.isWritable),o=e.filter(([,c])=>!c.isSigner&&!c.isWritable),a={numRequiredSignatures:t.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{_t(t.length>0,"Expected at least one writable signer key");const[c]=t[0];_t(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const u=[...t.map(([c])=>new R(c)),...r.map(([c])=>new R(c)),...s.map(([c])=>new R(c)),...o.map(([c])=>new R(c))];return[a,u]}extractTableLookup(e){const[t,r]=this.drainKeysFoundInLookupTable(e.state.addresses,a=>!a.isSigner&&!a.isInvoked&&a.isWritable),[s,o]=this.drainKeysFoundInLookupTable(e.state.addresses,a=>!a.isSigner&&!a.isInvoked&&!a.isWritable);if(!(t.length===0&&s.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:s},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(e,t){const r=new Array,s=new Array;for(const[o,a]of this.keyMetaMap.entries())if(t(a)){const u=new R(o),c=e.findIndex(d=>d.equals(u));c>=0&&(_t(c<256,"Max lookup table index exceeded"),r.push(c),s.push(u),this.keyMetaMap.delete(o))}return[r,s]}}function la({payerKey:n,recentBlockhash:e,instructions:t,addressLookupTableAccounts:r}){const s=Mr.compile(t,n),o=new Array,a={writable:[],readonly:[]},u=r||[];for(const S of u){const B=s.extractTableLookup(S);if(B!==void 0){const[b,{writable:h,readonly:g}]=B;o.push(b),a.writable.push(...h),a.readonly.push(...g)}}const[c,d]=s.getMessageComponents(),f=new Mt(d,a).compileInstructions(t);return new rn({header:c,staticAccountKeys:d,recentBlockhash:e,compiledInstructions:f,addressTableLookups:o})}function Ge(n){return new TextEncoder().encode(n)}function da(n){const e=$.Buffer.alloc(1);return i.u8.write(e,0,n),e}function fa(n){const e=$.Buffer.alloc(8);return i.u64.write(e,0,n),e}function xa({message:n,addressLookupTableAccounts:e,vaultPda:t}){const r=la({payerKey:n.payerKey,recentBlockhash:n.recentBlockhash,instructions:n.instructions,addressLookupTableAccounts:e}),[s]=ua.serialize({numSigners:r.header.numRequiredSignatures,numWritableSigners:r.header.numRequiredSignatures-r.header.numReadonlySignedAccounts,numWritableNonSigners:r.staticAccountKeys.length-r.header.numRequiredSignatures-r.header.numReadonlyUnsignedAccounts,accountKeys:r.staticAccountKeys,instructions:r.compiledInstructions.map(o=>({programIdIndex:o.programIdIndex,accountIndexes:o.accountKeyIndexes,data:Array.from(o.data)})),addressTableLookups:r.addressTableLookups});return s}const Xs=Ge("multisig");Ge("program_config");Ge("multisig");const ha=Ge("vault"),pa=Ge("transaction");Ge("proposal");Ge("batch_transaction");Ge("ephemeral_signer");Ge("spending_limit");function wa({multisigPda:n,index:e,programId:t=Ys}){return an(e>=0&&e<256,"Invalid vault index"),R.findProgramAddressSync([Xs,n.toBytes(),ha,da(e)],t)}function Sa({multisigPda:n,index:e,programId:t=Ys}){return R.findProgramAddressSync([Xs,n.toBytes(),pa,fa(e)],t)}export{st as M,Ys as P,Sa as a,ba as c,wa as g,xa as t};
