import{bX as E,dd as $t,dg as K,dh as Mt,cX as ke}from"./index.73e5dabb.js";import{a as M}from"./assert.c643555f.js";var We={},v={},h={};Object.defineProperty(h,"__esModule",{value:!0});h.isElementCollectionFixedSizeBeet=h.isFixableBeet=h.assertFixedSizeBeet=h.isFixedSizeBeet=h.BEET_TYPE_ARG_INNER=h.BEET_TYPE_ARG_LEN=h.BEET_PACKAGE=void 0;const It=M.exports;h.BEET_PACKAGE="@metaplex-foundation/beet";h.BEET_TYPE_ARG_LEN="len";h.BEET_TYPE_ARG_INNER="Beet<{innner}>";function bt(e){return Object.keys(e).includes("byteSize")}h.isFixedSizeBeet=bt;function Ot(e,t=`${e} should have been a fixed beet`){(0,It.strict)(bt(e),t)}h.assertFixedSizeBeet=Ot;function kt(e){return typeof e.toFixedFromData=="function"&&typeof e.toFixedFromValue=="function"}h.isFixableBeet=kt;function Dt(e){const t=Object.keys(e);return t.includes("length")&&t.includes("elementByteSize")&&t.includes("lenPrefixByteSize")}h.isElementCollectionFixedSizeBeet=Dt;var R={};(function(e){var t=E&&E.__importDefault||function(o){return o&&o.__esModule?o:{default:o}};Object.defineProperty(e,"__esModule",{value:!0}),e.numbersTypeMap=e.bool=e.i512=e.i256=e.i128=e.i64=e.i32=e.i16=e.i8=e.u512=e.u256=e.u128=e.u64=e.u32=e.u16=e.u8=void 0;const r=t($t.exports),n=h;e.u8={write:function(o,a,c){o.writeUInt8(c,a)},read:function(o,a){return o.readUInt8(a)},byteSize:1,description:"u8"},e.u16={write:function(o,a,c){o.writeUInt16LE(c,a)},read:function(o,a){return o.readUInt16LE(a)},byteSize:2,description:"u16"},e.u32={write:function(o,a,c){o.writeUInt32LE(c,a)},read:function(o,a){return o.readUInt32LE(a)},byteSize:4,description:"u32"};function i(o,a){return{write:function(c,d,u){const g=(r.default.isBN(u)?u:new r.default(u)).toArray("le",this.byteSize);K.Buffer.from(g).copy(c,d,0,this.byteSize)},read:function(c,d){const u=c.slice(d,d+this.byteSize);return new r.default(u,"le")},byteSize:o,description:a}}e.u64=i(8,"u64"),e.u128=i(16,"u128"),e.u256=i(32,"u256"),e.u512=i(64,"u512"),e.i8={write:function(o,a,c){o.writeInt8(c,a)},read:function(o,a){return o.readInt8(a)},byteSize:1,description:"i8"},e.i16={write:function(o,a,c){o.writeInt16LE(c,a)},read:function(o,a){return o.readInt16LE(a)},byteSize:2,description:"i16"},e.i32={write:function(o,a,c){o.writeInt32LE(c,a)},read:function(o,a){return o.readInt32LE(a)},byteSize:4,description:"i32"};function s(o,a){const c=o*8;return{write:function(d,u,l){const f=(r.default.isBN(l)?l:new r.default(l)).toTwos(c).toArray("le",this.byteSize);K.Buffer.from(f).copy(d,u,0,this.byteSize)},read:function(d,u){const l=d.slice(u,u+this.byteSize);return new r.default(l,"le").fromTwos(c)},byteSize:o,description:a}}e.i64=s(8,"i64"),e.i128=s(16,"i128"),e.i256=s(32,"i256"),e.i512=s(64,"i512"),e.bool={write:function(o,a,c){const d=c?1:0;e.u8.write(o,a,d)},read:function(o,a){return e.u8.read(o,a)===1},byteSize:1,description:"bool"},e.numbersTypeMap={u8:{beet:"u8",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"number"},u16:{beet:"u16",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"number"},u32:{beet:"u32",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"number"},i8:{beet:"i8",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"number"},i16:{beet:"i16",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"number"},i32:{beet:"i32",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"number"},bool:{beet:"bool",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"boolean"},u64:{beet:"u64",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"bignum",pack:n.BEET_PACKAGE},u128:{beet:"u128",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"bignum",pack:n.BEET_PACKAGE},u256:{beet:"u256",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"bignum",pack:n.BEET_PACKAGE},u512:{beet:"u512",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"bignum",pack:n.BEET_PACKAGE},i64:{beet:"i64",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"bignum",pack:n.BEET_PACKAGE},i128:{beet:"i128",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"bignum",pack:n.BEET_PACKAGE},i256:{beet:"i256",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"bignum",pack:n.BEET_PACKAGE},i512:{beet:"i512",isFixable:!1,sourcePack:n.BEET_PACKAGE,ts:"bignum",pack:n.BEET_PACKAGE}}})(R);var S={},he={exports:{}},oe=1e3,se=oe*60,ae=se*60,J=ae*24,Nt=J*7,Lt=J*365.25,jt=function(e,t){t=t||{};var r=typeof e;if(r==="string"&&e.length>0)return Gt(e);if(r==="number"&&isFinite(e))return t.long?Ut(e):Kt(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))};function Gt(e){if(e=String(e),!(e.length>100)){var t=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(!!t){var r=parseFloat(t[1]),n=(t[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return r*Lt;case"weeks":case"week":case"w":return r*Nt;case"days":case"day":case"d":return r*J;case"hours":case"hour":case"hrs":case"hr":case"h":return r*ae;case"minutes":case"minute":case"mins":case"min":case"m":return r*se;case"seconds":case"second":case"secs":case"sec":case"s":return r*oe;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return r;default:return}}}}function Kt(e){var t=Math.abs(e);return t>=J?Math.round(e/J)+"d":t>=ae?Math.round(e/ae)+"h":t>=se?Math.round(e/se)+"m":t>=oe?Math.round(e/oe)+"s":e+"ms"}function Ut(e){var t=Math.abs(e);return t>=J?be(e,t,J,"day"):t>=ae?be(e,t,ae,"hour"):t>=se?be(e,t,se,"minute"):t>=oe?be(e,t,oe,"second"):e+" ms"}function be(e,t,r,n){var i=t>=r*1.5;return Math.round(e/r)+" "+n+(i?"s":"")}function Rt(e){r.debug=r,r.default=r,r.coerce=c,r.disable=s,r.enable=i,r.enabled=o,r.humanize=jt,r.destroy=d,Object.keys(e).forEach(u=>{r[u]=e[u]}),r.names=[],r.skips=[],r.formatters={};function t(u){let l=0;for(let g=0;g<u.length;g++)l=(l<<5)-l+u.charCodeAt(g),l|=0;return r.colors[Math.abs(l)%r.colors.length]}r.selectColor=t;function r(u){let l,g=null,f,m;function y(...b){if(!y.enabled)return;const p=y,_=Number(new Date),B=_-(l||_);p.diff=B,p.prev=l,p.curr=_,l=_,b[0]=r.coerce(b[0]),typeof b[0]!="string"&&b.unshift("%O");let w=0;b[0]=b[0].replace(/%([a-zA-Z%])/g,(A,x)=>{if(A==="%%")return"%";w++;const W=r.formatters[x];if(typeof W=="function"){const Pt=b[w];A=W.call(p,Pt),b.splice(w,1),w--}return A}),r.formatArgs.call(p,b),(p.log||r.log).apply(p,b)}return y.namespace=u,y.useColors=r.useColors(),y.color=r.selectColor(u),y.extend=n,y.destroy=r.destroy,Object.defineProperty(y,"enabled",{enumerable:!0,configurable:!1,get:()=>g!==null?g:(f!==r.namespaces&&(f=r.namespaces,m=r.enabled(u)),m),set:b=>{g=b}}),typeof r.init=="function"&&r.init(y),y}function n(u,l){const g=r(this.namespace+(typeof l>"u"?":":l)+u);return g.log=this.log,g}function i(u){r.save(u),r.namespaces=u,r.names=[],r.skips=[];let l;const g=(typeof u=="string"?u:"").split(/[\s,]+/),f=g.length;for(l=0;l<f;l++)!g[l]||(u=g[l].replace(/\*/g,".*?"),u[0]==="-"?r.skips.push(new RegExp("^"+u.slice(1)+"$")):r.names.push(new RegExp("^"+u+"$")))}function s(){const u=[...r.names.map(a),...r.skips.map(a).map(l=>"-"+l)].join(",");return r.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let l,g;for(l=0,g=r.skips.length;l<g;l++)if(r.skips[l].test(u))return!1;for(l=0,g=r.names.length;l<g;l++)if(r.names[l].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack||u.message:u}function d(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return r.enable(r.load()),r}var Vt=Rt;(function(e,t){t.formatArgs=n,t.save=i,t.load=s,t.useColors=r,t.storage=o(),t.destroy=(()=>{let c=!1;return()=>{c||(c=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function r(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function n(c){if(c[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+c[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const d="color: "+this.color;c.splice(1,0,d,"color: inherit");let u=0,l=0;c[0].replace(/%[a-zA-Z%]/g,g=>{g!=="%%"&&(u++,g==="%c"&&(l=u))}),c.splice(l,0,d)}t.log=console.debug||console.log||(()=>{});function i(c){try{c?t.storage.setItem("debug",c):t.storage.removeItem("debug")}catch{}}function s(){let c;try{c=t.storage.getItem("debug")}catch{}return!c&&typeof K.process<"u"&&"env"in K.process&&(c={}.DEBUG),c}function o(){try{return localStorage}catch{}}e.exports=Vt(t);const{formatters:a}=e.exports;a.j=function(c){try{return JSON.stringify(c)}catch(d){return"[UnexpectedJSONParseError]: "+d.message}}})(he,he.exports);var et={white:37,black:30,blue:34,cyan:36,green:32,magenta:35,red:31,yellow:33,brightBlack:90,brightRed:91,brightGreen:92,brightYellow:93,brightBlue:94,brightMagenta:95,brightCyan:96,brightWhite:97},tt={bgBlack:40,bgRed:41,bgGreen:42,bgYellow:43,bgBlue:44,bgMagenta:45,bgCyan:46,bgWhite:47,bgBrightBlack:100,bgBrightRed:101,bgBrightGreen:102,bgBrightYellow:103,bgBrightBlue:104,bgBrightMagenta:105,bgBrightCyan:106,bgBrightWhite:107},Je={},Ze={},ge={};Object.keys(et).forEach(function(e){var t=Je[e]="\x1B["+et[e]+"m",r=Ze[e]="\x1B[39m";ge[e]=function(n){return t+n+r}});Object.keys(tt).forEach(function(e){var t=Je[e]="\x1B["+tt[e]+"m",r=Ze[e]="\x1B[49m";ge[e]=function(n){return t+n+r}});var mt=ge;ge.open=Je;ge.close=Ze;var pt=E&&E.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(S,"__esModule",{value:!0});S.UnreachableCaseError=S.stringify=S.bytes=S.beetBytes=S.logTrace=S.logDebug=S.logInfo=S.logError=void 0;const Ce=pt(he.exports),qt=pt(mt),rt=h,{brightBlack:yt}=qt.default;S.logError=(0,Ce.default)("beet:error");S.logInfo=(0,Ce.default)("beet:info");S.logDebug=(0,Ce.default)("beet:debug");S.logTrace=(0,Ce.default)("beet:trace");function Yt(e,t=!1){let r;if((0,rt.isFixableBeet)(e))r="? B";else if((0,rt.isElementCollectionFixedSizeBeet)(e)){const n=t?"length":e.length,i=e.lenPrefixByteSize;r=i>0?`${i} + (${e.elementByteSize} * ${n}) B  (${e.byteSize} B)`:`(${e.elementByteSize} * ${n}) B (${e.byteSize} B)`}else r=`${e.byteSize} B`;return yt(r)}S.beetBytes=Yt;function Wt(e){return yt(`${e} B`)}S.bytes=Wt;function Jt(e){return e.toString==="function"?e.toString():e}S.stringify=Jt;class Zt extends Error{constructor(t){super(`Unreachable case: ${t}`)}}S.UnreachableCaseError=Zt;var D={};Object.defineProperty(D,"__esModule",{value:!0});D.fixBeetFromValue=D.fixBeetFromData=void 0;const Ee=h,ht=S;function Ht(e,t,r){if((0,Ee.isFixedSizeBeet)(e))return e;if((0,Ee.isFixableBeet)(e))return e.toFixedFromData(t,r);throw new ht.UnreachableCaseError(e)}D.fixBeetFromData=Ht;function Xt(e,t){if((0,Ee.isFixedSizeBeet)(e))return e;if((0,Ee.isFixableBeet)(e))return e.toFixedFromValue(t);throw new ht.UnreachableCaseError(e)}D.fixBeetFromValue=Xt;Object.defineProperty(v,"__esModule",{value:!0});v.collectionsTypeMap=v.uint8Array=v.fixedSizeUint8Array=v.fixedSizeBuffer=v.array=v.fixedSizeArray=v.uniformFixedSizeArray=void 0;const re=h,Z=M.exports,V=R,ne=h,Et=S,nt=D;function Qt(e,t,r=!1){const n=e.byteSize*t,i=r?4+n:n;return{write:function(s,o,a){Z.strict.equal(a.length,t,`array length ${a.length} should match len ${t}`),r&&(V.u32.write(s,o,t),o+=4);for(let c=0;c<t;c++)e.write(s,o+c*e.byteSize,a[c])},read:function(s,o){if(r){const c=V.u32.read(s,o);Z.strict.equal(c,t,"invalid byte size"),o+=4}const a=new Array(t);for(let c=0;c<t;c++)a[c]=e.read(s,o+c*e.byteSize);return a},byteSize:i,length:t,elementByteSize:e.byteSize,lenPrefixByteSize:4,description:`Array<${e.description}>(${t})`}}v.uniformFixedSizeArray=Qt;function De(e,t){const r=e.length,n=r===0?"<EMPTY>":e[0].description;return{write:function(i,s,o){Z.strict.equal(o.length,r,`array length ${o.length} should match len ${r}`),V.u32.write(i,s,r);let a=s+4;for(let c=0;c<r;c++){const d=e[c];d.write(i,a,o[c]),a+=d.byteSize}},read:function(i,s){const o=V.u32.read(i,s);Z.strict.equal(o,r,"invalid byte size");let a=s+4;const c=new Array(r);for(let d=0;d<r;d++){const u=e[d];c[d]=u.read(i,a),a+=u.byteSize}return c},byteSize:4+t,length:r,description:`Array<${n}>(${r})[ 4 + ${t} ]`}}v.fixedSizeArray=De;function er(e){return{toFixedFromData(t,r){const n=V.u32.read(t,r);(0,Et.logTrace)(`${this.description}[${n}]`);const i=r+4;let s=i;const o=new Array(n);for(let a=0;a<n;a++){const c=(0,nt.fixBeetFromData)(e,t,s);o[a]=c,s+=c.byteSize}return De(o,s-i)},toFixedFromValue(t){(0,Z.strict)(Array.isArray(t),`${t} should be an array`);let r=0;const n=new Array(t.length);for(let i=0;i<t.length;i++){const s=(0,nt.fixBeetFromValue)(e,t[i]);n[i]=s,r+=s.byteSize}return De(n,r)},description:"array"}}v.array=er;function St(e){return{write:function(t,r,n){n.copy(t,r,0,e)},read:function(t,r){return t.slice(r,r+e)},byteSize:e,description:`Buffer(${e})`}}v.fixedSizeBuffer=St;function Ne(e,t=!1){const r=St(e),n=t?e+4:e;return{write:function(i,s,o){Z.strict.equal(o.byteLength,e,`Uint8Array length ${o.byteLength} should match len ${e}`),t&&(V.u32.write(i,s,e),s+=4);const a=K.Buffer.from(o);r.write(i,s,a)},read:function(i,s){if(t){const a=V.u32.read(i,s);Z.strict.equal(a,e,"invalid byte size"),s+=4}const o=r.read(i,s);return Uint8Array.from(o)},byteSize:n,description:`Uint8Array(${e})`}}v.fixedSizeUint8Array=Ne;v.uint8Array={toFixedFromData(e,t){const r=V.u32.read(e,t);return(0,Et.logTrace)(`${this.description}[${r}]`),Ne(r,!0)},toFixedFromValue(e){const t=e.byteLength;return Ne(t,!0)},description:"Uint8Array"};v.collectionsTypeMap={Array:{beet:"array",isFixable:!0,sourcePack:ne.BEET_PACKAGE,ts:"Array",arg:re.BEET_TYPE_ARG_LEN},FixedSizeArray:{beet:"fixedSizeArray",isFixable:!1,sourcePack:ne.BEET_PACKAGE,ts:"Array",arg:re.BEET_TYPE_ARG_LEN},UniformFixedSizeArray:{beet:"uniformFixedSizeArray",isFixable:!1,sourcePack:ne.BEET_PACKAGE,ts:"Array",arg:re.BEET_TYPE_ARG_LEN},Buffer:{beet:"fixedSizeBuffer",isFixable:!1,sourcePack:ne.BEET_PACKAGE,ts:"Buffer",arg:re.BEET_TYPE_ARG_LEN},FixedSizeUint8Array:{beet:"fixedSizeUint8Array",isFixable:!1,sourcePack:ne.BEET_PACKAGE,ts:"Uint8Array",arg:re.BEET_TYPE_ARG_LEN},Uint8Array:{beet:"uint8Array",isFixable:!0,sourcePack:ne.BEET_PACKAGE,ts:"Uint8Array",arg:re.BEET_TYPE_ARG_LEN}};var z={};Object.defineProperty(z,"__esModule",{value:!0});z.compositesTypeMap=z.coption=z.coptionSome=z.coptionNone=z.isNoneBuffer=z.isSomeBuffer=void 0;const le=M.exports,Le=h,it=h,_t=S,ot=D,Ct=0,vt=1;function He(e,t){return e[t]===vt}z.isSomeBuffer=He;function Xe(e,t){return e[t]===Ct}z.isNoneBuffer=Xe;function je(e){return(0,_t.logTrace)(`coptionNone(${e})`),{write:function(t,r,n){(0,le.strict)(n==null,"coptionNone can only handle `null` values"),t[r]=Ct},read:function(t,r){return(0,le.strict)(Xe(t,r),"coptionNone can only handle `NONE` data"),null},byteSize:1,description:`COption<None(${e})>`}}z.coptionNone=je;function Ge(e){const t=1+e.byteSize,r={write:function(n,i,s){(0,Le.assertFixedSizeBeet)(e,`coption inner type ${e.description} needs to be fixed before calling write`),(0,le.strict)(s!=null,"coptionSome cannot handle `null` values"),n[i]=vt,e.write(n,i+1,s)},read:function(n,i){return(0,Le.assertFixedSizeBeet)(e,`coption inner type ${e.description} needs to be fixed before calling read`),(0,le.strict)(He(n,i),"coptionSome can only handle `SOME` data"),e.read(n,i+1)},description:`COption<${e.description}>[1 + ${e.byteSize}]`,byteSize:t,inner:e};return(0,_t.logTrace)(r.description),r}z.coptionSome=Ge;function tr(e){return{toFixedFromData(t,r){if(He(t,r)){const n=(0,ot.fixBeetFromData)(e,t,r+1);return Ge(n)}else return(0,le.strict)(Xe(t,r),`Expected ${t} to hold a COption`),je(e.description)},toFixedFromValue(t){return t==null?je(e.description):Ge((0,ot.fixBeetFromValue)(e,t))},description:`COption<${e.description}>`}}z.coption=tr;z.compositesTypeMap={option:{beet:"coption",isFixable:!0,sourcePack:it.BEET_PACKAGE,ts:"COption<Inner>",arg:Le.BEET_TYPE_ARG_INNER,pack:it.BEET_PACKAGE}};var Ke={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.stringTypeMap=e.utf8String=e.fixedSizeUtf8String=void 0;const t=h,r=M.exports,n=R,i=S,s=o=>({write:function(a,c,d){const u=K.Buffer.from(d,"utf8");r.strict.equal(u.byteLength,o,`${d} has invalid byte size`),n.u32.write(a,c,o),u.copy(a,c+4,0,o)},read:function(a,c){const d=n.u32.read(a,c);return r.strict.equal(d,o,"invalid byte size"),a.slice(c+4,c+4+o).toString("utf8")},elementByteSize:1,length:o,lenPrefixByteSize:4,byteSize:4+o,description:`Utf8String(4 + ${o})`});e.fixedSizeUtf8String=s,e.utf8String={toFixedFromData(o,a){const c=n.u32.read(o,a);return(0,i.logTrace)(`${this.description}[${c}]`),(0,e.fixedSizeUtf8String)(c)},toFixedFromValue(o){const a=K.Buffer.from(o).byteLength;return(0,e.fixedSizeUtf8String)(a)},description:"Utf8String"},e.stringTypeMap={fixedSizeString:{beet:"fixedSizeUtf8String",isFixable:!1,sourcePack:t.BEET_PACKAGE,ts:"string",arg:t.BEET_TYPE_ARG_LEN},string:{beet:"utf8String",isFixable:!0,sourcePack:t.BEET_PACKAGE,ts:"string"}}})(Ke);var P={},k={},H={};Object.defineProperty(H,"__esModule",{value:!0});H.BeetReader=H.BeetWriter=void 0;const rr=M.exports;class nr{constructor(t){this.buf=K.Buffer.alloc(t),this._offset=0}get buffer(){return this.buf}get offset(){return this._offset}maybeResize(t){this._offset+t>this.buf.length&&rr.strict.fail(`We shouldn't ever need to resize, but ${this._offset+t} > ${this.buf.length}`)}write(t,r){this.maybeResize(t.byteSize),t.write(this.buf,this._offset,r),this._offset+=t.byteSize}writeStruct(t,r){for(const[n,i]of r){const s=t[n];this.write(i,s)}}}H.BeetWriter=nr;class ir{constructor(t,r=0){this.buffer=t,this._offset=r}get offset(){return this._offset}read(t){const r=t.read(this.buffer,this._offset);return this._offset+=t.byteSize,r}readStruct(t){const r={};for(const[n,i]of t)r[n]=this.read(i);return r}}H.BeetReader=ir;Object.defineProperty(k,"__esModule",{value:!0});k.BeetArgsStruct=k.isBeetStruct=k.BeetStruct=void 0;const st=H,L=S;class q{constructor(t,r,n=q.description){if(this.fields=t,this.construct=r,this.description=n,this.byteSize=this.getByteSize(),L.logDebug.enabled){const i=t.map(([s,o])=>`${String(s)}: ${o.description} ${(0,L.beetBytes)(o)}`).join(`
  `);(0,L.logDebug)(`struct ${n} {
  ${i}
} ${(0,L.beetBytes)(this)}`)}}read(t,r){const[n]=this.deserialize(t,r);return n}write(t,r,n){const[i,s]=this.serialize(n);i.copy(t,r,0,s)}deserialize(t,r=0){L.logTrace.enabled&&((0,L.logTrace)("deserializing [%s] from %d bytes buffer",this.description,t.byteLength),(0,L.logTrace)(t),(0,L.logTrace)(t.toJSON().data));const n=new st.BeetReader(t,r),i=n.readStruct(this.fields);return[this.construct(i),n.offset]}serialize(t,r=this.byteSize){(0,L.logTrace)("serializing [%s] %o to %d bytes buffer",this.description,t,r);const n=new st.BeetWriter(r);return n.writeStruct(t,this.fields),[n.buffer,n.offset]}getByteSize(){return this.fields.reduce((t,[r,n])=>t+n.byteSize,0)}get type(){return q.TYPE}}k.BeetStruct=q;q.description="BeetStruct";q.TYPE="BeetStruct";function or(e){return e.type===q.TYPE}k.isBeetStruct=or;class ve extends q{constructor(t,r=ve.description){super(t,n=>n,r)}}k.BeetArgsStruct=ve;ve.description="BeetArgsStruct";var j={},sr=E&&E.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(j,"__esModule",{value:!0});j.FixableBeetArgsStruct=j.isFixableBeetStruct=j.FixableBeetStruct=void 0;const at=D,me=k,ar=h,cr=M.exports,Pe=S,ur=sr(mt),{brightBlack:dr}=ur.default;class I{constructor(t,r,n=I.description){this.fields=t,this.construct=r,this.description=n;let i=0;if(Pe.logDebug.enabled){const s=t.map(([a,c])=>((0,ar.isFixedSizeBeet)(c)&&(i+=c.byteSize),`${a}: ${c.description} ${(0,Pe.beetBytes)(c)}`)).join(`
  `),o=`> ${i} B`;(0,Pe.logDebug)(`struct ${n} {
  ${s}
} ${dr(o)}`)}}deserialize(t,r=0){return this.toFixedFromData(t,r).deserialize(t,r)}serialize(t,r){return this.toFixedFromValue(t).serialize(t,r)}toFixedFromData(t,r){let n=r;const i=new Array(this.fields.length);for(let s=0;s<this.fields.length;s++){const[o,a]=this.fields[s],c=(0,at.fixBeetFromData)(a,t,n);i[s]=[o,c],n+=c.byteSize}return this.description!==I.description?new me.BeetStruct(i,this.construct,this.description):new me.BeetStruct(i,this.construct)}toFixedFromValue(t){const r=Object.keys(t),n=new Array(this.fields.length);for(let i=0;i<this.fields.length;i++){const[s,o]=this.fields[i];(0,cr.strict)(r.includes(s),`Value with keys [ ${r} ] should include struct key '${s}' but doesn't.`);const a=t[s],c=(0,at.fixBeetFromValue)(o,a);n[i]=[s,c]}return this.description!==I.description?new me.BeetStruct(n,this.construct,this.description):new me.BeetStruct(n,this.construct)}get type(){return I.TYPE}}j.FixableBeetStruct=I;I.description="FixableBeetStruct";I.TYPE="FixableBeetStruct";function lr(e){return e.type===I.TYPE}j.isFixableBeetStruct=lr;class Fe extends I{constructor(t,r=Fe.description){super(t,n=>n,r)}}j.FixableBeetArgsStruct=Fe;Fe.description="FixableBeetArgsStruct";var Y={};Object.defineProperty(Y,"__esModule",{value:!0});Y.unitTypeMap=Y.unit=void 0;const fr=h;Y.unit={write:function(e,t,r){},read:function(e,t){},byteSize:0,description:"unit"};Y.unitTypeMap={unit:{beet:"unit",isFixable:!1,sourcePack:fr.BEET_PACKAGE,ts:"void"}};Object.defineProperty(P,"__esModule",{value:!0});P.enumsTypeMap=P.dataEnum=P.uniformDataEnum=P.fixedScalarEnum=void 0;const U=h,$=R,ie=M.exports,gr=k,br=j,mr=Y;function ct(e,t){return t?`${e}`:e}function pr(e){const t=Object.keys(e);return{write(r,n,i){const s=typeof i=="number",o=ct(i,s);if(t.includes(o)||ie.strict.fail(`${i} should be a variant of the provided enum type, i.e. [ ${Object.values(e).join(", ")} ], but isn't`),s)$.u8.write(r,n,i);else{const a=e[o];$.u8.write(r,n,a)}},read(r,n){const i=$.u8.read(r,n),s=typeof i=="number",o=ct(i,s);return t.includes(o)||ie.strict.fail(`${i} should be a of a variant of the provided enum type, i.e. [ ${Object.values(e).join(", ")} ], but isn't`),s?i:e[o]},byteSize:$.u8.byteSize,description:"Enum"}}P.fixedScalarEnum=pr;function yr(e){return{write:function(t,r,n){$.u8.write(t,r,n.kind),e.write(t,r+1,n.data)},read:function(t,r){const n=$.u8.read(t,r),i=e.read(t,r+1);return{kind:n,data:i}},byteSize:1+e.byteSize,description:`UniformDataEnum<${e.description}>`}}P.uniformDataEnum=yr;function ut(e,t,r){return{write(n,i,s){$.u8.write(n,i,t),e.write(n,i+$.u8.byteSize,s)},read(n,i){const s=e.read(n,i+$.u8.byteSize);return{__kind:r,...s}},byteSize:e.byteSize+$.u8.byteSize,description:`EnumData<${e.description}>`}}function hr(e){for(const[t,r]of e)(0,ie.strict)((0,gr.isBeetStruct)(r)||(0,br.isFixableBeetStruct)(r)||r===mr.unit,"dataEnum: variants must be a data beet struct or a scalar unit");return{toFixedFromData(t,r){const n=$.u8.read(t,r),i=e[n];(0,ie.strict)(i!=null,`Discriminant ${n} out of range for ${e.length} variants`);const[s,o]=i,a=(0,U.isFixedSizeBeet)(o)?o:o.toFixedFromData(t,r+1);return ut(a,n,s)},toFixedFromValue(t){if(t.__kind==null){const d=Object.keys(t).join(", "),u=e.map(([l])=>l).join(", ");ie.strict.fail(`Value with fields [ ${d} ] is missing __kind, which needs to be set to one of [ ${u} ]`)}const r=e.findIndex(([d])=>d===t.__kind);if(r<0){const d=e.map(([u])=>u).join(", ");ie.strict.fail(`${t.__kind} is not a valid kind, needs to be one of [ ${d} ]`)}const n=e[r],{__kind:i,...s}=t,[o,a]=n,c=(0,U.isFixedSizeBeet)(a)?a:a.toFixedFromValue(s);return ut(c,r,o)},description:`DataEnum<${e.length} variants>`}}P.dataEnum=hr;P.enumsTypeMap={fixedScalarEnum:{beet:"fixedScalarEnum",isFixable:!1,sourcePack:U.BEET_PACKAGE,ts:"<TypeName>",arg:U.BEET_TYPE_ARG_INNER,pack:U.BEET_PACKAGE},dataEnum:{beet:"dataEnum",isFixable:!1,sourcePack:U.BEET_PACKAGE,ts:"DataEnum<Kind, Inner>",arg:U.BEET_TYPE_ARG_INNER,pack:U.BEET_PACKAGE}};var X={};Object.defineProperty(X,"__esModule",{value:!0});X.aliasesTypeMap=X.bytes=void 0;const Ft=v;X.bytes=Ft.uint8Array;X.aliasesTypeMap={bytes:Ft.collectionsTypeMap.Uint8Array};var G={};Object.defineProperty(G,"__esModule",{value:!0});G.tuplesTypeMap=G.tuple=G.fixedSizeTuple=void 0;const dt=h,Ue=M.exports,lt=D;function Re(e){const t=e.length,r=e.map(s=>s.description),n=e.map(s=>s.byteSize),i=n.reduce((s,o)=>s+o,0);return{write:function(s,o,a){Ue.strict.equal(a.length,t,`tuple value element size ${a.length} should match len ${t}`);let c=o;for(let d=0;d<t;d++){const u=a[d],l=e[d];l.write(s,c,u),c+=l.byteSize}},read:function(s,o){const a=[];let c=o;for(let d=0;d<t;d++){const u=e[d];a[d]=u.read(s,c),c+=u.byteSize}return a},byteSize:i,length:t,description:`FixedSizeTuple<${r.join(",")}>[ ${n.join(", ")} ]`}}G.fixedSizeTuple=Re;function Er(e){const t=e.length,r=e.map(n=>n.description);return{toFixedFromData(n,i){let s=i;const o=new Array(t);for(let a=0;a<t;a++){const c=(0,lt.fixBeetFromData)(e[a],n,s);o[a]=c,s+=c.byteSize}return Re(o)},toFixedFromValue(n){(0,Ue.strict)(Array.isArray(n),`${n} should be an array of tuple values`),Ue.strict.equal(n.length,t,`There should be ${t} tuple values, but there are ${n.length}`);const i=new Array(t);for(let s=0;s<n.length;s++){const o=(0,lt.fixBeetFromValue)(e[s],n[s]);i[s]=o}return Re(i)},description:`Tuple<${r.join(",")}>`}}G.tuple=Er;G.tuplesTypeMap={Tuple:{beet:"tuple",isFixable:!0,sourcePack:dt.BEET_PACKAGE,ts:"[__tuple_elements__]"},FixedSizeTuple:{beet:"fixedSizeTuple",isFixable:!1,sourcePack:dt.BEET_PACKAGE,ts:"[__tuple_elements__]"}};var Q={};Object.defineProperty(Q,"__esModule",{value:!0});Q.mapsTypeMap=Q.map=void 0;const fe=h,Ve=R,Sr=S,$e=M.exports;function pe(e,t,r,n){const i=(0,fe.isFixedSizeBeet)(e),s=(0,fe.isFixedSizeBeet)(t);function o(){if(i&&s){const d=e.byteSize+t.byteSize;return{elementByteSize:d,byteSize:4+n*d}}else if(i){let d=0;for(const[l,g]of r.values())d+=g.byteSize;return{elementByteSize:e.byteSize+Math.ceil(d/n),byteSize:4+e.byteSize*n+d}}else if(s){let d=0;for(const[l,g]of r.values())d+=l.byteSize;return{elementByteSize:Math.ceil(d/n)+t.byteSize,byteSize:4+d+t.byteSize*n}}else{let d=0,u=0;for(const[g,f]of r.values())d+=g.byteSize,u+=f.byteSize;return{elementByteSize:Math.ceil(d/n+u/n),byteSize:4+d+u}}}const{elementByteSize:a,byteSize:c}=o();return{write:function(d,u,l){let g=u+4,f=0;for(const[m,y]of l.entries()){let b=i?e:null,p=s?t:null;if(b==null||p==null){const _=r.get(m);(0,$e.strict)(_!=null,`Should be able to find beet els for ${(0,Sr.stringify)(m)}, but could not`),b??(b=_[0]),p??(p=_[1])}b.write(d,g,m),g+=b.byteSize,p.write(d,g,y),g+=p.byteSize,f++}Ve.u32.write(d,u,f),$e.strict.equal(f,n,`Expected map to have size ${n}, but has ${f}.`)},read:function(d,u){const l=Ve.u32.read(d,u);$e.strict.equal(l,n,`Expected map to have size ${n}, but has ${l}.`);let g=u+4;const f=new Map;for(let m=0;m<l;m++){const y=i?e:e.toFixedFromData(d,g),b=y.read(d,g);g+=y.byteSize;const p=s?t:t.toFixedFromData(d,g),_=p.read(d,g);g+=p.byteSize,f.set(b,_)}return f},elementByteSize:a,byteSize:c,length:n,lenPrefixByteSize:4,description:`Map<${e.description}, ${t.description}>`}}function _r(e,t){const r=(0,fe.isFixedSizeBeet)(e),n=(0,fe.isFixedSizeBeet)(t);return{toFixedFromData(i,s){const o=Ve.u32.read(i,s);let a=s+4;if(r&&n)return pe(e,t,new Map,o);const c=new Map;for(let d=0;d<o;d++){const u=r?e:e.toFixedFromData(i,a),l=u.read(i,a);a+=u.byteSize;const g=n?t:t.toFixedFromData(i,a);a+=g.byteSize,c.set(l,[u,g])}return pe(e,t,c,o)},toFixedFromValue(i){const s=i.size;if(r&&n)return pe(e,t,new Map,s);const o=new Map;for(const[a,c]of i){const d=r?e:e.toFixedFromValue(a),u=n?t:t.toFixedFromValue(c);o.set(a,[d,u])}return pe(e,t,o,s)},description:`FixableMap<${e.description}, ${t.description}>`}}Q.map=_r;Q.mapsTypeMap={Map:{beet:"map",isFixable:!0,sourcePack:fe.BEET_PACKAGE,ts:"Map"}};var ee={};Object.defineProperty(ee,"__esModule",{value:!0});ee.setsTypeMap=ee.set=void 0;const Qe=h,qe=R,Cr=S,Me=M.exports;function ye(e,t,r){const n=(0,Qe.isFixedSizeBeet)(e);function i(){if(n){const a=e.byteSize;return{elementByteSize:a,byteSize:4+r*a}}else{let a=0;for(const d of t.values())a+=d.byteSize;return{elementByteSize:Math.ceil(a/r),byteSize:4+a}}}const{elementByteSize:s,byteSize:o}=i();return{write:function(a,c,d){let u=c+4,l=0;for(const g of d.keys()){let f=n?e:null;if(f==null){const m=t.get(g);(0,Me.strict)(m!=null,`Should be able to find beet el for ${(0,Cr.stringify)(g)}, but could not`),f??(f=m)}f.write(a,u,g),u+=f.byteSize,l++}qe.u32.write(a,c,l),Me.strict.equal(l,r,`Expected set to have size ${r}, but has ${l}.`)},read:function(a,c){const d=qe.u32.read(a,c);Me.strict.equal(d,r,`Expected set to have size ${r}, but has ${d}.`);let u=c+4;const l=new Set;for(let g=0;g<d;g++){const f=n?e:e.toFixedFromData(a,u),m=f.read(a,u);u+=f.byteSize,l.add(m)}return l},elementByteSize:s,byteSize:o,length:r,lenPrefixByteSize:4,description:`Set<${e.description}>`}}function vr(e){const t=(0,Qe.isFixedSizeBeet)(e);return{toFixedFromData(r,n){const i=qe.u32.read(r,n);let s=n+4;if(t)return ye(e,new Map,i);const o=new Map;for(let a=0;a<i;a++){const c=t?e:e.toFixedFromData(r,s),d=c.read(r,s);s+=c.byteSize,o.set(d,c)}return ye(e,o,i)},toFixedFromValue(r){const n=r.size;if(t)return ye(e,new Map,n);const i=new Map;for(const s of r){const o=t?e:e.toFixedFromValue(s);i.set(s,o)}return ye(e,i,n)},description:`FixableSet<${e.description}>`}}ee.set=vr;ee.setsTypeMap={Set:{beet:"set",isFixable:!0,sourcePack:Qe.BEET_PACKAGE,ts:"Set"}};(function(e){var t=E&&E.__createBinding||(Object.create?function(f,m,y,b){b===void 0&&(b=y);var p=Object.getOwnPropertyDescriptor(m,y);(!p||("get"in p?!m.__esModule:p.writable||p.configurable))&&(p={enumerable:!0,get:function(){return m[y]}}),Object.defineProperty(f,b,p)}:function(f,m,y,b){b===void 0&&(b=y),f[b]=m[y]}),r=E&&E.__exportStar||function(f,m){for(var y in f)y!=="default"&&!Object.prototype.hasOwnProperty.call(m,y)&&t(m,f,y)};Object.defineProperty(e,"__esModule",{value:!0}),e.supportedTypeMap=void 0;const n=v,i=z,s=R,o=Ke,a=P,c=X,d=G,u=Q,l=Y,g=ee;r(X,e),r(v,e),r(z,e),r(P,e),r(Q,e),r(R,e),r(ee,e),r(Ke,e),r(G,e),r(Y,e),r(D,e),r(H,e),r(k,e),r(j,e),r(h,e),e.supportedTypeMap={...n.collectionsTypeMap,...o.stringTypeMap,...i.compositesTypeMap,...a.enumsTypeMap,...s.numbersTypeMap,...c.aliasesTypeMap,...d.tuplesTypeMap,...u.mapsTypeMap,...g.setsTypeMap,...l.unitTypeMap}})(We);var Fr={},te={};Object.defineProperty(te,"__esModule",{value:!0});te.keysTypeMap=te.publicKey=void 0;const wr=Mt,Ar=We,zr="@metaplex-foundation/beet-solana",Br="@solana/web3.js",Ie=(0,Ar.fixedSizeUint8Array)(32);te.publicKey={write:function(e,t,r){const n=r.toBytes();Ie.write(e,t,n)},read:function(e,t){const r=Ie.read(e,t);return new wr.PublicKey(r)},byteSize:Ie.byteSize,description:"PublicKey"};te.keysTypeMap={publicKey:{beet:"publicKey",isFixable:!1,sourcePack:zr,ts:"PublicKey",pack:Br}};var we={},O={},Tr=E&&E.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(O,"__esModule",{value:!0});O.logTrace=O.logDebug=O.logInfo=O.logError=void 0;const Ae=Tr(he.exports);O.logError=(0,Ae.default)("beet:error");O.logInfo=(0,Ae.default)("beet:info");O.logDebug=(0,Ae.default)("beet:debug");O.logTrace=(0,Ae.default)("beet:trace");var ze={};function xr(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<e.length;n++){var i=e.charAt(n),s=i.charCodeAt(0);if(t[s]!==255)throw new TypeError(i+" is ambiguous");t[s]=n}var o=e.length,a=e.charAt(0),c=Math.log(o)/Math.log(256),d=Math.log(256)/Math.log(o);function u(f){if(f instanceof Uint8Array||(ArrayBuffer.isView(f)?f=new Uint8Array(f.buffer,f.byteOffset,f.byteLength):Array.isArray(f)&&(f=Uint8Array.from(f))),!(f instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(f.length===0)return"";for(var m=0,y=0,b=0,p=f.length;b!==p&&f[b]===0;)b++,m++;for(var _=(p-b)*d+1>>>0,B=new Uint8Array(_);b!==p;){for(var w=f[b],N=0,A=_-1;(w!==0||N<y)&&A!==-1;A--,N++)w+=256*B[A]>>>0,B[A]=w%o>>>0,w=w/o>>>0;if(w!==0)throw new Error("Non-zero carry");y=N,b++}for(var x=_-y;x!==_&&B[x]===0;)x++;for(var W=a.repeat(m);x<_;++x)W+=e.charAt(B[x]);return W}function l(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return new Uint8Array;for(var m=0,y=0,b=0;f[m]===a;)y++,m++;for(var p=(f.length-m)*c+1>>>0,_=new Uint8Array(p);f[m];){var B=t[f.charCodeAt(m)];if(B===255)return;for(var w=0,N=p-1;(B!==0||w<b)&&N!==-1;N--,w++)B+=o*_[N]>>>0,_[N]=B%256>>>0,B=B/256>>>0;if(B!==0)throw new Error("Non-zero carry");b=w,m++}for(var A=p-b;A!==p&&_[A]===0;)A++;for(var x=new Uint8Array(y+(p-A)),W=y;A!==p;)x[W++]=_[A++];return x}function g(f){var m=l(f);if(m)return m;throw new Error("Non-base"+o+" character")}return{encode:u,decodeUnsafe:l,decode:g}}var Pr=xr;const $r=Pr,Mr="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";var Ir=$r(Mr),Or=E&&E.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(ze,"__esModule",{value:!0});ze.encodeFixedBeet=void 0;const kr=Or(Ir);function Dr(e,t){const r=K.Buffer.alloc(e.byteSize);return e.write(r,0,t),kr.default.encode(r)}ze.encodeFixedBeet=Dr;Object.defineProperty(we,"__esModule",{value:!0});we.GpaBuilder=void 0;const Oe=We,de=M.exports,Nr=O,ft=ze;class Se{constructor(t,r,n){this.programId=t,this.beets=r,this.accountSize=n,this.config={}}_addFilter(t){return this.config.filters==null&&(this.config.filters=[]),this.config.filters.push(t),this}_addInnerFilter(t,r,n){(0,Nr.logTrace)(`gpa.addInnerFilter: ${t}.${r}`);const i=this.beets.get(t);(0,de.strict)(i!=null,"Outer filter key needs to be an existing field name");const s=i.beet;let o=i.offset;const a=(0,Oe.isFixedSizeBeet)(s)?s:s.toFixedFromValue(n);let c;for(const[u,l]of a.fields){if(u===r){c=l;break}o+=l.byteSize}(0,de.strict)(c!=null,`${r} is not a field of the ${t} struct`);const d=(0,ft.encodeFixedBeet)(c,n);return this._addFilter({memcmp:{offset:o,bytes:d}}),this}addInnerFilter(t,r){const n=t.split(".");de.strict.equal(n.length,2,"inner filters can go only one level deep, i.e. 'outer.inner' is ok, but 'outer.inner.deep' is not");const[i,s]=n;return this._addInnerFilter(i,s,r)}addFilter(t,r){const n=this.beets.get(t);(0,de.strict)(n!=null,"Filter key needs to be an existing field name");const i=(0,Oe.isFixedSizeBeet)(n.beet)?n.beet:n.beet.toFixedFromValue(r),s=(0,ft.encodeFixedBeet)(i,r);return this._addFilter({memcmp:{offset:n.offset,bytes:s}}),this}dataSize(t){return t=t??this.accountSize,(0,de.strict)(t!=null,"for accounts of dynamic size the dataSize arg needs to be provided"),this._addFilter({dataSize:t})}run(t){return t.getProgramAccounts(this.programId,this.config)}static fromBeetFields(t,r){const n=new Map;let i=0,s=!1;for(const[a,c]of r){if(n.set(a,{beet:c,offset:i}),!(0,Oe.isFixedSizeBeet)(c)){s=!0;break}i+=c.byteSize}const o=s?void 0:i;return new Se(t,n,o)}static fromStruct(t,r){return Se.fromBeetFields(t,r.fields)}}we.GpaBuilder=Se;(function(e){var t=E&&E.__createBinding||(Object.create?function(i,s,o,a){a===void 0&&(a=o);var c=Object.getOwnPropertyDescriptor(s,o);(!c||("get"in c?!s.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return s[o]}}),Object.defineProperty(i,a,c)}:function(i,s,o,a){a===void 0&&(a=o),i[a]=s[o]}),r=E&&E.__exportStar||function(i,s){for(var o in i)o!=="default"&&!Object.prototype.hasOwnProperty.call(s,o)&&t(s,i,o)};Object.defineProperty(e,"__esModule",{value:!0}),e.supportedTypeMap=void 0;const n=te;r(te,e),r(we,e),e.supportedTypeMap=n.keysTypeMap})(Fr);var Lr={},T={},Be={};Object.defineProperty(Be,"__esModule",{value:!0});Be.errorCodeFromLogs=void 0;const jr=/Custom program error: (0x[a-f0-9]+)/i;function Gr(e){for(const t of e){const r=t.match(jr);if(r==null)continue;const n=r[1];try{return parseInt(n)}catch{}}return null}Be.errorCodeFromLogs=Gr;var wt={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.LangErrorMessage=e.LangErrorCode=void 0,e.LangErrorCode={InstructionMissing:100,InstructionFallbackNotFound:101,InstructionDidNotDeserialize:102,InstructionDidNotSerialize:103,IdlInstructionStub:1e3,IdlInstructionInvalidProgram:1001,ConstraintMut:2e3,ConstraintHasOne:2001,ConstraintSigner:2002,ConstraintRaw:2003,ConstraintOwner:2004,ConstraintRentExempt:2005,ConstraintSeeds:2006,ConstraintExecutable:2007,ConstraintState:2008,ConstraintAssociated:2009,ConstraintAssociatedInit:2010,ConstraintClose:2011,ConstraintAddress:2012,ConstraintZero:2013,ConstraintTokenMint:2014,ConstraintTokenOwner:2015,ConstraintMintMintAuthority:2016,ConstraintMintFreezeAuthority:2017,ConstraintMintDecimals:2018,ConstraintSpace:2019,AccountDiscriminatorAlreadySet:3e3,AccountDiscriminatorNotFound:3001,AccountDiscriminatorMismatch:3002,AccountDidNotDeserialize:3003,AccountDidNotSerialize:3004,AccountNotEnoughKeys:3005,AccountNotMutable:3006,AccountOwnedByWrongProgram:3007,InvalidProgramId:3008,InvalidProgramExecutable:3009,AccountNotSigner:3010,AccountNotSystemOwned:3011,AccountNotInitialized:3012,AccountNotProgramData:3013,StateInvalidAddress:4e3,Deprecated:5e3},e.LangErrorMessage=new Map([[e.LangErrorCode.InstructionMissing,"8 byte instruction identifier not provided"],[e.LangErrorCode.InstructionFallbackNotFound,"Fallback functions are not supported"],[e.LangErrorCode.InstructionDidNotDeserialize,"The program could not deserialize the given instruction"],[e.LangErrorCode.InstructionDidNotSerialize,"The program could not serialize the given instruction"],[e.LangErrorCode.IdlInstructionStub,"The program was compiled without idl instructions"],[e.LangErrorCode.IdlInstructionInvalidProgram,"The transaction was given an invalid program for the IDL instruction"],[e.LangErrorCode.ConstraintMut,"A mut constraint was violated"],[e.LangErrorCode.ConstraintHasOne,"A has_one constraint was violated"],[e.LangErrorCode.ConstraintSigner,"A signer constraint was violated"],[e.LangErrorCode.ConstraintRaw,"A raw constraint was violated"],[e.LangErrorCode.ConstraintOwner,"An owner constraint was violated"],[e.LangErrorCode.ConstraintRentExempt,"A rent exempt constraint was violated"],[e.LangErrorCode.ConstraintSeeds,"A seeds constraint was violated"],[e.LangErrorCode.ConstraintExecutable,"An executable constraint was violated"],[e.LangErrorCode.ConstraintState,"A state constraint was violated"],[e.LangErrorCode.ConstraintAssociated,"An associated constraint was violated"],[e.LangErrorCode.ConstraintAssociatedInit,"An associated init constraint was violated"],[e.LangErrorCode.ConstraintClose,"A close constraint was violated"],[e.LangErrorCode.ConstraintAddress,"An address constraint was violated"],[e.LangErrorCode.ConstraintZero,"Expected zero account discriminant"],[e.LangErrorCode.ConstraintTokenMint,"A token mint constraint was violated"],[e.LangErrorCode.ConstraintTokenOwner,"A token owner constraint was violated"],[e.LangErrorCode.ConstraintMintMintAuthority,"A mint mint authority constraint was violated"],[e.LangErrorCode.ConstraintMintFreezeAuthority,"A mint freeze authority constraint was violated"],[e.LangErrorCode.ConstraintMintDecimals,"A mint decimals constraint was violated"],[e.LangErrorCode.ConstraintSpace,"A space constraint was violated"],[e.LangErrorCode.AccountDiscriminatorAlreadySet,"The account discriminator was already set on this account"],[e.LangErrorCode.AccountDiscriminatorNotFound,"No 8 byte discriminator was found on the account"],[e.LangErrorCode.AccountDiscriminatorMismatch,"8 byte discriminator did not match what was expected"],[e.LangErrorCode.AccountDidNotDeserialize,"Failed to deserialize the account"],[e.LangErrorCode.AccountDidNotSerialize,"Failed to serialize the account"],[e.LangErrorCode.AccountNotEnoughKeys,"Not enough account keys given to the instruction"],[e.LangErrorCode.AccountNotMutable,"The given account is not mutable"],[e.LangErrorCode.AccountOwnedByWrongProgram,"The given account is owned by a different program than expected"],[e.LangErrorCode.InvalidProgramId,"Program ID was not as expected"],[e.LangErrorCode.InvalidProgramExecutable,"Program account is not executable"],[e.LangErrorCode.AccountNotSigner,"The given account did not sign"],[e.LangErrorCode.AccountNotSystemOwned,"The given account is not owned by the system program"],[e.LangErrorCode.AccountNotInitialized,"The program expected this account to be already initialized"],[e.LangErrorCode.AccountNotProgramData,"The given account is not a program data account"],[e.LangErrorCode.StateInvalidAddress,"The given state account does not have the correct address"],[e.LangErrorCode.Deprecated,"The API being used is deprecated and should no longer be used"]])})(wt);var Te={};Object.defineProperty(Te,"__esModule",{value:!0});Te.tokenLendingErrors=void 0;Te.tokenLendingErrors=new Map([[0,{code:0,message:'Failed to unpack instruction data"',name:"InstructionUnpackError"}],[1,{code:1,message:'Account is already initialized"',name:"AlreadyInitialized"}],[2,{code:2,message:'Lamport balance below rent-exempt threshold"',name:"NotRentExempt"}],[3,{code:3,message:'Market authority is invalid"',name:"InvalidMarketAuthority"}],[4,{code:4,message:'Market owner is invalid"',name:"InvalidMarketOwner"}],[5,{code:5,message:'Input account owner is not the program address"',name:"InvalidAccountOwner"}],[6,{code:6,message:'Input token account is not owned by the correct token program id"',name:"InvalidTokenOwner"}],[7,{code:7,message:'Input token account is not valid"',name:"InvalidTokenAccount"}],[8,{code:8,message:'Input token mint account is not valid"',name:"InvalidTokenMint"}],[9,{code:9,message:'Input token program account is not valid"',name:"InvalidTokenProgram"}],[10,{code:10,message:'Input amount is invalid"',name:"InvalidAmount"}],[11,{code:11,message:'Input config value is invalid"',name:"InvalidConfig"}],[12,{code:12,message:'Input account must be a signer"',name:"InvalidSigner"}],[13,{code:13,message:'Invalid account input"',name:"InvalidAccountInput"}],[14,{code:14,message:'Math operation overflow"',name:"MathOverflow"}],[15,{code:15,message:'Token initialize mint failed"',name:"TokenInitializeMintFailed"}],[16,{code:16,message:'Token initialize account failed"',name:"TokenInitializeAccountFailed"}],[17,{code:17,message:'Token transfer failed"',name:"TokenTransferFailed"}],[18,{code:18,message:'Token mint to failed"',name:"TokenMintToFailed"}],[19,{code:19,message:'Token burn failed"',name:"TokenBurnFailed"}],[20,{code:20,message:'Insufficient liquidity available"',name:"InsufficientLiquidity"}],[21,{code:21,message:'Input reserve has collateral disabled"',name:"ReserveCollateralDisabled"}],[22,{code:22,message:'Reserve state needs to be refreshed"',name:"ReserveStale"}],[23,{code:23,message:'Withdraw amount too small"',name:"WithdrawTooSmall"}],[24,{code:24,message:'Withdraw amount too large"',name:"WithdrawTooLarge"}],[25,{code:25,message:'Borrow amount too small to receive liquidity after fees"',name:"BorrowTooSmall"}],[26,{code:26,message:'Borrow amount too large for deposited collateral"',name:"BorrowTooLarge"}],[27,{code:27,message:'Repay amount too small to transfer liquidity"',name:"RepayTooSmall"}],[28,{code:28,message:'Liquidation amount too small to receive collateral"',name:"LiquidationTooSmall"}],[29,{code:29,message:'Cannot liquidate healthy obligations"',name:"ObligationHealthy"}],[30,{code:30,message:'Obligation state needs to be refreshed"',name:"ObligationStale"}],[31,{code:31,message:'Obligation reserve limit exceeded"',name:"ObligationReserveLimit"}],[32,{code:32,message:'Obligation owner is invalid"',name:"InvalidObligationOwner"}],[33,{code:33,message:'Obligation deposits are empty"',name:"ObligationDepositsEmpty"}],[34,{code:34,message:'Obligation borrows are empty"',name:"ObligationBorrowsEmpty"}],[35,{code:35,message:'Obligation deposits have zero value"',name:"ObligationDepositsZero"}],[36,{code:36,message:'Obligation borrows have zero value"',name:"ObligationBorrowsZero"}],[37,{code:37,message:'Invalid obligation collateral"',name:"InvalidObligationCollateral"}],[38,{code:38,message:'Invalid obligation liquidity"',name:"InvalidObligationLiquidity"}],[39,{code:39,message:'Obligation collateral is empty"',name:"ObligationCollateralEmpty"}],[40,{code:40,message:'Obligation liquidity is empty"',name:"ObligationLiquidityEmpty"}],[41,{code:41,message:'Interest rate is negative"',name:"NegativeInterestRate"}],[42,{code:42,message:'Input oracle config is invalid"',name:"InvalidOracleConfig"}],[43,{code:43,message:'Input flash loan receiver program account is not valid"',name:"InvalidFlashLoanReceiverProgram"}],[44,{code:44,message:'Not enough liquidity after flash loan"',name:"NotEnoughLiquidityAfterFlashLoan"}]]);var Kr=E&&E.__createBinding||(Object.create?function(e,t,r,n){n===void 0&&(n=r),Object.defineProperty(e,n,{enumerable:!0,get:function(){return t[r]}})}:function(e,t,r,n){n===void 0&&(n=r),e[n]=t[r]}),Ur=E&&E.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),Rr=E&&E.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(e!=null)for(var r in e)r!=="default"&&Object.prototype.hasOwnProperty.call(e,r)&&Kr(t,e,r);return Ur(t,e),t};Object.defineProperty(T,"__esModule",{value:!0});T.TokenLendingError=T.AnchorError=T.CustomProgramError=T.CusperUnknownError=T.initCusper=T.ErrorResolver=void 0;const Vr=Be,gt=Rr(wt),qr=Te;class At{constructor(t){this.resolveErrorFromCode=t}errorFromCode(t,r,n=!0){let i=this.resolveErrorFromCode!=null?this.resolveErrorFromCode(t):null;if(i!=null)return this.passPreparedError(i,r??this.errorFromCode);if(i=ce.fromCode(t),i!=null)return this.passPreparedError(i,r??this.errorFromCode);if(i=ue.fromCode(t),i!=null)return this.passPreparedError(i,r??this.errorFromCode);if(n)return i=new Ye(t,"CusperUnknownError","cusper does not know this error"),this.passPreparedError(i,r??this.errorFromCode)}errorFromProgramLogs(t,r=!0){const n=(0,Vr.errorCodeFromLogs)(t);return n==null?null:this.errorFromCode(n,this.errorFromProgramLogs,r)}throwError(t){const r=t.logs!=null&&this.errorFromProgramLogs(t.logs,!0)||new Ye(-1,"Error created without logs and thus without error code");throw this.passPreparedError(r,this.throwError)}passPreparedError(t,r){return t==null?null:(typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(t,r),t)}}T.ErrorResolver=At;function Yr(e){return new At(e)}T.initCusper=Yr;class Ye extends Error{constructor(t,...r){super(...r),this.code=t,this.name="CusperUnknownError"}}T.CusperUnknownError=Ye;class Wr extends Error{constructor(t,r,...n){super(...n),this.code=t,this.name=`CustomProgramError#${r}`}}T.CustomProgramError=Wr;class ce extends Error{constructor(t,r,...n){super(...n),this.code=t,this.name=`AnchorError#${r}`}static fromCode(t){const r=ce.errorMap.get(t);return r!=null?new ce(r.code,r.name,r.message):null}toString(){return`${this.name}: ${this.message}`}}T.AnchorError=ce;ce.errorMap=Object.entries(gt.LangErrorCode).reduce((e,[t,r])=>(e.set(r,{code:r,name:t,message:gt.LangErrorMessage.get(r)}),e),new Map);class ue extends Error{constructor(t,r,...n){super(...n),this.code=t,this.name=`TokenLendingError#${r}`}static fromCode(t){const r=ue.errorMap.get(t);return r!=null?new ue(r.code,r.name,r.message):null}toString(){return`${this.name}: ${this.message}`}}T.TokenLendingError=ue;ue.errorMap=qr.tokenLendingErrors;var zt={};Object.defineProperty(zt,"__esModule",{value:!0});(function(e){var t=E&&E.__createBinding||(Object.create?function(n,i,s,o){o===void 0&&(o=s),Object.defineProperty(n,o,{enumerable:!0,get:function(){return i[s]}})}:function(n,i,s,o){o===void 0&&(o=s),n[o]=i[s]}),r=E&&E.__exportStar||function(n,i){for(var s in n)s!=="default"&&!Object.prototype.hasOwnProperty.call(i,s)&&t(i,n,s)};Object.defineProperty(e,"__esModule",{value:!0}),r(T,e),r(zt,e)})(Lr);function C(e,t,r){return t=Zr(t),t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function Jr(e,t){if(typeof e!="object"||e===null)return e;var r=e[Symbol.toPrimitive];if(r!==void 0){var n=r.call(e,t||"default");if(typeof n!="object")return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(e)}function Zr(e){var t=Jr(e,"string");return typeof t=="symbol"?t:String(t)}class Hr extends Error{constructor(t,r,n,i){super(t),C(this,"name","MetaplexError"),this.source=r,this.sourceDetails=n,this.cause=i,this.message=this.message+`

Source: ${this.getFullSource()}`+(this.cause?`

Caused By: ${this.cause}`:"")+`
`}getCapitalizedSource(){return this.source==="sdk"||this.source==="rpc"?this.source.toUpperCase():this.source[0].toUpperCase()+this.source.slice(1)}getFullSource(){const t=this.getCapitalizedSource(),r=this.sourceDetails?` > ${this.sourceDetails}`:"";return t+r}toString(){return`[${this.name}] ${this.message}`}}class F extends Hr{constructor(t,r){super(t,"sdk",void 0,r),C(this,"name","SdkError")}}class nn extends F{constructor(t){const r=`No operation handler was registered for the [${t}] operation. Did you forget to register it? You may do this by using: "metaplex.operations().register(operation, operationHandler)".`;super(r),C(this,"name","OperationHandlerMissingError")}}class on extends F{constructor(t){const r=`The SDK tried to access the driver [${t}] but was not provided. Make sure the driver is registered by using the "setDriver(myDriver)" method.`;super(r),C(this,"name","DriverNotProvidedError")}}class Xr extends F{constructor(t,r){const n=`Expected currency [${r}] but got [${t}]. Ensure the provided Amount or Currency is of the expected type.`;super(n),C(this,"name","UnexpectedCurrencyError"),this.actual=t,this.expected=r}}class Qr extends F{constructor(t,r,n){const s=`The SDK tried to execute an operation${n?` [${n}]`:""} on two different currencies: ${t.symbol} and ${r.symbol}. Provide both amounts in the same currency to perform this operation.`;super(s),C(this,"name","CurrencyMismatchError"),this.left=t,this.right=r,this.operation=n}}class sn extends F{constructor(t){super("The provided JSON variable could not be parsed into a string.",t),C(this,"name","InvalidJsonVariableError")}}class an extends F{constructor(t){super("The provided string could not be parsed into a JSON variable.",t),C(this,"name","InvalidJsonStringError")}}class cn extends F{constructor(t){const r=`Trying to access the [${t}] operation as a guest. Ensure your wallet is connected using the identity driver. For instance, by using "metaplex.use(walletAdapterIdentity(wallet))" or "metaplex.use(keypairIdentity(keypair))".`;super(r),C(this,"name","OperationUnauthorizedForGuestsError")}}class un extends F{constructor(t,r,n){const i=(r?`The account of type [${r}] was not found`:"No account was found")+` at the provided address [${t.toString()}].`+(n?` ${n}`:"");super(i),C(this,"name","AccountNotFoundError")}}class dn extends F{constructor(t,r,n){const i=`The account at the provided address [${t.toString()}] is not of the expected type [${r}].`;super(i,n),C(this,"name","UnexpectedAccountError")}}class ln extends F{constructor(t,r,n){const i=`Expected variable [${t}] to be of type [Signer] but got [${r}]. `+(n??"Please check that you are providing the variable as a signer. Note that, it may be allowed to provide a non-signer variable for certain use cases but not this one.");super(i),C(this,"name","ExpectedSignerError")}}class fn extends F{constructor(t,r){const n=typeof t=="string",i=n?t:t.toString(),s=`The provided program ${n?"name":"address"} [${i}] is not recognized in the [${r}] cluster.Did you forget to register this program? If so, you may use "metaplex.programs().register(myProgram)" to fix this.`;super(s),C(this,"name","ProgramNotRecognizedError"),this.nameOrAddress=t,this.cluster=r}}class gn extends F{constructor(t,r){const n=`The input provided to the [${t}] resulted in a Transaction containing no Instructions. `+(r??"Ensure that the provided input has an effect on the operation. This typically happens when trying to update an account with the same data it already contains.");super(n),C(this,"name","NoInstructionsToSendError")}}class bn extends F{constructor(t,r){const n=`The received data could not be serialized as a [${t}].`;super(n,r),C(this,"name","FailedToSerializeDataError")}}class mn extends F{constructor(t,r){const n=`The received serialized data could not be deserialized to a [${t}].`;super(n,r),C(this,"name","FailedToDeserializeDataError")}}class pn extends F{constructor(t,r){const n=`Some parameters are missing from the provided input object. Please provide the following missing parameters [${t.join(", ")}].`+(r?` ${r}`:"");super(n),C(this,"name","MissingInputDataError")}}class yn extends F{constructor(){const t="This feature is not yet implemented. Please check back later.";super(t),C(this,"name","NotYetImplementedError")}}class hn extends F{constructor(t){const r=`A switch statement is not handling the provided case [${t}]. Check your inputs or raise an issue to have ensure all cases are handled properly.`;super(r),C(this,"name","UnreachableCaseError")}}const _e=(e,t)=>new ke(e,t),En=e=>e===null?null:_e(e),Bt={symbol:"SOL",decimals:9},xe=(e,t)=>({basisPoints:_e(e),currency:t}),Sn=e=>xe(e,Bt),_n=(e,t=0,r="Token")=>(typeof e!="number"&&(e=_e(e).toNumber()),{basisPoints:_e(e*Math.pow(10,t)),currency:{symbol:r,decimals:t,namespace:"spl-token"}}),Tt=(e,t)=>("currency"in e&&(e=e.currency),"currency"in t&&(t=t.currency),e.symbol===t.symbol&&e.decimals===t.decimals&&e.namespace===t.namespace);function en(e,t){if("currency"in e&&(e=e.currency),!Tt(e,t))throw new Xr(e,t)}function Cn(e){en(e,Bt)}function xt(e,t,r){if("currency"in e&&(e=e.currency),"currency"in t&&(t=t.currency),!Tt(e,t))throw new Qr(e,t,r)}const vn=(e,t)=>(xt(e,t,"add"),xe(e.basisPoints.add(t.basisPoints),e.currency)),Fn=(e,t)=>(xt(e,t,"subtract"),xe(e.basisPoints.sub(t.basisPoints),e.currency)),wn=(e,t)=>xe(e.basisPoints.muln(t),e.currency),An=e=>{if(e.currency.decimals===0)return`${e.currency.symbol} ${e.basisPoints.toString()}`;const t=new ke(10).pow(new ke(e.currency.decimals)),r=e.basisPoints,{div:n,mod:i}=r.divmod(t),s=`${n.toString()}.${i.abs().toString(10,e.currency.decimals)}`;return`${e.currency.symbol} ${s}`};export{un as A,on as D,ln as E,bn as F,sn as I,Hr as M,yn as N,nn as O,fn as P,Bt as S,dn as U,C as _,Fr as a,We as b,Lr as c,xe as d,an as e,Cn as f,vn as g,cn as h,_n as i,mn as j,En as k,Sn as l,wn as m,hn as n,gn as o,xt as p,he as q,mt as r,Fn as s,_e as t,pn as u,An as v};
