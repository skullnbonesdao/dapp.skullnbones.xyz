import{Q as Cr,a as vr,b as Ho}from"./QInput.714a6bae.js";import{Q as Wo}from"./QPage.64076250.js";import{a as pe,Q as Wr}from"./QCard.b1778339.js";import{Q as Vo}from"./QSpace.dea3f279.js";import{e9 as js,di as V,dj as Bt,dk as M,dl as N,dm as qt,dn as st,dp as Pt,dq as De,dG as Gt,dI as pt,de as _t,cX as Kr,e6 as jo,e7 as Go,e8 as Zo,dM as Yo,dN as Qo,P as Jt,dT as Xo,ea as Jo,cn as Et,cq as zn,eb as ti,d3 as ei,au as Rn,b1 as ht,ai as oe,bx as At,as as tt,al as w,V as rt,ck as ye,ak as Kt,bz as ys,a6 as Gs,b7 as Zs,a1 as Tt,aj as An,cs as bs,J as Ys,aX as Qs,bs as ni,cl as ri}from"./index.a464e8b1.js";import{c as ws,d as xs}from"./use-key-composition.1885db10.js";import{Q as si}from"./QList.90658d84.js";import{b as a,a as P,c as oi,d as ii}from"./Amount.21fe7b1d.js";import{f as ln,g as Ge}from"./assert.ccf0f6d7.js";import{d as Yt}from"./index.f7b363e6.js";import{h as ci}from"./handle_confirmation.f63cf752.js";import{t as ai}from"./token.890bfbaf.js";import{T as ui}from"./constants.2a4a46a2.js";import{Q as li}from"./QImg.1c260d95.js";import{Q as dn}from"./QSeparator.46b67c0f.js";import{_ as di}from"./plugin-vue_export-helper.21dcd24c.js";import"./sha256.3bd7c8e0.js";import"./defineProperty.034d6b40.js";function Ss(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function fi(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function Mn(n,...t){if(!fi(n))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(n.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${n.length}`)}function hi(n){if(typeof n!="function"||typeof n.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Ss(n.outputLen),Ss(n.blockLen)}function In(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function gi(n,t){Mn(n);const e=t.outputLen;if(n.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Er=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Tr=n=>new DataView(n.buffer,n.byteOffset,n.byteLength),Qt=(n,t)=>n<<32-t|n>>>t;new Uint8Array(new Uint32Array([287454020]).buffer)[0];function pi(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}function Vr(n){return typeof n=="string"&&(n=pi(n)),Mn(n),n}function mi(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];Mn(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const o=n[r];e.set(o,s),s+=o.length}return e}class Xs{clone(){return this._cloneInto()}}function Js(n){const t=r=>n().update(Vr(r)).digest(),e=n();return t.outputLen=e.outputLen,t.blockLen=e.blockLen,t.create=()=>n(),t}function to(n=32){if(Er&&typeof Er.getRandomValues=="function")return Er.getRandomValues(new Uint8Array(n));throw new Error("crypto.getRandomValues must be defined")}function yi(n,t,e,r){if(typeof n.setBigUint64=="function")return n.setBigUint64(t,e,r);const s=BigInt(32),o=BigInt(4294967295),i=Number(e>>s&o),u=Number(e&o),c=r?4:0,l=r?0:4;n.setUint32(t+c,i,r),n.setUint32(t+l,u,r)}const bi=(n,t,e)=>n&t^~n&e,wi=(n,t,e)=>n&t^n&e^t&e;class eo extends Xs{constructor(t,e,r,s){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Tr(this.buffer)}update(t){In(this);const{view:e,buffer:r,blockLen:s}=this;t=Vr(t);const o=t.length;for(let i=0;i<o;){const u=Math.min(s-this.pos,o-i);if(u===s){const c=Tr(t);for(;s<=o-i;i+=s)this.process(c,i);continue}r.set(t.subarray(i,i+u),this.pos),this.pos+=u,i+=u,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){In(this),gi(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:o}=this;let{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(r,0),i=0);for(let f=i;f<s;f++)e[f]=0;yi(r,s-8,BigInt(this.length*8),o),this.process(r,0);const u=Tr(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,d=this.get();if(l>d.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<l;f++)u.setUint32(4*f,d[f],o)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:o,destroyed:i,pos:u}=this;return t.length=s,t.pos=u,t.finished=o,t.destroyed=i,s%e&&t.buffer.set(r),t}}const fn=BigInt(2**32-1),Pr=BigInt(32);function no(n,t=!1){return t?{h:Number(n&fn),l:Number(n>>Pr&fn)}:{h:Number(n>>Pr&fn)|0,l:Number(n&fn)|0}}function xi(n,t=!1){let e=new Uint32Array(n.length),r=new Uint32Array(n.length);for(let s=0;s<n.length;s++){const{h:o,l:i}=no(n[s],t);[e[s],r[s]]=[o,i]}return[e,r]}const Si=(n,t)=>BigInt(n>>>0)<<Pr|BigInt(t>>>0),Ai=(n,t,e)=>n>>>e,ki=(n,t,e)=>n<<32-e|t>>>e,Ii=(n,t,e)=>n>>>e|t<<32-e,Bi=(n,t,e)=>n<<32-e|t>>>e,vi=(n,t,e)=>n<<64-e|t>>>e-32,Ei=(n,t,e)=>n>>>e-32|t<<64-e,Ti=(n,t)=>t,_i=(n,t)=>n,Li=(n,t,e)=>n<<e|t>>>32-e,zi=(n,t,e)=>t<<e|n>>>32-e,Ri=(n,t,e)=>t<<e-32|n>>>64-e,Mi=(n,t,e)=>n<<e-32|t>>>64-e;function Ci(n,t,e,r){const s=(t>>>0)+(r>>>0);return{h:n+e+(s/2**32|0)|0,l:s|0}}const Ki=(n,t,e)=>(n>>>0)+(t>>>0)+(e>>>0),Pi=(n,t,e,r)=>t+e+r+(n/2**32|0)|0,Fi=(n,t,e,r)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0),Di=(n,t,e,r,s)=>t+e+r+s+(n/2**32|0)|0,Ni=(n,t,e,r,s)=>(n>>>0)+(t>>>0)+(e>>>0)+(r>>>0)+(s>>>0),qi=(n,t,e,r,s,o)=>t+e+r+s+o+(n/2**32|0)|0,$i={fromBig:no,split:xi,toBig:Si,shrSH:Ai,shrSL:ki,rotrSH:Ii,rotrSL:Bi,rotrBH:vi,rotrBL:Ei,rotr32H:Ti,rotr32L:_i,rotlSH:Li,rotlSL:zi,rotlBH:Ri,rotlBL:Mi,add:Ci,add3L:Ki,add3H:Pi,add4L:Fi,add4H:Di,add5H:qi,add5L:Ni};var G=$i;const[Ui,Oi]=(()=>G.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))))(),ae=new Uint32Array(80),ue=new Uint32Array(80);class Hi extends eo{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:r,Bl:s,Ch:o,Cl:i,Dh:u,Dl:c,Eh:l,El:d,Fh:f,Fl:S,Gh:I,Gl:b,Hh:h,Hl:p}=this;return[t,e,r,s,o,i,u,c,l,d,f,S,I,b,h,p]}set(t,e,r,s,o,i,u,c,l,d,f,S,I,b,h,p){this.Ah=t|0,this.Al=e|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=u|0,this.Dl=c|0,this.Eh=l|0,this.El=d|0,this.Fh=f|0,this.Fl=S|0,this.Gh=I|0,this.Gl=b|0,this.Hh=h|0,this.Hl=p|0}process(t,e){for(let A=0;A<16;A++,e+=4)ae[A]=t.getUint32(e),ue[A]=t.getUint32(e+=4);for(let A=16;A<80;A++){const H=ae[A-15]|0,C=ue[A-15]|0,K=G.rotrSH(H,C,1)^G.rotrSH(H,C,8)^G.shrSH(H,C,7),U=G.rotrSL(H,C,1)^G.rotrSL(H,C,8)^G.shrSL(H,C,7),D=ae[A-2]|0,ct=ue[A-2]|0,X=G.rotrSH(D,ct,19)^G.rotrBH(D,ct,61)^G.shrSH(D,ct,6),J=G.rotrSL(D,ct,19)^G.rotrBL(D,ct,61)^G.shrSL(D,ct,6),mt=G.add4L(U,J,ue[A-7],ue[A-16]),yt=G.add4H(mt,K,X,ae[A-7],ae[A-16]);ae[A]=yt|0,ue[A]=mt|0}let{Ah:r,Al:s,Bh:o,Bl:i,Ch:u,Cl:c,Dh:l,Dl:d,Eh:f,El:S,Fh:I,Fl:b,Gh:h,Gl:p,Hh:k,Hl:B}=this;for(let A=0;A<80;A++){const H=G.rotrSH(f,S,14)^G.rotrSH(f,S,18)^G.rotrBH(f,S,41),C=G.rotrSL(f,S,14)^G.rotrSL(f,S,18)^G.rotrBL(f,S,41),K=f&I^~f&h,U=S&b^~S&p,D=G.add5L(B,C,U,Oi[A],ue[A]),ct=G.add5H(D,k,H,K,Ui[A],ae[A]),X=D|0,J=G.rotrSH(r,s,28)^G.rotrBH(r,s,34)^G.rotrBH(r,s,39),mt=G.rotrSL(r,s,28)^G.rotrBL(r,s,34)^G.rotrBL(r,s,39),yt=r&o^r&u^o&u,z=s&i^s&c^i&c;k=h|0,B=p|0,h=I|0,p=b|0,I=f|0,b=S|0,{h:f,l:S}=G.add(l|0,d|0,ct|0,X|0),l=u|0,d=c|0,u=o|0,c=i|0,o=r|0,i=s|0;const y=G.add3L(X,mt,z);r=G.add3H(y,ct,J,yt),s=y|0}({h:r,l:s}=G.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:i}=G.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:u,l:c}=G.add(this.Ch|0,this.Cl|0,u|0,c|0),{h:l,l:d}=G.add(this.Dh|0,this.Dl|0,l|0,d|0),{h:f,l:S}=G.add(this.Eh|0,this.El|0,f|0,S|0),{h:I,l:b}=G.add(this.Fh|0,this.Fl|0,I|0,b|0),{h,l:p}=G.add(this.Gh|0,this.Gl|0,h|0,p|0),{h:k,l:B}=G.add(this.Hh|0,this.Hl|0,k|0,B|0),this.set(r,s,o,i,u,c,l,d,f,S,I,b,h,p,k,B)}roundClean(){ae.fill(0),ue.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Wi=Js(()=>new Hi);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jr=BigInt(0),Cn=BigInt(1),Vi=BigInt(2);function _e(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function nn(n){if(!_e(n))throw new Error("Uint8Array expected")}function ie(n,t){if(typeof t!="boolean")throw new Error(`${n} must be valid boolean, got "${t}".`)}const ji=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function Le(n){nn(n);let t="";for(let e=0;e<n.length;e++)t+=ji[n[e]];return t}function ro(n){const t=n.toString(16);return t.length&1?`0${t}`:t}function Gr(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":`0x${n}`)}const re={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function As(n){if(n>=re._0&&n<=re._9)return n-re._0;if(n>=re._A&&n<=re._F)return n-(re._A-10);if(n>=re._a&&n<=re._f)return n-(re._a-10)}function $e(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);const t=n.length,e=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(e);for(let s=0,o=0;s<e;s++,o+=2){const i=As(n.charCodeAt(o)),u=As(n.charCodeAt(o+1));if(i===void 0||u===void 0){const c=n[o]+n[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}r[s]=i*16+u}return r}function Ee(n){return Gr(Le(n))}function Ne(n){return nn(n),Gr(Le(Uint8Array.from(n).reverse()))}function Ue(n,t){return $e(n.toString(16).padStart(t*2,"0"))}function Ye(n,t){return Ue(n,t).reverse()}function Gi(n){return $e(ro(n))}function wt(n,t,e){let r;if(typeof t=="string")try{r=$e(t)}catch(o){throw new Error(`${n} must be valid hex string, got "${t}". Cause: ${o}`)}else if(_e(t))r=Uint8Array.from(t);else throw new Error(`${n} must be hex string or Uint8Array`);const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(`${n} expected ${e} bytes, got ${s}`);return r}function ze(...n){let t=0;for(let r=0;r<n.length;r++){const s=n[r];nn(s),t+=s.length}const e=new Uint8Array(t);for(let r=0,s=0;r<n.length;r++){const o=n[r];e.set(o,s),s+=o.length}return e}function Zi(n,t){if(n.length!==t.length)return!1;let e=0;for(let r=0;r<n.length;r++)e|=n[r]^t[r];return e===0}function Yi(n){if(typeof n!="string")throw new Error(`utf8ToBytes expected string, got ${typeof n}`);return new Uint8Array(new TextEncoder().encode(n))}const _r=n=>typeof n=="bigint"&&jr<=n;function Kn(n,t,e){return _r(n)&&_r(t)&&_r(e)&&t<=n&&n<e}function Ht(n,t,e,r){if(!Kn(t,e,r))throw new Error(`expected valid ${n}: ${e} <= n < ${r}, got ${typeof t} ${t}`)}function Qi(n){let t;for(t=0;n>jr;n>>=Cn,t+=1);return t}function Xi(n,t){return n>>BigInt(t)&Cn}function Ji(n,t,e){return n|(e?Cn:jr)<<BigInt(t)}const Zr=n=>(Vi<<BigInt(n-1))-Cn,Lr=n=>new Uint8Array(n),ks=n=>Uint8Array.from(n);function so(n,t,e){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Lr(n),s=Lr(n),o=0;const i=()=>{r.fill(1),s.fill(0),o=0},u=(...f)=>e(s,r,...f),c=(f=Lr())=>{s=u(ks([0]),f),r=u(),f.length!==0&&(s=u(ks([1]),f),r=u())},l=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const S=[];for(;f<t;){r=u();const I=r.slice();S.push(I),f+=r.length}return ze(...S)};return(f,S)=>{i(),c(f);let I;for(;!(I=S(l()));)c();return i(),I}}const tc={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||_e(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,t)=>t.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function He(n,t,e={}){const r=(s,o,i)=>{const u=tc[o];if(typeof u!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=n[s];if(!(i&&c===void 0)&&!u(c,n))throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${o}`)};for(const[s,o]of Object.entries(t))r(s,o,!1);for(const[s,o]of Object.entries(e))r(s,o,!0);return n}const ec=()=>{throw new Error("not implemented")};function Qe(n){const t=new WeakMap;return(e,...r)=>{const s=t.get(e);if(s!==void 0)return s;const o=n(e,...r);return t.set(e,o),o}}var nc=Object.freeze(Object.defineProperty({__proto__:null,isBytes:_e,abytes:nn,abool:ie,bytesToHex:Le,numberToHexUnpadded:ro,hexToNumber:Gr,hexToBytes:$e,bytesToNumberBE:Ee,bytesToNumberLE:Ne,numberToBytesBE:Ue,numberToBytesLE:Ye,numberToVarBytesBE:Gi,ensureBytes:wt,concatBytes:ze,equalBytes:Zi,utf8ToBytes:Yi,inRange:Kn,aInRange:Ht,bitLen:Qi,bitGet:Xi,bitSet:Ji,bitMask:Zr,createHmacDrbg:so,validateObject:He,notImplemented:ec,memoized:Qe},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const kt=BigInt(0),dt=BigInt(1),be=BigInt(2),rc=BigInt(3),Fr=BigInt(4),Is=BigInt(5),Bs=BigInt(8);BigInt(9);BigInt(16);function it(n,t){const e=n%t;return e>=kt?e:t+e}function sc(n,t,e){if(e<=kt||t<kt)throw new Error("Expected power/modulo > 0");if(e===dt)return kt;let r=dt;for(;t>kt;)t&dt&&(r=r*n%e),n=n*n%e,t>>=dt;return r}function ft(n,t,e){let r=n;for(;t-- >kt;)r*=r,r%=e;return r}function Dr(n,t){if(n===kt||t<=kt)throw new Error(`invert: expected positive integers, got n=${n} mod=${t}`);let e=it(n,t),r=t,s=kt,o=dt;for(;e!==kt;){const u=r/e,c=r%e,l=s-o*u;r=e,e=c,s=o,o=l}if(r!==dt)throw new Error("invert: does not exist");return it(s,t)}function oc(n){const t=(n-dt)/be;let e,r,s;for(e=n-dt,r=0;e%be===kt;e/=be,r++);for(s=be;s<n&&sc(s,t,n)!==n-dt;s++);if(r===1){const i=(n+dt)/Fr;return function(c,l){const d=c.pow(l,i);if(!c.eql(c.sqr(d),l))throw new Error("Cannot find square root");return d}}const o=(e+dt)/be;return function(u,c){if(u.pow(c,t)===u.neg(u.ONE))throw new Error("Cannot find square root");let l=r,d=u.pow(u.mul(u.ONE,s),e),f=u.pow(c,o),S=u.pow(c,e);for(;!u.eql(S,u.ONE);){if(u.eql(S,u.ZERO))return u.ZERO;let I=1;for(let h=u.sqr(S);I<l&&!u.eql(h,u.ONE);I++)h=u.sqr(h);const b=u.pow(d,dt<<BigInt(l-I-1));d=u.sqr(b),f=u.mul(f,b),S=u.mul(S,d),l=I}return f}}function ic(n){if(n%Fr===rc){const t=(n+dt)/Fr;return function(r,s){const o=r.pow(s,t);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(n%Bs===Is){const t=(n-Is)/Bs;return function(r,s){const o=r.mul(s,be),i=r.pow(o,t),u=r.mul(s,i),c=r.mul(r.mul(u,be),i),l=r.mul(u,r.sub(c,r.ONE));if(!r.eql(r.sqr(l),s))throw new Error("Cannot find square root");return l}}return oc(n)}const cc=(n,t)=>(it(n,t)&dt)===dt,ac=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function uc(n){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=ac.reduce((r,s)=>(r[s]="function",r),t);return He(n,e)}function lc(n,t,e){if(e<kt)throw new Error("Expected power > 0");if(e===kt)return n.ONE;if(e===dt)return t;let r=n.ONE,s=t;for(;e>kt;)e&dt&&(r=n.mul(r,s)),s=n.sqr(s),e>>=dt;return r}function dc(n,t){const e=new Array(t.length),r=t.reduce((o,i,u)=>n.is0(i)?o:(e[u]=o,n.mul(o,i)),n.ONE),s=n.inv(r);return t.reduceRight((o,i,u)=>n.is0(i)?o:(e[u]=n.mul(o,e[u]),n.mul(o,i)),s),e}function oo(n,t){const e=t!==void 0?t:n.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function io(n,t,e=!1,r={}){if(n<=kt)throw new Error(`Expected Field ORDER > 0, got ${n}`);const{nBitLength:s,nByteLength:o}=oo(n,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=ic(n),u=Object.freeze({ORDER:n,BITS:s,BYTES:o,MASK:Zr(s),ZERO:kt,ONE:dt,create:c=>it(c,n),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return kt<=c&&c<n},is0:c=>c===kt,isOdd:c=>(c&dt)===dt,neg:c=>it(-c,n),eql:(c,l)=>c===l,sqr:c=>it(c*c,n),add:(c,l)=>it(c+l,n),sub:(c,l)=>it(c-l,n),mul:(c,l)=>it(c*l,n),pow:(c,l)=>lc(u,c,l),div:(c,l)=>it(c*Dr(l,n),n),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>Dr(c,n),sqrt:r.sqrt||(c=>i(u,c)),invertBatch:c=>dc(u,c),cmov:(c,l,d)=>d?l:c,toBytes:c=>e?Ye(c,o):Ue(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return e?Ne(c):Ee(c)}});return Object.freeze(u)}function co(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function ao(n){const t=co(n);return t+Math.ceil(t/2)}function fc(n,t,e=!1){const r=n.length,s=co(t),o=ao(t);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const i=e?Ee(n):Ne(n),u=it(i,t-dt)+dt;return e?Ye(u,s):Ue(u,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const hc=BigInt(0),zr=BigInt(1),Rr=new WeakMap,vs=new WeakMap;function uo(n,t){const e=(o,i)=>{const u=i.negate();return o?u:i},r=o=>{if(!Number.isSafeInteger(o)||o<=0||o>t)throw new Error(`Wrong window size=${o}, should be [1..${t}]`)},s=o=>{r(o);const i=Math.ceil(t/o)+1,u=2**(o-1);return{windows:i,windowSize:u}};return{constTimeNegate:e,unsafeLadder(o,i){let u=n.ZERO,c=o;for(;i>hc;)i&zr&&(u=u.add(c)),c=c.double(),i>>=zr;return u},precomputeWindow(o,i){const{windows:u,windowSize:c}=s(i),l=[];let d=o,f=d;for(let S=0;S<u;S++){f=d,l.push(f);for(let I=1;I<c;I++)f=f.add(d),l.push(f);d=f.double()}return l},wNAF(o,i,u){const{windows:c,windowSize:l}=s(o);let d=n.ZERO,f=n.BASE;const S=BigInt(2**o-1),I=2**o,b=BigInt(o);for(let h=0;h<c;h++){const p=h*l;let k=Number(u&S);u>>=b,k>l&&(k-=I,u+=zr);const B=p,A=p+Math.abs(k)-1,H=h%2!==0,C=k<0;k===0?f=f.add(e(H,i[B])):d=d.add(e(C,i[A]))}return{p:d,f}},wNAFCached(o,i,u){const c=vs.get(o)||1;let l=Rr.get(o);return l||(l=this.precomputeWindow(o,c),c!==1&&Rr.set(o,u(l))),this.wNAF(c,l,i)},setWindowSize(o,i){r(i),vs.set(o,i),Rr.delete(o)}}}function Yr(n){return uc(n.Fp),He(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...oo(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jt=BigInt(0),Mt=BigInt(1),hn=BigInt(2),gc=BigInt(8),pc={zip215:!0};function mc(n){const t=Yr(n);return He(n,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...t})}function yc(n){const t=mc(n),{Fp:e,n:r,prehash:s,hash:o,randomBytes:i,nByteLength:u,h:c}=t,l=hn<<BigInt(u*8)-Mt,d=e.create,f=t.uvRatio||((y,m)=>{try{return{isValid:!0,value:e.sqrt(y*e.inv(m))}}catch{return{isValid:!1,value:jt}}}),S=t.adjustScalarBytes||(y=>y),I=t.domain||((y,m,E)=>{if(ie("phflag",E),m.length||E)throw new Error("Contexts/pre-hash are not supported");return y});function b(y,m){Ht("coordinate "+y,m,jt,l)}function h(y){if(!(y instanceof B))throw new Error("ExtendedPoint expected")}const p=Qe((y,m)=>{const{ex:E,ey:L,ez:q}=y,O=y.is0();m==null&&(m=O?gc:e.inv(q));const W=d(E*m),et=d(L*m),Y=d(q*m);if(O)return{x:jt,y:Mt};if(Y!==Mt)throw new Error("invZ was invalid");return{x:W,y:et}}),k=Qe(y=>{const{a:m,d:E}=t;if(y.is0())throw new Error("bad point: ZERO");const{ex:L,ey:q,ez:O,et:W}=y,et=d(L*L),Y=d(q*q),nt=d(O*O),at=d(nt*nt),ut=d(et*m),zt=d(nt*d(ut+Y)),xt=d(at+d(E*d(et*Y)));if(zt!==xt)throw new Error("bad point: equation left != right (1)");const bt=d(L*q),Vt=d(O*W);if(bt!==Vt)throw new Error("bad point: equation left != right (2)");return!0});class B{constructor(m,E,L,q){this.ex=m,this.ey=E,this.ez=L,this.et=q,b("x",m),b("y",E),b("z",L),b("t",q),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(m){if(m instanceof B)throw new Error("extended point not allowed");const{x:E,y:L}=m||{};return b("x",E),b("y",L),new B(E,L,Mt,d(E*L))}static normalizeZ(m){const E=e.invertBatch(m.map(L=>L.ez));return m.map((L,q)=>L.toAffine(E[q])).map(B.fromAffine)}_setWindowSize(m){C.setWindowSize(this,m)}assertValidity(){k(this)}equals(m){h(m);const{ex:E,ey:L,ez:q}=this,{ex:O,ey:W,ez:et}=m,Y=d(E*et),nt=d(O*q),at=d(L*et),ut=d(W*q);return Y===nt&&at===ut}is0(){return this.equals(B.ZERO)}negate(){return new B(d(-this.ex),this.ey,this.ez,d(-this.et))}double(){const{a:m}=t,{ex:E,ey:L,ez:q}=this,O=d(E*E),W=d(L*L),et=d(hn*d(q*q)),Y=d(m*O),nt=E+L,at=d(d(nt*nt)-O-W),ut=Y+W,zt=ut-et,xt=Y-W,bt=d(at*zt),Vt=d(ut*xt),Rt=d(at*xt),It=d(zt*ut);return new B(bt,Vt,It,Rt)}add(m){h(m);const{a:E,d:L}=t,{ex:q,ey:O,ez:W,et}=this,{ex:Y,ey:nt,ez:at,et:ut}=m;if(E===BigInt(-1)){const ls=d((O-q)*(nt+Y)),ds=d((O+q)*(nt-Y)),Br=d(ds-ls);if(Br===jt)return this.double();const fs=d(W*hn*ut),hs=d(et*hn*at),gs=hs+fs,ps=ds+ls,ms=hs-fs,qo=d(gs*Br),$o=d(ps*ms),Uo=d(gs*ms),Oo=d(Br*ps);return new B(qo,$o,Oo,Uo)}const zt=d(q*Y),xt=d(O*nt),bt=d(et*L*ut),Vt=d(W*at),Rt=d((q+O)*(Y+nt)-zt-xt),It=Vt-bt,ne=Vt+bt,je=d(xt-E*zt),un=d(Rt*It),Fo=d(ne*je),Do=d(Rt*je),No=d(It*ne);return new B(un,Fo,No,Do)}subtract(m){return this.add(m.negate())}wNAF(m){return C.wNAFCached(this,m,B.normalizeZ)}multiply(m){const E=m;Ht("scalar",E,Mt,r);const{p:L,f:q}=this.wNAF(E);return B.normalizeZ([L,q])[0]}multiplyUnsafe(m){const E=m;return Ht("scalar",E,jt,r),E===jt?H:this.equals(H)||E===Mt?this:this.equals(A)?this.wNAF(E).p:C.unsafeLadder(this,E)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return C.unsafeLadder(this,r).is0()}toAffine(m){return p(this,m)}clearCofactor(){const{h:m}=t;return m===Mt?this:this.multiplyUnsafe(m)}static fromHex(m,E=!1){const{d:L,a:q}=t,O=e.BYTES;m=wt("pointHex",m,O),ie("zip215",E);const W=m.slice(),et=m[O-1];W[O-1]=et&-129;const Y=Ne(W),nt=E?l:e.ORDER;Ht("pointHex.y",Y,jt,nt);const at=d(Y*Y),ut=d(at-Mt),zt=d(L*at-q);let{isValid:xt,value:bt}=f(ut,zt);if(!xt)throw new Error("Point.fromHex: invalid y coordinate");const Vt=(bt&Mt)===Mt,Rt=(et&128)!==0;if(!E&&bt===jt&&Rt)throw new Error("Point.fromHex: x=0 and x_0=1");return Rt!==Vt&&(bt=d(-bt)),B.fromAffine({x:bt,y:Y})}static fromPrivateKey(m){return D(m).point}toRawBytes(){const{x:m,y:E}=this.toAffine(),L=Ye(E,e.BYTES);return L[L.length-1]|=m&Mt?128:0,L}toHex(){return Le(this.toRawBytes())}}B.BASE=new B(t.Gx,t.Gy,Mt,d(t.Gx*t.Gy)),B.ZERO=new B(jt,Mt,Mt,jt);const{BASE:A,ZERO:H}=B,C=uo(B,u*8);function K(y){return it(y,r)}function U(y){return K(Ne(y))}function D(y){const m=u;y=wt("private key",y,m);const E=wt("hashed private key",o(y),2*m),L=S(E.slice(0,m)),q=E.slice(m,2*m),O=U(L),W=A.multiply(O),et=W.toRawBytes();return{head:L,prefix:q,scalar:O,point:W,pointBytes:et}}function ct(y){return D(y).pointBytes}function X(y=new Uint8Array,...m){const E=ze(...m);return U(o(I(E,wt("context",y),!!s)))}function J(y,m,E={}){y=wt("message",y),s&&(y=s(y));const{prefix:L,scalar:q,pointBytes:O}=D(m),W=X(E.context,L,y),et=A.multiply(W).toRawBytes(),Y=X(E.context,et,O,y),nt=K(W+Y*q);Ht("signature.s",nt,jt,r);const at=ze(et,Ye(nt,e.BYTES));return wt("result",at,u*2)}const mt=pc;function yt(y,m,E,L=mt){const{context:q,zip215:O}=L,W=e.BYTES;y=wt("signature",y,2*W),m=wt("message",m),O!==void 0&&ie("zip215",O),s&&(m=s(m));const et=Ne(y.slice(W,2*W));let Y,nt,at;try{Y=B.fromHex(E,O),nt=B.fromHex(y.slice(0,W),O),at=A.multiplyUnsafe(et)}catch{return!1}if(!O&&Y.isSmallOrder())return!1;const ut=X(q,nt.toRawBytes(),Y.toRawBytes(),m);return nt.add(Y.multiplyUnsafe(ut)).subtract(at).clearCofactor().equals(B.ZERO)}return A._setWindowSize(8),{CURVE:t,getPublicKey:ct,sign:J,verify:yt,ExtendedPoint:B,utils:{getExtendedPublicKey:D,randomPrivateKey:()=>i(e.BYTES),precompute(y=8,m=B.BASE){return m._setWindowSize(y),m.multiply(BigInt(3)),m}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Qr=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Es=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const bc=BigInt(1),Ts=BigInt(2);BigInt(3);const wc=BigInt(5),xc=BigInt(8);function Sc(n){const t=BigInt(10),e=BigInt(20),r=BigInt(40),s=BigInt(80),o=Qr,u=n*n%o*n%o,c=ft(u,Ts,o)*u%o,l=ft(c,bc,o)*n%o,d=ft(l,wc,o)*l%o,f=ft(d,t,o)*d%o,S=ft(f,e,o)*f%o,I=ft(S,r,o)*S%o,b=ft(I,s,o)*I%o,h=ft(b,s,o)*I%o,p=ft(h,t,o)*d%o;return{pow_p_5_8:ft(p,Ts,o)*n%o,b2:u}}function Ac(n){return n[0]&=248,n[31]&=127,n[31]|=64,n}function kc(n,t){const e=Qr,r=it(t*t*t,e),s=it(r*r*t,e),o=Sc(n*s).pow_p_5_8;let i=it(n*r*o,e);const u=it(t*i*i,e),c=i,l=it(i*Es,e),d=u===n,f=u===it(-n,e),S=u===it(-n*Es,e);return d&&(i=c),(f||S)&&(i=l),cc(i,e)&&(i=it(-i,e)),{isValid:d||f,value:i}}const Ic=(()=>io(Qr,void 0,!0))(),Bc=(()=>({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Ic,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:xc,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Wi,randomBytes:to,adjustScalarBytes:Ac,uvRatio:kc}))(),rn=(()=>yc(Bc))(),vc=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),le=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),de=new Uint32Array(64);class Ec extends eo{constructor(){super(64,32,8,!1),this.A=le[0]|0,this.B=le[1]|0,this.C=le[2]|0,this.D=le[3]|0,this.E=le[4]|0,this.F=le[5]|0,this.G=le[6]|0,this.H=le[7]|0}get(){const{A:t,B:e,C:r,D:s,E:o,F:i,G:u,H:c}=this;return[t,e,r,s,o,i,u,c]}set(t,e,r,s,o,i,u,c){this.A=t|0,this.B=e|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=u|0,this.H=c|0}process(t,e){for(let f=0;f<16;f++,e+=4)de[f]=t.getUint32(e,!1);for(let f=16;f<64;f++){const S=de[f-15],I=de[f-2],b=Qt(S,7)^Qt(S,18)^S>>>3,h=Qt(I,17)^Qt(I,19)^I>>>10;de[f]=h+de[f-7]+b+de[f-16]|0}let{A:r,B:s,C:o,D:i,E:u,F:c,G:l,H:d}=this;for(let f=0;f<64;f++){const S=Qt(u,6)^Qt(u,11)^Qt(u,25),I=d+S+bi(u,c,l)+vc[f]+de[f]|0,h=(Qt(r,2)^Qt(r,13)^Qt(r,22))+wi(r,s,o)|0;d=l,l=c,c=u,u=i+I|0,i=o,o=s,s=r,r=I+h|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,u=u+this.E|0,c=c+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(r,s,o,i,u,c,l,d)}roundClean(){de.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const Nr=Js(()=>new Ec);class Tc extends TypeError{constructor(t,e){let r;const{message:s,explanation:o,...i}=t,{path:u}=t,c=u.length===0?s:`At path: ${u.join(".")} -- ${s}`;super(o??c),o!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>r??(r=[t,...e()])}}function _c(n){return sn(n)&&typeof n[Symbol.iterator]=="function"}function sn(n){return typeof n=="object"&&n!=null}function Bn(n){return sn(n)&&!Array.isArray(n)}function Zt(n){return typeof n=="symbol"?n.toString():typeof n=="string"?JSON.stringify(n):`${n}`}function Lc(n){const{done:t,value:e}=n.next();return t?void 0:e}function zc(n,t,e,r){if(n===!0)return;n===!1?n={}:typeof n=="string"&&(n={message:n});const{path:s,branch:o}=t,{type:i}=e,{refinement:u,message:c=`Expected a value of type \`${i}\`${u?` with refinement \`${u}\``:""}, but received: \`${Zt(r)}\``}=n;return{value:r,type:i,refinement:u,key:s[s.length-1],path:s,branch:o,...n,message:c}}function*_s(n,t,e,r){_c(n)||(n=[n]);for(const s of n){const o=zc(s,t,e,r);o&&(yield o)}}function*Xr(n,t,e={}){const{path:r=[],branch:s=[n],coerce:o=!1,mask:i=!1}=e,u={path:r,branch:s,mask:i};o&&(n=t.coercer(n,u));let c="valid";for(const l of t.validator(n,u))l.explanation=e.message,c="not_valid",yield[l,void 0];for(let[l,d,f]of t.entries(n,u)){const S=Xr(d,f,{path:l===void 0?r:[...r,l],branch:l===void 0?s:[...s,d],coerce:o,mask:i,message:e.message});for(const I of S)I[0]?(c=I[0].refinement!=null?"not_refined":"not_valid",yield[I[0],void 0]):o&&(d=I[1],l===void 0?n=d:n instanceof Map?n.set(l,d):n instanceof Set?n.add(d):sn(n)&&(d!==void 0||l in n)&&(n[l]=d))}if(c!=="not_valid")for(const l of t.refiner(n,u))l.explanation=e.message,c="not_refined",yield[l,void 0];c==="valid"&&(yield[void 0,n])}class ee{constructor(t){const{type:e,schema:r,validator:s,refiner:o,coercer:i=c=>c,entries:u=function*(){}}=t;this.type=e,this.schema=r,this.entries=u,this.coercer=i,s?this.validator=(c,l)=>{const d=s(c,l);return _s(d,l,this,c)}:this.validator=()=>[],o?this.refiner=(c,l)=>{const d=o(c,l);return _s(d,l,this,c)}:this.refiner=()=>[]}assert(t,e){return Rc(t,this,e)}create(t,e){return Xe(t,this,e)}is(t){return lo(t,this)}mask(t,e){return Mc(t,this,e)}validate(t,e={}){return on(t,this,e)}}function Rc(n,t,e){const r=on(n,t,{message:e});if(r[0])throw r[0]}function Xe(n,t,e){const r=on(n,t,{coerce:!0,message:e});if(r[0])throw r[0];return r[1]}function Mc(n,t,e){const r=on(n,t,{coerce:!0,mask:!0,message:e});if(r[0])throw r[0];return r[1]}function lo(n,t){return!on(n,t)[0]}function on(n,t,e={}){const r=Xr(n,t,e),s=Lc(r);if(s[0])return[new Tc(s[0],function*(){for(const i of r)i[0]&&(yield i[0])}),void 0];{const o=s[1];return[void 0,o]}}function Re(n,t){return new ee({type:n,schema:null,validator:t})}function Cc(){return Re("any",()=>!0)}function T(n){return new ee({type:"array",schema:n,*entries(t){if(n&&Array.isArray(t))for(const[e,r]of t.entries())yield[e,r,n]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||`Expected an array value, but received: ${Zt(t)}`}})}function te(){return Re("boolean",n=>typeof n=="boolean")}function Jr(n){return Re("instance",t=>t instanceof n||`Expected a \`${n.name}\` instance, but received: ${Zt(t)}`)}function lt(n){const t=Zt(n),e=typeof n;return new ee({type:"literal",schema:e==="string"||e==="number"||e==="boolean"?n:null,validator(r){return r===n||`Expected the literal \`${t}\`, but received: ${Zt(r)}`}})}function Kc(){return Re("never",()=>!1)}function _(n){return new ee({...n,validator:(t,e)=>t===null||n.validator(t,e),refiner:(t,e)=>t===null||n.refiner(t,e)})}function g(){return Re("number",n=>typeof n=="number"&&!isNaN(n)||`Expected a number, but received: ${Zt(n)}`)}function $(n){return new ee({...n,validator:(t,e)=>t===void 0||n.validator(t,e),refiner:(t,e)=>t===void 0||n.refiner(t,e)})}function fo(n,t){return new ee({type:"record",schema:null,*entries(e){if(sn(e))for(const r in e){const s=e[r];yield[r,r,n],yield[r,s,t]}},validator(e){return Bn(e)||`Expected an object, but received: ${Zt(e)}`},coercer(e){return Bn(e)?{...e}:e}})}function v(){return Re("string",n=>typeof n=="string"||`Expected a string, but received: ${Zt(n)}`)}function ts(n){const t=Kc();return new ee({type:"tuple",schema:null,*entries(e){if(Array.isArray(e)){const r=Math.max(n.length,e.length);for(let s=0;s<r;s++)yield[s,e[s],n[s]||t]}},validator(e){return Array.isArray(e)||`Expected an array, but received: ${Zt(e)}`},coercer(e){return Array.isArray(e)?e.slice():e}})}function x(n){const t=Object.keys(n);return new ee({type:"type",schema:n,*entries(e){if(sn(e))for(const r of t)yield[r,e[r],n[r]]},validator(e){return Bn(e)||`Expected an object, but received: ${Zt(e)}`},coercer(e){return Bn(e)?{...e}:e}})}function Lt(n){const t=n.map(e=>e.type).join(" | ");return new ee({type:"union",schema:null,coercer(e,r){for(const s of n){const[o,i]=s.validate(e,{coerce:!0,mask:r.mask});if(!o)return i}return e},validator(e,r){const s=[];for(const o of n){const[...i]=Xr(e,o,r),[u]=i;if(u[0])for(const[c]of i)c&&s.push(c);else return[]}return[`Expected the value to satisfy a union of \`${t}\`, but received: ${Zt(e)}`,...s]}})}function We(){return Re("unknown",()=>!0)}function cn(n,t,e){return new ee({...n,coercer:(r,s)=>lo(r,t)?n.coercer(e(r,s),s):n.coercer(r,s)})}js.v4;js.v4;var Pc={exports:{}};(function(n){var t=Object.prototype.hasOwnProperty,e="~";function r(){}Object.create&&(r.prototype=Object.create(null),new r().__proto__||(e=!1));function s(c,l,d){this.fn=c,this.context=l,this.once=d||!1}function o(c,l,d,f,S){if(typeof d!="function")throw new TypeError("The listener must be a function");var I=new s(d,f||c,S),b=e?e+l:l;return c._events[b]?c._events[b].fn?c._events[b]=[c._events[b],I]:c._events[b].push(I):(c._events[b]=I,c._eventsCount++),c}function i(c,l){--c._eventsCount===0?c._events=new r:delete c._events[l]}function u(){this._events=new r,this._eventsCount=0}u.prototype.eventNames=function(){var l=[],d,f;if(this._eventsCount===0)return l;for(f in d=this._events)t.call(d,f)&&l.push(e?f.slice(1):f);return Object.getOwnPropertySymbols?l.concat(Object.getOwnPropertySymbols(d)):l},u.prototype.listeners=function(l){var d=e?e+l:l,f=this._events[d];if(!f)return[];if(f.fn)return[f.fn];for(var S=0,I=f.length,b=new Array(I);S<I;S++)b[S]=f[S].fn;return b},u.prototype.listenerCount=function(l){var d=e?e+l:l,f=this._events[d];return f?f.fn?1:f.length:0},u.prototype.emit=function(l,d,f,S,I,b){var h=e?e+l:l;if(!this._events[h])return!1;var p=this._events[h],k=arguments.length,B,A;if(p.fn){switch(p.once&&this.removeListener(l,p.fn,void 0,!0),k){case 1:return p.fn.call(p.context),!0;case 2:return p.fn.call(p.context,d),!0;case 3:return p.fn.call(p.context,d,f),!0;case 4:return p.fn.call(p.context,d,f,S),!0;case 5:return p.fn.call(p.context,d,f,S,I),!0;case 6:return p.fn.call(p.context,d,f,S,I,b),!0}for(A=1,B=new Array(k-1);A<k;A++)B[A-1]=arguments[A];p.fn.apply(p.context,B)}else{var H=p.length,C;for(A=0;A<H;A++)switch(p[A].once&&this.removeListener(l,p[A].fn,void 0,!0),k){case 1:p[A].fn.call(p[A].context);break;case 2:p[A].fn.call(p[A].context,d);break;case 3:p[A].fn.call(p[A].context,d,f);break;case 4:p[A].fn.call(p[A].context,d,f,S);break;default:if(!B)for(C=1,B=new Array(k-1);C<k;C++)B[C-1]=arguments[C];p[A].fn.apply(p[A].context,B)}}return!0},u.prototype.on=function(l,d,f){return o(this,l,d,f,!1)},u.prototype.once=function(l,d,f){return o(this,l,d,f,!0)},u.prototype.removeListener=function(l,d,f,S){var I=e?e+l:l;if(!this._events[I])return this;if(!d)return i(this,I),this;var b=this._events[I];if(b.fn)b.fn===d&&(!S||b.once)&&(!f||b.context===f)&&i(this,I);else{for(var h=0,p=[],k=b.length;h<k;h++)(b[h].fn!==d||S&&!b[h].once||f&&b[h].context!==f)&&p.push(b[h]);p.length?this._events[I]=p.length===1?p[0]:p:i(this,I)}return this},u.prototype.removeAllListeners=function(l){var d;return l?(d=e?e+l:l,this._events[d]&&i(this,d)):(this._events=new r,this._eventsCount=0),this},u.prototype.off=u.prototype.removeListener,u.prototype.addListener=u.prototype.on,u.prefixed=e,u.EventEmitter=u,n.exports=u})(Pc);class ho extends Xs{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,hi(t);const r=Vr(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?t.create().update(r).digest():r);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=t.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(t){return In(this),this.iHash.update(t),this}digestInto(t){In(this),Mn(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:o,blockLen:i,outputLen:u}=this;return t=t,t.finished=s,t.destroyed=o,t.blockLen=i,t.outputLen=u,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const go=(n,t,e)=>new ho(n,t).update(e).digest();go.create=(n,t)=>new ho(n,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ls(n){n.lowS!==void 0&&ie("lowS",n.lowS),n.prehash!==void 0&&ie("prehash",n.prehash)}function Fc(n){const t=Yr(n);He(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:s}=t;if(e){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:Dc,hexToBytes:Nc}=nc,ve={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(n){const{Err:t}=ve;if(n.length<2||n[0]!==2)throw new t("Invalid signature integer tag");const e=n[1],r=n.subarray(2,e+2);if(!e||r.length!==e)throw new t("Invalid signature integer: wrong length");if(r[0]&128)throw new t("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:Dc(r),l:n.subarray(e+2)}},toSig(n){const{Err:t}=ve,e=typeof n=="string"?Nc(n):n;nn(e);let r=e.length;if(r<2||e[0]!=48)throw new t("Invalid signature tag");if(e[1]!==r-2)throw new t("Invalid signature: incorrect length");const{d:s,l:o}=ve._parseInt(e.subarray(2)),{d:i,l:u}=ve._parseInt(o);if(u.length)throw new t("Invalid signature: left bytes after parsing");return{r:s,s:i}},hexFromSig(n){const t=l=>Number.parseInt(l[0],16)&8?"00"+l:l,e=l=>{const d=l.toString(16);return d.length&1?`0${d}`:d},r=t(e(n.s)),s=t(e(n.r)),o=r.length/2,i=s.length/2,u=e(o),c=e(i);return`30${e(i+o+4)}02${c}${s}02${u}${r}`}},fe=BigInt(0),St=BigInt(1);BigInt(2);const zs=BigInt(3);BigInt(4);function qc(n){const t=Fc(n),{Fp:e}=t,r=t.toBytes||((b,h,p)=>{const k=h.toAffine();return ze(Uint8Array.from([4]),e.toBytes(k.x),e.toBytes(k.y))}),s=t.fromBytes||(b=>{const h=b.subarray(1),p=e.fromBytes(h.subarray(0,e.BYTES)),k=e.fromBytes(h.subarray(e.BYTES,2*e.BYTES));return{x:p,y:k}});function o(b){const{a:h,b:p}=t,k=e.sqr(b),B=e.mul(k,b);return e.add(e.add(B,e.mul(b,h)),p)}if(!e.eql(e.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function i(b){return Kn(b,St,t.n)}function u(b){const{allowedPrivateKeyLengths:h,nByteLength:p,wrapPrivateKey:k,n:B}=t;if(h&&typeof b!="bigint"){if(_e(b)&&(b=Le(b)),typeof b!="string"||!h.includes(b.length))throw new Error("Invalid key");b=b.padStart(p*2,"0")}let A;try{A=typeof b=="bigint"?b:Ee(wt("private key",b,p))}catch{throw new Error(`private key must be ${p} bytes, hex or bigint, not ${typeof b}`)}return k&&(A=it(A,B)),Ht("private key",A,St,B),A}function c(b){if(!(b instanceof f))throw new Error("ProjectivePoint expected")}const l=Qe((b,h)=>{const{px:p,py:k,pz:B}=b;if(e.eql(B,e.ONE))return{x:p,y:k};const A=b.is0();h==null&&(h=A?e.ONE:e.inv(B));const H=e.mul(p,h),C=e.mul(k,h),K=e.mul(B,h);if(A)return{x:e.ZERO,y:e.ZERO};if(!e.eql(K,e.ONE))throw new Error("invZ was invalid");return{x:H,y:C}}),d=Qe(b=>{if(b.is0()){if(t.allowInfinityPoint&&!e.is0(b.py))return;throw new Error("bad point: ZERO")}const{x:h,y:p}=b.toAffine();if(!e.isValid(h)||!e.isValid(p))throw new Error("bad point: x or y not FE");const k=e.sqr(p),B=o(h);if(!e.eql(k,B))throw new Error("bad point: equation left != right");if(!b.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class f{constructor(h,p,k){if(this.px=h,this.py=p,this.pz=k,h==null||!e.isValid(h))throw new Error("x required");if(p==null||!e.isValid(p))throw new Error("y required");if(k==null||!e.isValid(k))throw new Error("z required");Object.freeze(this)}static fromAffine(h){const{x:p,y:k}=h||{};if(!h||!e.isValid(p)||!e.isValid(k))throw new Error("invalid affine point");if(h instanceof f)throw new Error("projective point not allowed");const B=A=>e.eql(A,e.ZERO);return B(p)&&B(k)?f.ZERO:new f(p,k,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const p=e.invertBatch(h.map(k=>k.pz));return h.map((k,B)=>k.toAffine(p[B])).map(f.fromAffine)}static fromHex(h){const p=f.fromAffine(s(wt("pointHex",h)));return p.assertValidity(),p}static fromPrivateKey(h){return f.BASE.multiply(u(h))}_setWindowSize(h){I.setWindowSize(this,h)}assertValidity(){d(this)}hasEvenY(){const{y:h}=this.toAffine();if(e.isOdd)return!e.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){c(h);const{px:p,py:k,pz:B}=this,{px:A,py:H,pz:C}=h,K=e.eql(e.mul(p,C),e.mul(A,B)),U=e.eql(e.mul(k,C),e.mul(H,B));return K&&U}negate(){return new f(this.px,e.neg(this.py),this.pz)}double(){const{a:h,b:p}=t,k=e.mul(p,zs),{px:B,py:A,pz:H}=this;let C=e.ZERO,K=e.ZERO,U=e.ZERO,D=e.mul(B,B),ct=e.mul(A,A),X=e.mul(H,H),J=e.mul(B,A);return J=e.add(J,J),U=e.mul(B,H),U=e.add(U,U),C=e.mul(h,U),K=e.mul(k,X),K=e.add(C,K),C=e.sub(ct,K),K=e.add(ct,K),K=e.mul(C,K),C=e.mul(J,C),U=e.mul(k,U),X=e.mul(h,X),J=e.sub(D,X),J=e.mul(h,J),J=e.add(J,U),U=e.add(D,D),D=e.add(U,D),D=e.add(D,X),D=e.mul(D,J),K=e.add(K,D),X=e.mul(A,H),X=e.add(X,X),D=e.mul(X,J),C=e.sub(C,D),U=e.mul(X,ct),U=e.add(U,U),U=e.add(U,U),new f(C,K,U)}add(h){c(h);const{px:p,py:k,pz:B}=this,{px:A,py:H,pz:C}=h;let K=e.ZERO,U=e.ZERO,D=e.ZERO;const ct=t.a,X=e.mul(t.b,zs);let J=e.mul(p,A),mt=e.mul(k,H),yt=e.mul(B,C),z=e.add(p,k),y=e.add(A,H);z=e.mul(z,y),y=e.add(J,mt),z=e.sub(z,y),y=e.add(p,B);let m=e.add(A,C);return y=e.mul(y,m),m=e.add(J,yt),y=e.sub(y,m),m=e.add(k,B),K=e.add(H,C),m=e.mul(m,K),K=e.add(mt,yt),m=e.sub(m,K),D=e.mul(ct,y),K=e.mul(X,yt),D=e.add(K,D),K=e.sub(mt,D),D=e.add(mt,D),U=e.mul(K,D),mt=e.add(J,J),mt=e.add(mt,J),yt=e.mul(ct,yt),y=e.mul(X,y),mt=e.add(mt,yt),yt=e.sub(J,yt),yt=e.mul(ct,yt),y=e.add(y,yt),J=e.mul(mt,y),U=e.add(U,J),J=e.mul(m,y),K=e.mul(z,K),K=e.sub(K,J),J=e.mul(z,mt),D=e.mul(m,D),D=e.add(D,J),new f(K,U,D)}subtract(h){return this.add(h.negate())}is0(){return this.equals(f.ZERO)}wNAF(h){return I.wNAFCached(this,h,f.normalizeZ)}multiplyUnsafe(h){Ht("scalar",h,fe,t.n);const p=f.ZERO;if(h===fe)return p;if(h===St)return this;const{endo:k}=t;if(!k)return I.unsafeLadder(this,h);let{k1neg:B,k1:A,k2neg:H,k2:C}=k.splitScalar(h),K=p,U=p,D=this;for(;A>fe||C>fe;)A&St&&(K=K.add(D)),C&St&&(U=U.add(D)),D=D.double(),A>>=St,C>>=St;return B&&(K=K.negate()),H&&(U=U.negate()),U=new f(e.mul(U.px,k.beta),U.py,U.pz),K.add(U)}multiply(h){const{endo:p,n:k}=t;Ht("scalar",h,St,k);let B,A;if(p){const{k1neg:H,k1:C,k2neg:K,k2:U}=p.splitScalar(h);let{p:D,f:ct}=this.wNAF(C),{p:X,f:J}=this.wNAF(U);D=I.constTimeNegate(H,D),X=I.constTimeNegate(K,X),X=new f(e.mul(X.px,p.beta),X.py,X.pz),B=D.add(X),A=ct.add(J)}else{const{p:H,f:C}=this.wNAF(h);B=H,A=C}return f.normalizeZ([B,A])[0]}multiplyAndAddUnsafe(h,p,k){const B=f.BASE,A=(C,K)=>K===fe||K===St||!C.equals(B)?C.multiplyUnsafe(K):C.multiply(K),H=A(this,p).add(A(h,k));return H.is0()?void 0:H}toAffine(h){return l(this,h)}isTorsionFree(){const{h,isTorsionFree:p}=t;if(h===St)return!0;if(p)return p(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:p}=t;return h===St?this:p?p(f,this):this.multiplyUnsafe(t.h)}toRawBytes(h=!0){return ie("isCompressed",h),this.assertValidity(),r(f,this,h)}toHex(h=!0){return ie("isCompressed",h),Le(this.toRawBytes(h))}}f.BASE=new f(t.Gx,t.Gy,e.ONE),f.ZERO=new f(e.ZERO,e.ONE,e.ZERO);const S=t.nBitLength,I=uo(f,t.endo?Math.ceil(S/2):S);return{CURVE:t,ProjectivePoint:f,normPrivateKeyToScalar:u,weierstrassEquation:o,isWithinCurveOrder:i}}function $c(n){const t=Yr(n);return He(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function Uc(n){const t=$c(n),{Fp:e,n:r}=t,s=e.BYTES+1,o=2*e.BYTES+1;function i(z){return it(z,r)}function u(z){return Dr(z,r)}const{ProjectivePoint:c,normPrivateKeyToScalar:l,weierstrassEquation:d,isWithinCurveOrder:f}=qc({...t,toBytes(z,y,m){const E=y.toAffine(),L=e.toBytes(E.x),q=ze;return ie("isCompressed",m),m?q(Uint8Array.from([y.hasEvenY()?2:3]),L):q(Uint8Array.from([4]),L,e.toBytes(E.y))},fromBytes(z){const y=z.length,m=z[0],E=z.subarray(1);if(y===s&&(m===2||m===3)){const L=Ee(E);if(!Kn(L,St,e.ORDER))throw new Error("Point is not on curve");const q=d(L);let O;try{O=e.sqrt(q)}catch(Y){const nt=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+nt)}const W=(O&St)===St;return(m&1)===1!==W&&(O=e.neg(O)),{x:L,y:O}}else if(y===o&&m===4){const L=e.fromBytes(E.subarray(0,e.BYTES)),q=e.fromBytes(E.subarray(e.BYTES,2*e.BYTES));return{x:L,y:q}}else throw new Error(`Point of length ${y} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),S=z=>Le(Ue(z,t.nByteLength));function I(z){const y=r>>St;return z>y}function b(z){return I(z)?i(-z):z}const h=(z,y,m)=>Ee(z.slice(y,m));class p{constructor(y,m,E){this.r=y,this.s=m,this.recovery=E,this.assertValidity()}static fromCompact(y){const m=t.nByteLength;return y=wt("compactSignature",y,m*2),new p(h(y,0,m),h(y,m,2*m))}static fromDER(y){const{r:m,s:E}=ve.toSig(wt("DER",y));return new p(m,E)}assertValidity(){Ht("r",this.r,St,r),Ht("s",this.s,St,r)}addRecoveryBit(y){return new p(this.r,this.s,y)}recoverPublicKey(y){const{r:m,s:E,recovery:L}=this,q=K(wt("msgHash",y));if(L==null||![0,1,2,3].includes(L))throw new Error("recovery id invalid");const O=L===2||L===3?m+t.n:m;if(O>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const W=(L&1)===0?"02":"03",et=c.fromHex(W+S(O)),Y=u(O),nt=i(-q*Y),at=i(E*Y),ut=c.BASE.multiplyAndAddUnsafe(et,nt,at);if(!ut)throw new Error("point at infinify");return ut.assertValidity(),ut}hasHighS(){return I(this.s)}normalizeS(){return this.hasHighS()?new p(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return $e(this.toDERHex())}toDERHex(){return ve.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return $e(this.toCompactHex())}toCompactHex(){return S(this.r)+S(this.s)}}const k={isValidPrivateKey(z){try{return l(z),!0}catch{return!1}},normPrivateKeyToScalar:l,randomPrivateKey:()=>{const z=ao(t.n);return fc(t.randomBytes(z),t.n)},precompute(z=8,y=c.BASE){return y._setWindowSize(z),y.multiply(BigInt(3)),y}};function B(z,y=!0){return c.fromPrivateKey(z).toRawBytes(y)}function A(z){const y=_e(z),m=typeof z=="string",E=(y||m)&&z.length;return y?E===s||E===o:m?E===2*s||E===2*o:z instanceof c}function H(z,y,m=!0){if(A(z))throw new Error("first arg must be private key");if(!A(y))throw new Error("second arg must be public key");return c.fromHex(y).multiply(l(z)).toRawBytes(m)}const C=t.bits2int||function(z){const y=Ee(z),m=z.length*8-t.nBitLength;return m>0?y>>BigInt(m):y},K=t.bits2int_modN||function(z){return i(C(z))},U=Zr(t.nBitLength);function D(z){return Ht(`num < 2^${t.nBitLength}`,z,fe,U),Ue(z,t.nByteLength)}function ct(z,y,m=X){if(["recovered","canonical"].some(xt=>xt in m))throw new Error("sign() legacy options not supported");const{hash:E,randomBytes:L}=t;let{lowS:q,prehash:O,extraEntropy:W}=m;q==null&&(q=!0),z=wt("msgHash",z),Ls(m),O&&(z=wt("prehashed msgHash",E(z)));const et=K(z),Y=l(y),nt=[D(Y),D(et)];if(W!=null&&W!==!1){const xt=W===!0?L(e.BYTES):W;nt.push(wt("extraEntropy",xt))}const at=ze(...nt),ut=et;function zt(xt){const bt=C(xt);if(!f(bt))return;const Vt=u(bt),Rt=c.BASE.multiply(bt).toAffine(),It=i(Rt.x);if(It===fe)return;const ne=i(Vt*i(ut+It*Y));if(ne===fe)return;let je=(Rt.x===It?0:2)|Number(Rt.y&St),un=ne;return q&&I(ne)&&(un=b(ne),je^=1),new p(It,un,je)}return{seed:at,k2sig:zt}}const X={lowS:t.lowS,prehash:!1},J={lowS:t.lowS,prehash:!1};function mt(z,y,m=X){const{seed:E,k2sig:L}=ct(z,y,m),q=t;return so(q.hash.outputLen,q.nByteLength,q.hmac)(E,L)}c.BASE._setWindowSize(8);function yt(z,y,m,E=J){var Rt;const L=z;if(y=wt("msgHash",y),m=wt("publicKey",m),"strict"in E)throw new Error("options.strict was renamed to lowS");Ls(E);const{lowS:q,prehash:O}=E;let W,et;try{if(typeof L=="string"||_e(L))try{W=p.fromDER(L)}catch(It){if(!(It instanceof ve.Err))throw It;W=p.fromCompact(L)}else if(typeof L=="object"&&typeof L.r=="bigint"&&typeof L.s=="bigint"){const{r:It,s:ne}=L;W=new p(It,ne)}else throw new Error("PARSE");et=c.fromHex(m)}catch(It){if(It.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(q&&W.hasHighS())return!1;O&&(y=t.hash(y));const{r:Y,s:nt}=W,at=K(y),ut=u(nt),zt=i(at*ut),xt=i(Y*ut),bt=(Rt=c.BASE.multiplyAndAddUnsafe(et,zt,xt))==null?void 0:Rt.toAffine();return bt?i(bt.x)===Y:!1}return{CURVE:t,getPublicKey:B,getSharedSecret:H,sign:mt,verify:yt,ProjectivePoint:c,Signature:p,utils:k}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Oc(n){return{hash:n,hmac:(t,...e)=>go(n,t,mi(...e)),randomBytes:to}}function Hc(n,t){const e=r=>Uc({...n,...Oc(r)});return Object.freeze({...e(t),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const po=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Rs=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Wc=BigInt(1),qr=BigInt(2),Ms=(n,t)=>(n+t/qr)/t;function Vc(n){const t=po,e=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),i=BigInt(23),u=BigInt(44),c=BigInt(88),l=n*n*n%t,d=l*l*n%t,f=ft(d,e,t)*d%t,S=ft(f,e,t)*d%t,I=ft(S,qr,t)*l%t,b=ft(I,s,t)*I%t,h=ft(b,o,t)*b%t,p=ft(h,u,t)*h%t,k=ft(p,c,t)*p%t,B=ft(k,u,t)*h%t,A=ft(B,e,t)*d%t,H=ft(A,i,t)*b%t,C=ft(H,r,t)*l%t,K=ft(C,qr,t);if(!$r.eql($r.sqr(K),n))throw new Error("Cannot find square root");return K}const $r=io(po,void 0,void 0,{sqrt:Vc}),es=Hc({a:BigInt(0),b:BigInt(7),Fp:$r,n:Rs,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const t=Rs,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Wc*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=e,i=BigInt("0x100000000000000000000000000000000"),u=Ms(o*n,t),c=Ms(-r*n,t);let l=it(n-u*e-c*s,t),d=it(-u*r-c*o,t);const f=l>i,S=d>i;if(f&&(l=t-l),S&&(d=t-d),l>i||d>i)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:f,k1:l,k2neg:S,k2:d}}}},Nr);BigInt(0);es.ProjectivePoint;rn.utils.randomPrivateKey;rn.getPublicKey;function Cs(n){try{return rn.ExtendedPoint.fromHex(n),!0}catch{return!1}}const jc=(n,t)=>rn.sign(n,t.slice(0,32)),Gc=rn.verify,Ct=n=>V.Buffer.isBuffer(n)?n:n instanceof Uint8Array?V.Buffer.from(n.buffer,n.byteOffset,n.byteLength):V.Buffer.from(n);class Zc{constructor(t){Object.assign(this,t)}encode(){return V.Buffer.from(jo(kn,this))}static decode(t){return Go(kn,this,t)}static decodeUnchecked(t){return Zo(kn,this,t)}}const kn=new Map;var mo;const Yc=32,me=32;function Qc(n){return n._bn!==void 0}let Ks=1;class R extends Zc{constructor(t){if(super({}),this._bn=void 0,Qc(t))this._bn=t._bn;else{if(typeof t=="string"){const e=_t.decode(t);if(e.length!=me)throw new Error("Invalid public key input");this._bn=new Kr(e)}else this._bn=new Kr(t);if(this._bn.byteLength()>me)throw new Error("Invalid public key input")}}static unique(){const t=new R(Ks);return Ks+=1,new R(t.toBuffer())}equals(t){return this._bn.eq(t._bn)}toBase58(){return _t.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const t=this.toBuffer();return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}toBuffer(){const t=this._bn.toArrayLike(V.Buffer);if(t.length===me)return t;const e=V.Buffer.alloc(32);return t.copy(e,32-t.length),e}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(t,e,r){const s=V.Buffer.concat([t.toBuffer(),V.Buffer.from(e),r.toBuffer()]),o=Nr(s);return new R(o)}static createProgramAddressSync(t,e){let r=V.Buffer.alloc(0);t.forEach(function(o){if(o.length>Yc)throw new TypeError("Max seed length exceeded");r=V.Buffer.concat([r,Ct(o)])}),r=V.Buffer.concat([r,e.toBuffer(),V.Buffer.from("ProgramDerivedAddress")]);const s=Nr(r);if(Cs(s))throw new Error("Invalid seeds, address must fall off the curve");return new R(s)}static async createProgramAddress(t,e){return this.createProgramAddressSync(t,e)}static findProgramAddressSync(t,e){let r=255,s;for(;r!=0;){try{const o=t.concat(V.Buffer.from([r]));s=this.createProgramAddressSync(o,e)}catch(o){if(o instanceof TypeError)throw o;r--;continue}return[s,r]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(t,e){return this.findProgramAddressSync(t,e)}static isOnCurve(t){const e=new R(t);return Cs(e.toBytes())}}mo=R;R.default=new mo("11111111111111111111111111111111");kn.set(R,{kind:"struct",fields:[["_bn","u256"]]});new R("BPFLoader1111111111111111111111111111111111");const qe=1280-40-8,yo=127,bo=64;class Je{constructor(t,e){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=t,this.accountKeysFromLookups=e}keySegments(){const t=[this.staticAccountKeys];return this.accountKeysFromLookups&&(t.push(this.accountKeysFromLookups.writable),t.push(this.accountKeysFromLookups.readonly)),t}get(t){for(const e of this.keySegments()){if(t<e.length)return e[t];t-=e.length}}get length(){return this.keySegments().flat().length}compileInstructions(t){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const r=new Map;this.keySegments().flat().forEach((o,i)=>{r.set(o.toBase58(),i)});const s=o=>{const i=r.get(o.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return t.map(o=>({programIdIndex:s(o.programId),accountKeyIndexes:o.keys.map(i=>s(i.pubkey)),data:o.data}))}}const Q=(n="publicKey")=>pt(32,n),Fe=(n="string")=>{const t=M([N("length"),N("lengthPadding"),pt(De(N(),-8),"chars")],n),e=t.decode.bind(t),r=t.encode.bind(t),s=t;return s.decode=(o,i)=>e(o,i).chars.toString(),s.encode=(o,i,u)=>{const c={chars:V.Buffer.from(o,"utf8")};return r(c,i,u)},s.alloc=o=>N().span+N().span+V.Buffer.from(o,"utf8").length,s},Xc=(n="authorized")=>M([Q("staker"),Q("withdrawer")],n),Jc=(n="lockup")=>M([qt("unixTimestamp"),qt("epoch"),Q("custodian")],n),ta=(n="voteInit")=>M([Q("nodePubkey"),Q("authorizedVoter"),Q("authorizedWithdrawer"),st("commission")],n),ea=(n="voteAuthorizeWithSeedArgs")=>M([N("voteAuthorizationType"),Q("currentAuthorityDerivedKeyOwnerPubkey"),Fe("currentAuthorityDerivedKeySeed"),Q("newAuthorized")],n);function wo(n,t){const e=s=>{if(s.span>=0)return s.span;if(typeof s.alloc=="function")return s.alloc(t[s.property]);if("count"in s&&"elementLayout"in s){const o=t[s.property];if(Array.isArray(o))return o.length*e(s.elementLayout)}else if("fields"in s)return wo({layout:s},t[s.property]);return 0};let r=0;return n.layout.fields.forEach(s=>{r+=e(s)}),r}function $t(n){let t=0,e=0;for(;;){let r=n.shift();if(t|=(r&127)<<e*7,e+=1,(r&128)===0)break}return t}function Ut(n,t){let e=t;for(;;){let r=e&127;if(e>>=7,e==0){n.push(r);break}else r|=128,n.push(r)}}function vt(n,t){if(!n)throw new Error(t||"Assertion failed")}class Pn{constructor(t,e){this.payer=void 0,this.keyMetaMap=void 0,this.payer=t,this.keyMetaMap=e}static compile(t,e){const r=new Map,s=i=>{const u=i.toBase58();let c=r.get(u);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(u,c)),c},o=s(e);o.isSigner=!0,o.isWritable=!0;for(const i of t){s(i.programId).isInvoked=!0;for(const u of i.keys){const c=s(u.pubkey);c.isSigner||=u.isSigner,c.isWritable||=u.isWritable}}return new Pn(e,r)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];vt(t.length<=256,"Max static account keys length exceeded");const e=t.filter(([,c])=>c.isSigner&&c.isWritable),r=t.filter(([,c])=>c.isSigner&&!c.isWritable),s=t.filter(([,c])=>!c.isSigner&&c.isWritable),o=t.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:e.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{vt(e.length>0,"Expected at least one writable signer key");const[c]=e[0];vt(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const u=[...e.map(([c])=>new R(c)),...r.map(([c])=>new R(c)),...s.map(([c])=>new R(c)),...o.map(([c])=>new R(c))];return[i,u]}extractTableLookup(t){const[e,r]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(e.length===0&&s.length===0))return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:s},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(t,e){const r=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(e(i)){const u=new R(o),c=t.findIndex(l=>l.equals(u));c>=0&&(vt(c<256,"Max lookup table index exceeded"),r.push(c),s.push(u),this.keyMetaMap.delete(o))}return[r,s]}}const xo="Reached end of buffer unexpectedly";function se(n){if(n.length===0)throw new Error(xo);return n.shift()}function Ot(n,...t){const[e]=t;if(t.length===2?e+(t[1]??0)>n.length:e>=n.length)throw new Error(xo);return n.splice(...t)}class tn{constructor(t){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=t.header,this.accountKeys=t.accountKeys.map(e=>new R(e)),this.recentBlockhash=t.recentBlockhash,this.instructions=t.instructions,this.instructions.forEach(e=>this.indexToProgramIds.set(e.programIdIndex,this.accountKeys[e.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:_t.decode(t.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new Je(this.staticAccountKeys)}static compile(t){const e=Pn.compile(t.instructions,t.payerKey),[r,s]=e.getMessageComponents(),i=new Je(s).compileInstructions(t.instructions).map(u=>({programIdIndex:u.programIdIndex,accounts:u.accountKeyIndexes,data:_t.encode(u.data)}));return new tn({header:r,accountKeys:s,recentBlockhash:t.recentBlockhash,instructions:i})}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures;if(t>=this.header.numRequiredSignatures){const r=t-e,o=this.accountKeys.length-e-this.header.numReadonlyUnsignedAccounts;return r<o}else{const r=e-this.header.numReadonlySignedAccounts;return t<r}}isProgramId(t){return this.indexToProgramIds.has(t)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((t,e)=>!this.isProgramId(e))}serialize(){const t=this.accountKeys.length;let e=[];Ut(e,t);const r=this.instructions.map(f=>{const{accounts:S,programIdIndex:I}=f,b=Array.from(_t.decode(f.data));let h=[];Ut(h,S.length);let p=[];return Ut(p,b.length),{programIdIndex:I,keyIndicesCount:V.Buffer.from(h),keyIndices:S,dataLength:V.Buffer.from(p),data:b}});let s=[];Ut(s,r.length);let o=V.Buffer.alloc(qe);V.Buffer.from(s).copy(o);let i=s.length;r.forEach(f=>{i+=M([st("programIdIndex"),pt(f.keyIndicesCount.length,"keyIndicesCount"),Pt(st("keyIndex"),f.keyIndices.length,"keyIndices"),pt(f.dataLength.length,"dataLength"),Pt(st("userdatum"),f.data.length,"data")]).encode(f,o,i)}),o=o.slice(0,i);const u=M([pt(1,"numRequiredSignatures"),pt(1,"numReadonlySignedAccounts"),pt(1,"numReadonlyUnsignedAccounts"),pt(e.length,"keyCount"),Pt(Q("key"),t,"keys"),Q("recentBlockhash")]),c={numRequiredSignatures:V.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:V.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:V.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:V.Buffer.from(e),keys:this.accountKeys.map(f=>Ct(f.toBytes())),recentBlockhash:_t.decode(this.recentBlockhash)};let l=V.Buffer.alloc(2048);const d=u.encode(c,l);return o.copy(l,d),l.slice(0,d+o.length)}static from(t){let e=[...t];const r=se(e);if(r!==(r&yo))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const s=se(e),o=se(e),i=$t(e);let u=[];for(let S=0;S<i;S++){const I=Ot(e,0,me);u.push(new R(V.Buffer.from(I)))}const c=Ot(e,0,me),l=$t(e);let d=[];for(let S=0;S<l;S++){const I=se(e),b=$t(e),h=Ot(e,0,b),p=$t(e),k=Ot(e,0,p),B=_t.encode(V.Buffer.from(k));d.push({programIdIndex:I,accounts:h,data:B})}const f={header:{numRequiredSignatures:r,numReadonlySignedAccounts:s,numReadonlyUnsignedAccounts:o},recentBlockhash:_t.encode(V.Buffer.from(c)),accountKeys:u,instructions:d};return new tn(f)}}class vn{constructor(t){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=t.header,this.staticAccountKeys=t.staticAccountKeys,this.recentBlockhash=t.recentBlockhash,this.compiledInstructions=t.compiledInstructions,this.addressTableLookups=t.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let t=0;for(const e of this.addressTableLookups)t+=e.readonlyIndexes.length+e.writableIndexes.length;return t}getAccountKeys(t){let e;if(t&&"accountKeysFromLookups"in t&&t.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=t.accountKeysFromLookups.writable.length+t.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");e=t.accountKeysFromLookups}else if(t&&"addressLookupTableAccounts"in t&&t.addressLookupTableAccounts)e=this.resolveAddressTableLookups(t.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new Je(this.staticAccountKeys,e)}isAccountSigner(t){return t<this.header.numRequiredSignatures}isAccountWritable(t){const e=this.header.numRequiredSignatures,r=this.staticAccountKeys.length;if(t>=r){const s=t-r,o=this.addressTableLookups.reduce((i,u)=>i+u.writableIndexes.length,0);return s<o}else if(t>=this.header.numRequiredSignatures){const s=t-e,i=r-e-this.header.numReadonlyUnsignedAccounts;return s<i}else{const s=e-this.header.numReadonlySignedAccounts;return t<s}}resolveAddressTableLookups(t){const e={writable:[],readonly:[]};for(const r of this.addressTableLookups){const s=t.find(o=>o.key.equals(r.accountKey));if(!s)throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);for(const o of r.writableIndexes)if(o<s.state.addresses.length)e.writable.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`);for(const o of r.readonlyIndexes)if(o<s.state.addresses.length)e.readonly.push(s.state.addresses[o]);else throw new Error(`Failed to find address for index ${o} in address lookup table ${r.accountKey.toBase58()}`)}return e}static compile(t){const e=Pn.compile(t.instructions,t.payerKey),r=new Array,s={writable:new Array,readonly:new Array},o=t.addressLookupTableAccounts||[];for(const d of o){const f=e.extractTableLookup(d);if(f!==void 0){const[S,{writable:I,readonly:b}]=f;r.push(S),s.writable.push(...I),s.readonly.push(...b)}}const[i,u]=e.getMessageComponents(),l=new Je(u,s).compileInstructions(t.instructions);return new vn({header:i,staticAccountKeys:u,recentBlockhash:t.recentBlockhash,compiledInstructions:l,addressTableLookups:r})}serialize(){const t=Array();Ut(t,this.staticAccountKeys.length);const e=this.serializeInstructions(),r=Array();Ut(r,this.compiledInstructions.length);const s=this.serializeAddressTableLookups(),o=Array();Ut(o,this.addressTableLookups.length);const i=M([st("prefix"),M([st("numRequiredSignatures"),st("numReadonlySignedAccounts"),st("numReadonlyUnsignedAccounts")],"header"),pt(t.length,"staticAccountKeysLength"),Pt(Q(),this.staticAccountKeys.length,"staticAccountKeys"),Q("recentBlockhash"),pt(r.length,"instructionsLength"),pt(e.length,"serializedInstructions"),pt(o.length,"addressTableLookupsLength"),pt(s.length,"serializedAddressTableLookups")]),u=new Uint8Array(qe),c=1<<7,l=i.encode({prefix:c,header:this.header,staticAccountKeysLength:new Uint8Array(t),staticAccountKeys:this.staticAccountKeys.map(d=>d.toBytes()),recentBlockhash:_t.decode(this.recentBlockhash),instructionsLength:new Uint8Array(r),serializedInstructions:e,addressTableLookupsLength:new Uint8Array(o),serializedAddressTableLookups:s},u);return u.slice(0,l)}serializeInstructions(){let t=0;const e=new Uint8Array(qe);for(const r of this.compiledInstructions){const s=Array();Ut(s,r.accountKeyIndexes.length);const o=Array();Ut(o,r.data.length),t+=M([st("programIdIndex"),pt(s.length,"encodedAccountKeyIndexesLength"),Pt(st(),r.accountKeyIndexes.length,"accountKeyIndexes"),pt(o.length,"encodedDataLength"),pt(r.data.length,"data")]).encode({programIdIndex:r.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(s),accountKeyIndexes:r.accountKeyIndexes,encodedDataLength:new Uint8Array(o),data:r.data},e,t)}return e.slice(0,t)}serializeAddressTableLookups(){let t=0;const e=new Uint8Array(qe);for(const r of this.addressTableLookups){const s=Array();Ut(s,r.writableIndexes.length);const o=Array();Ut(o,r.readonlyIndexes.length),t+=M([Q("accountKey"),pt(s.length,"encodedWritableIndexesLength"),Pt(st(),r.writableIndexes.length,"writableIndexes"),pt(o.length,"encodedReadonlyIndexesLength"),Pt(st(),r.readonlyIndexes.length,"readonlyIndexes")]).encode({accountKey:r.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(s),writableIndexes:r.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(o),readonlyIndexes:r.readonlyIndexes},e,t)}return e.slice(0,t)}static deserialize(t){let e=[...t];const r=se(e),s=r&yo;vt(r!==s,"Expected versioned message but received legacy message");const o=s;vt(o===0,`Expected versioned message with version 0 but found version ${o}`);const i={numRequiredSignatures:se(e),numReadonlySignedAccounts:se(e),numReadonlyUnsignedAccounts:se(e)},u=[],c=$t(e);for(let b=0;b<c;b++)u.push(new R(Ot(e,0,me)));const l=_t.encode(Ot(e,0,me)),d=$t(e),f=[];for(let b=0;b<d;b++){const h=se(e),p=$t(e),k=Ot(e,0,p),B=$t(e),A=new Uint8Array(Ot(e,0,B));f.push({programIdIndex:h,accountKeyIndexes:k,data:A})}const S=$t(e),I=[];for(let b=0;b<S;b++){const h=new R(Ot(e,0,me)),p=$t(e),k=Ot(e,0,p),B=$t(e),A=Ot(e,0,B);I.push({accountKey:h,writableIndexes:k,readonlyIndexes:A})}return new vn({header:i,staticAccountKeys:u,recentBlockhash:l,compiledInstructions:f,addressTableLookups:I})}}const na=V.Buffer.alloc(bo).fill(0);class Nt{constructor(t){this.keys=void 0,this.programId=void 0,this.data=V.Buffer.alloc(0),this.programId=t.programId,this.keys=t.keys,t.data&&(this.data=t.data)}toJSON(){return{keys:this.keys.map(({pubkey:t,isSigner:e,isWritable:r})=>({pubkey:t.toJSON(),isSigner:e,isWritable:r})),programId:this.programId.toJSON(),data:[...this.data]}}}class En{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(t){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!t)if(t.feePayer&&(this.feePayer=t.feePayer),t.signatures&&(this.signatures=t.signatures),Object.prototype.hasOwnProperty.call(t,"nonceInfo")){const{minContextSlot:e,nonceInfo:r}=t;this.minNonceContextSlot=e,this.nonceInfo=r}else if(Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")){const{blockhash:e,lastValidBlockHeight:r}=t;this.recentBlockhash=e,this.lastValidBlockHeight=r}else{const{recentBlockhash:e,nonceInfo:r}=t;r&&(this.nonceInfo=r),this.recentBlockhash=e}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(t=>t.toJSON()),signers:this.signatures.map(({publicKey:t})=>t.toJSON())}}add(...t){if(t.length===0)throw new Error("No instructions");return t.forEach(e=>{"instructions"in e?this.instructions=this.instructions.concat(e.instructions):"data"in e&&"programId"in e&&"keys"in e?this.instructions.push(e):this.instructions.push(new Nt(e))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let t,e;if(this.nonceInfo?(t=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?e=[this.nonceInfo.nonceInstruction,...this.instructions]:e=this.instructions):(t=this.recentBlockhash,e=this.instructions),!t)throw new Error("Transaction recentBlockhash required");e.length<1&&console.warn("No instructions provided");let r;if(this.feePayer)r=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)r=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let h=0;h<e.length;h++)if(e[h].programId===void 0)throw new Error(`Transaction instruction index ${h} has undefined program id`);const s=[],o=[];e.forEach(h=>{h.keys.forEach(k=>{o.push({...k})});const p=h.programId.toString();s.includes(p)||s.push(p)}),s.forEach(h=>{o.push({pubkey:new R(h),isSigner:!1,isWritable:!1})});const i=[];o.forEach(h=>{const p=h.pubkey.toString(),k=i.findIndex(B=>B.pubkey.toString()===p);k>-1?(i[k].isWritable=i[k].isWritable||h.isWritable,i[k].isSigner=i[k].isSigner||h.isSigner):i.push(h)}),i.sort(function(h,p){if(h.isSigner!==p.isSigner)return h.isSigner?-1:1;if(h.isWritable!==p.isWritable)return h.isWritable?-1:1;const k={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return h.pubkey.toBase58().localeCompare(p.pubkey.toBase58(),"en",k)});const u=i.findIndex(h=>h.pubkey.equals(r));if(u>-1){const[h]=i.splice(u,1);h.isSigner=!0,h.isWritable=!0,i.unshift(h)}else i.unshift({pubkey:r,isSigner:!0,isWritable:!0});for(const h of this.signatures){const p=i.findIndex(k=>k.pubkey.equals(h.publicKey));if(p>-1)i[p].isSigner||(i[p].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${h.publicKey.toString()}`)}let c=0,l=0,d=0;const f=[],S=[];i.forEach(({pubkey:h,isSigner:p,isWritable:k})=>{p?(f.push(h.toString()),c+=1,k||(l+=1)):(S.push(h.toString()),k||(d+=1))});const I=f.concat(S),b=e.map(h=>{const{data:p,programId:k}=h;return{programIdIndex:I.indexOf(k.toString()),accounts:h.keys.map(B=>I.indexOf(B.pubkey.toString())),data:_t.encode(p)}});return b.forEach(h=>{vt(h.programIdIndex>=0),h.accounts.forEach(p=>vt(p>=0))}),new tn({header:{numRequiredSignatures:c,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:d},accountKeys:I,recentBlockhash:t,instructions:b})}_compile(){const t=this.compileMessage(),e=t.accountKeys.slice(0,t.header.numRequiredSignatures);return this.signatures.length===e.length&&this.signatures.every((s,o)=>e[o].equals(s.publicKey))||(this.signatures=e.map(r=>({signature:null,publicKey:r}))),t}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(t){return(await t.getFeeForMessage(this.compileMessage())).value}setSigners(...t){if(t.length===0)throw new Error("No signers");const e=new Set;this.signatures=t.filter(r=>{const s=r.toString();return e.has(s)?!1:(e.add(s),!0)}).map(r=>({signature:null,publicKey:r}))}sign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const o of t){const i=o.publicKey.toString();e.has(i)||(e.add(i),r.push(o))}this.signatures=r.map(o=>({signature:null,publicKey:o.publicKey}));const s=this._compile();this._partialSign(s,...r)}partialSign(...t){if(t.length===0)throw new Error("No signers");const e=new Set,r=[];for(const o of t){const i=o.publicKey.toString();e.has(i)||(e.add(i),r.push(o))}const s=this._compile();this._partialSign(s,...r)}_partialSign(t,...e){const r=t.serialize();e.forEach(s=>{const o=jc(r,s.secretKey);this._addSignature(s.publicKey,Ct(o))})}addSignature(t,e){this._compile(),this._addSignature(t,e)}_addSignature(t,e){vt(e.length===64);const r=this.signatures.findIndex(s=>t.equals(s.publicKey));if(r<0)throw new Error(`unknown signer: ${t.toString()}`);this.signatures[r].signature=V.Buffer.from(e)}verifySignatures(t=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),t)}_getMessageSignednessErrors(t,e){const r={};for(const{signature:s,publicKey:o}of this.signatures)s===null?e&&(r.missing||=[]).push(o):Gc(s,t,o.toBytes())||(r.invalid||=[]).push(o);return r.invalid||r.missing?r:void 0}serialize(t){const{requireAllSignatures:e,verifySignatures:r}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},t),s=this.serializeMessage();if(r){const o=this._getMessageSignednessErrors(s,e);if(o){let i="Signature verification failed.";throw o.invalid&&(i+=`
Invalid signature for public key${o.invalid.length===1?"":"(s)"} [\`${o.invalid.map(u=>u.toBase58()).join("`, `")}\`].`),o.missing&&(i+=`
Missing signature for public key${o.missing.length===1?"":"(s)"} [\`${o.missing.map(u=>u.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(s)}_serialize(t){const{signatures:e}=this,r=[];Ut(r,e.length);const s=r.length+e.length*64+t.length,o=V.Buffer.alloc(s);return vt(e.length<256),V.Buffer.from(r).copy(o,0),e.forEach(({signature:i},u)=>{i!==null&&(vt(i.length===64,"signature has invalid length"),V.Buffer.from(i).copy(o,r.length+u*64))}),t.copy(o,r.length+e.length*64),vt(o.length<=qe,`Transaction too large: ${o.length} > ${qe}`),o}get keys(){return vt(this.instructions.length===1),this.instructions[0].keys.map(t=>t.pubkey)}get programId(){return vt(this.instructions.length===1),this.instructions[0].programId}get data(){return vt(this.instructions.length===1),this.instructions[0].data}static from(t){let e=[...t];const r=$t(e);let s=[];for(let o=0;o<r;o++){const i=Ot(e,0,bo);s.push(_t.encode(V.Buffer.from(i)))}return En.populate(tn.from(e),s)}static populate(t,e=[]){const r=new En;return r.recentBlockhash=t.recentBlockhash,t.header.numRequiredSignatures>0&&(r.feePayer=t.accountKeys[0]),e.forEach((s,o)=>{const i={signature:s==_t.encode(na)?null:_t.decode(s),publicKey:t.accountKeys[o]};r.signatures.push(i)}),t.instructions.forEach(s=>{const o=s.accounts.map(i=>{const u=t.accountKeys[i];return{pubkey:u,isSigner:r.signatures.some(c=>c.publicKey.toString()===u.toString())||t.isAccountSigner(i),isWritable:t.isAccountWritable(i)}});r.instructions.push(new Nt({keys:o,programId:t.accountKeys[s.programIdIndex],data:_t.decode(s.data)}))}),r._message=t,r._json=r.toJSON(),r}}new R("SysvarC1ock11111111111111111111111111111111");new R("SysvarEpochSchedu1e111111111111111111111111");new R("Sysvar1nstructions1111111111111111111111111");const Mr=new R("SysvarRecentB1ockHashes11111111111111111111"),Ps=new R("SysvarRent111111111111111111111111111111111");new R("SysvarRewards111111111111111111111111111111");new R("SysvarS1otHashes111111111111111111111111111");new R("SysvarS1otHistory11111111111111111111111111");new R("SysvarStakeHistory1111111111111111111111111");function Ft(n,t){const e=n.layout.span>=0?n.layout.span:wo(n,t),r=V.Buffer.alloc(e),s=Object.assign({instruction:n.index},t);return n.layout.encode(s,r),r}const ra=Bt("lamportsPerSignature"),sa=M([N("version"),N("state"),Q("authorizedPubkey"),Q("nonce"),M([ra],"feeCalculator")]),Fs=sa.span,oa=n=>{const t=n.decode.bind(n),e=n.encode.bind(n);return{decode:t,encode:e}},ia=n=>t=>{const e=pt(n,t),{encode:r,decode:s}=oa(e),o=e;return o.decode=(i,u)=>{const c=s(i,u);return Yo(V.Buffer.from(c))},o.encode=(i,u,c)=>{const l=Qo(i,n);return r(l,u,c)},o},Oe=ia(8),Dt=Object.freeze({Create:{index:0,layout:M([N("instruction"),qt("lamports"),qt("space"),Q("programId")])},Assign:{index:1,layout:M([N("instruction"),Q("programId")])},Transfer:{index:2,layout:M([N("instruction"),Oe("lamports")])},CreateWithSeed:{index:3,layout:M([N("instruction"),Q("base"),Fe("seed"),qt("lamports"),qt("space"),Q("programId")])},AdvanceNonceAccount:{index:4,layout:M([N("instruction")])},WithdrawNonceAccount:{index:5,layout:M([N("instruction"),qt("lamports")])},InitializeNonceAccount:{index:6,layout:M([N("instruction"),Q("authorized")])},AuthorizeNonceAccount:{index:7,layout:M([N("instruction"),Q("authorized")])},Allocate:{index:8,layout:M([N("instruction"),qt("space")])},AllocateWithSeed:{index:9,layout:M([N("instruction"),Q("base"),Fe("seed"),qt("space"),Q("programId")])},AssignWithSeed:{index:10,layout:M([N("instruction"),Q("base"),Fe("seed"),Q("programId")])},TransferWithSeed:{index:11,layout:M([N("instruction"),Oe("lamports"),Fe("seed"),Q("programId")])},UpgradeNonceAccount:{index:12,layout:M([N("instruction")])}});class en{constructor(){}static createAccount(t){const e=Dt.Create,r=Ft(e,{lamports:t.lamports,space:t.space,programId:Ct(t.programId.toBuffer())});return new Nt({keys:[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:r})}static transfer(t){let e,r;if("basePubkey"in t){const s=Dt.TransferWithSeed;e=Ft(s,{lamports:BigInt(t.lamports),seed:t.seed,programId:Ct(t.programId.toBuffer())}),r=[{pubkey:t.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}else{const s=Dt.Transfer;e=Ft(s,{lamports:BigInt(t.lamports)}),r=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0}]}return new Nt({keys:r,programId:this.programId,data:e})}static assign(t){let e,r;if("basePubkey"in t){const s=Dt.AssignWithSeed;e=Ft(s,{base:Ct(t.basePubkey.toBuffer()),seed:t.seed,programId:Ct(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Dt.Assign;e=Ft(s,{programId:Ct(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new Nt({keys:r,programId:this.programId,data:e})}static createAccountWithSeed(t){const e=Dt.CreateWithSeed,r=Ft(e,{base:Ct(t.basePubkey.toBuffer()),seed:t.seed,lamports:t.lamports,space:t.space,programId:Ct(t.programId.toBuffer())});let s=[{pubkey:t.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:t.newAccountPubkey,isSigner:!1,isWritable:!0}];return t.basePubkey.equals(t.fromPubkey)||s.push({pubkey:t.basePubkey,isSigner:!0,isWritable:!1}),new Nt({keys:s,programId:this.programId,data:r})}static createNonceAccount(t){const e=new En;"basePubkey"in t&&"seed"in t?e.add(en.createAccountWithSeed({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,basePubkey:t.basePubkey,seed:t.seed,lamports:t.lamports,space:Fs,programId:this.programId})):e.add(en.createAccount({fromPubkey:t.fromPubkey,newAccountPubkey:t.noncePubkey,lamports:t.lamports,space:Fs,programId:this.programId}));const r={noncePubkey:t.noncePubkey,authorizedPubkey:t.authorizedPubkey};return e.add(this.nonceInitialize(r)),e}static nonceInitialize(t){const e=Dt.InitializeNonceAccount,r=Ft(e,{authorized:Ct(t.authorizedPubkey.toBuffer())}),s={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Mr,isSigner:!1,isWritable:!1},{pubkey:Ps,isSigner:!1,isWritable:!1}],programId:this.programId,data:r};return new Nt(s)}static nonceAdvance(t){const e=Dt.AdvanceNonceAccount,r=Ft(e),s={keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Mr,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r};return new Nt(s)}static nonceWithdraw(t){const e=Dt.WithdrawNonceAccount,r=Ft(e,{lamports:t.lamports});return new Nt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Mr,isSigner:!1,isWritable:!1},{pubkey:Ps,isSigner:!1,isWritable:!1},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static nonceAuthorize(t){const e=Dt.AuthorizeNonceAccount,r=Ft(e,{authorized:Ct(t.newAuthorizedPubkey.toBuffer())});return new Nt({keys:[{pubkey:t.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:t.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:r})}static allocate(t){let e,r;if("basePubkey"in t){const s=Dt.AllocateWithSeed;e=Ft(s,{base:Ct(t.basePubkey.toBuffer()),seed:t.seed,space:t.space,programId:Ct(t.programId.toBuffer())}),r=[{pubkey:t.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:t.basePubkey,isSigner:!0,isWritable:!1}]}else{const s=Dt.Allocate;e=Ft(s,{space:t.space}),r=[{pubkey:t.accountPubkey,isSigner:!0,isWritable:!0}]}return new Nt({keys:r,programId:this.programId,data:e})}}en.programId=new R("11111111111111111111111111111111");new R("BPFLoader2111111111111111111111111111111111");M([N("typeIndex"),Oe("deactivationSlot"),Bt("lastExtendedSlot"),st("lastExtendedStartIndex"),st(),Pt(Q(),De(st(),-1),"authority")]);const gt=cn(Jr(R),v(),n=>new R(n)),So=ts([v(),lt("base64")]),ns=cn(Jr(V.Buffer),So,n=>V.Buffer.from(n[0],"base64"));function Ao(n){return Lt([x({jsonrpc:lt("2.0"),id:v(),result:n}),x({jsonrpc:lt("2.0"),id:v(),error:x({code:We(),message:v(),data:$(Cc())})})])}const ca=Ao(We());function ot(n){return cn(Ao(n),ca,t=>"error"in t?t:{...t,result:Xe(t.result,n)})}function Wt(n){return ot(x({context:x({slot:g()}),value:n}))}function Fn(n){return x({context:x({slot:g()}),value:n})}const aa=x({foundation:g(),foundationTerm:g(),initial:g(),taper:g(),terminal:g()});ot(T(_(x({epoch:g(),effectiveSlot:g(),amount:g(),postBalance:g(),commission:$(_(g()))}))));const ua=T(x({slot:g(),prioritizationFee:g()})),la=x({total:g(),validator:g(),foundation:g(),epoch:g()}),da=x({epoch:g(),slotIndex:g(),slotsInEpoch:g(),absoluteSlot:g(),blockHeight:$(g()),transactionCount:$(g())}),fa=x({slotsPerEpoch:g(),leaderScheduleSlotOffset:g(),warmup:te(),firstNormalEpoch:g(),firstNormalSlot:g()}),ha=fo(v(),T(g())),Me=_(Lt([x({}),v()])),ga=x({err:Me}),pa=lt("receivedSignature");x({"solana-core":v(),"feature-set":$(g())});const ma=x({program:v(),programId:gt,parsed:We()}),ya=x({programId:gt,accounts:T(gt),data:v()});Wt(x({err:_(Lt([x({}),v()])),logs:_(T(v())),accounts:$(_(T(_(x({executable:te(),owner:v(),lamports:g(),data:T(v()),rentEpoch:$(g())}))))),unitsConsumed:$(g()),returnData:$(_(x({programId:v(),data:ts([v(),lt("base64")])}))),innerInstructions:$(_(T(x({index:g(),instructions:T(Lt([ma,ya]))}))))}));Wt(x({byIdentity:fo(v(),T(g())),range:x({firstSlot:g(),lastSlot:g()})}));ot(aa);ot(la);ot(ua);ot(da);ot(fa);ot(ha);ot(g());Wt(x({total:g(),circulating:g(),nonCirculating:g(),nonCirculatingAccounts:T(gt)}));const ba=x({amount:v(),uiAmount:_(g()),decimals:g(),uiAmountString:$(v())});Wt(T(x({address:gt,amount:v(),uiAmount:_(g()),decimals:g(),uiAmountString:$(v())})));Wt(T(x({pubkey:gt,account:x({executable:te(),owner:gt,lamports:g(),data:ns,rentEpoch:g()})})));const Ur=x({program:v(),parsed:We(),space:g()});Wt(T(x({pubkey:gt,account:x({executable:te(),owner:gt,lamports:g(),data:Ur,rentEpoch:g()})})));Wt(T(x({lamports:g(),address:gt})));const rs=x({executable:te(),owner:gt,lamports:g(),data:ns,rentEpoch:g()});x({pubkey:gt,account:rs});const wa=cn(Lt([Jr(V.Buffer),Ur]),Lt([So,Ur]),n=>Array.isArray(n)?Xe(n,ns):n),xa=x({executable:te(),owner:gt,lamports:g(),data:wa,rentEpoch:g()});x({pubkey:gt,account:xa});x({state:Lt([lt("active"),lt("inactive"),lt("activating"),lt("deactivating")]),active:g(),inactive:g()});ot(T(x({signature:v(),slot:g(),err:Me,memo:_(v()),blockTime:$(_(g()))})));ot(T(x({signature:v(),slot:g(),err:Me,memo:_(v()),blockTime:$(_(g()))})));x({subscription:g(),result:Fn(rs)});const Sa=x({pubkey:gt,account:rs});x({subscription:g(),result:Fn(Sa)});const Aa=x({parent:g(),slot:g(),root:g()});x({subscription:g(),result:Aa});const ka=Lt([x({type:Lt([lt("firstShredReceived"),lt("completed"),lt("optimisticConfirmation"),lt("root")]),slot:g(),timestamp:g()}),x({type:lt("createdBank"),parent:g(),slot:g(),timestamp:g()}),x({type:lt("frozen"),slot:g(),timestamp:g(),stats:x({numTransactionEntries:g(),numSuccessfulTransactions:g(),numFailedTransactions:g(),maxTransactionsPerEntry:g()})}),x({type:lt("dead"),slot:g(),timestamp:g(),err:v()})]);x({subscription:g(),result:ka});x({subscription:g(),result:Fn(Lt([ga,pa]))});x({subscription:g(),result:g()});x({pubkey:v(),gossip:_(v()),tpu:_(v()),rpc:_(v()),version:_(v())});const Ds=x({votePubkey:v(),nodePubkey:v(),activatedStake:g(),epochVoteAccount:te(),epochCredits:T(ts([g(),g(),g()])),commission:g(),lastVote:g(),rootSlot:_(g())});ot(x({current:T(Ds),delinquent:T(Ds)}));const Ia=Lt([lt("processed"),lt("confirmed"),lt("finalized")]),Ba=x({slot:g(),confirmations:_(g()),err:Me,confirmationStatus:$(Ia)});Wt(T(_(Ba)));ot(g());const ko=x({accountKey:gt,writableIndexes:T(g()),readonlyIndexes:T(g())}),ss=x({signatures:T(v()),message:x({accountKeys:T(v()),header:x({numRequiredSignatures:g(),numReadonlySignedAccounts:g(),numReadonlyUnsignedAccounts:g()}),instructions:T(x({accounts:T(g()),data:v(),programIdIndex:g()})),recentBlockhash:v(),addressTableLookups:$(T(ko))})}),Io=x({pubkey:gt,signer:te(),writable:te(),source:$(Lt([lt("transaction"),lt("lookupTable")]))}),Bo=x({accountKeys:T(Io),signatures:T(v())}),vo=x({parsed:We(),program:v(),programId:gt}),Eo=x({accounts:T(gt),data:v(),programId:gt}),va=Lt([Eo,vo]),Ea=Lt([x({parsed:We(),program:v(),programId:v()}),x({accounts:T(v()),data:v(),programId:v()})]),To=cn(va,Ea,n=>"accounts"in n?Xe(n,Eo):Xe(n,vo)),_o=x({signatures:T(v()),message:x({accountKeys:T(Io),instructions:T(To),recentBlockhash:v(),addressTableLookups:$(_(T(ko)))})}),Tn=x({accountIndex:g(),mint:v(),owner:$(v()),uiTokenAmount:ba}),Lo=x({writable:T(gt),readonly:T(gt)}),Dn=x({err:Me,fee:g(),innerInstructions:$(_(T(x({index:g(),instructions:T(x({accounts:T(g()),data:v(),programIdIndex:g()}))})))),preBalances:T(g()),postBalances:T(g()),logMessages:$(_(T(v()))),preTokenBalances:$(_(T(Tn))),postTokenBalances:$(_(T(Tn))),loadedAddresses:$(Lo),computeUnitsConsumed:$(g())}),os=x({err:Me,fee:g(),innerInstructions:$(_(T(x({index:g(),instructions:T(To)})))),preBalances:T(g()),postBalances:T(g()),logMessages:$(_(T(v()))),preTokenBalances:$(_(T(Tn))),postTokenBalances:$(_(T(Tn))),loadedAddresses:$(Lo),computeUnitsConsumed:$(g())}),Ve=Lt([lt(0),lt("legacy")]),Ce=x({pubkey:v(),lamports:g(),postBalance:_(g()),rewardType:_(v()),commission:$(_(g()))});ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:ss,meta:_(Dn),version:$(Ve)})),rewards:$(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),rewards:$(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:Bo,meta:_(Dn),version:$(Ve)})),rewards:$(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:_o,meta:_(os),version:$(Ve)})),rewards:$(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:Bo,meta:_(os),version:$(Ve)})),rewards:$(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),rewards:$(T(Ce)),blockTime:_(g()),blockHeight:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),transactions:T(x({transaction:ss,meta:_(Dn)})),rewards:$(T(Ce)),blockTime:_(g())})));ot(_(x({blockhash:v(),previousBlockhash:v(),parentSlot:g(),signatures:T(v()),blockTime:_(g())})));ot(_(x({slot:g(),meta:_(Dn),blockTime:$(_(g())),transaction:ss,version:$(Ve)})));ot(_(x({slot:g(),transaction:_o,meta:_(os),blockTime:$(_(g())),version:$(Ve)})));Wt(x({blockhash:v(),feeCalculator:x({lamportsPerSignature:g()})}));Wt(x({blockhash:v(),lastValidBlockHeight:g()}));Wt(te());const Ta=x({slot:g(),numTransactions:g(),numSlots:g(),samplePeriodSecs:g()});ot(T(Ta));Wt(_(x({feeCalculator:x({lamportsPerSignature:g()})})));ot(v());ot(v());const _a=x({err:Me,logs:T(v()),signature:v()});x({result:Fn(_a),subscription:g()});Object.freeze({CreateLookupTable:{index:0,layout:M([N("instruction"),Oe("recentSlot"),st("bumpSeed")])},FreezeLookupTable:{index:1,layout:M([N("instruction")])},ExtendLookupTable:{index:2,layout:M([N("instruction"),Oe(),Pt(Q(),De(N(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:M([N("instruction")])},CloseLookupTable:{index:4,layout:M([N("instruction")])}});new R("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:M([st("instruction"),N("units"),N("additionalFee")])},RequestHeapFrame:{index:1,layout:M([st("instruction"),N("bytes")])},SetComputeUnitLimit:{index:2,layout:M([st("instruction"),N("units")])},SetComputeUnitPrice:{index:3,layout:M([st("instruction"),Oe("microLamports")])}});new R("ComputeBudget111111111111111111111111111111");M([st("numSignatures"),st("padding"),Gt("signatureOffset"),Gt("signatureInstructionIndex"),Gt("publicKeyOffset"),Gt("publicKeyInstructionIndex"),Gt("messageDataOffset"),Gt("messageDataSize"),Gt("messageInstructionIndex")]);new R("Ed25519SigVerify111111111111111111111111111");es.utils.isValidPrivateKey;es.getPublicKey;M([st("numSignatures"),Gt("signatureOffset"),st("signatureInstructionIndex"),Gt("ethAddressOffset"),st("ethAddressInstructionIndex"),Gt("messageDataOffset"),Gt("messageDataSize"),st("messageInstructionIndex"),pt(20,"ethAddress"),pt(64,"signature"),st("recoveryId")]);new R("KeccakSecp256k11111111111111111111111111111");var zo;new R("StakeConfig11111111111111111111111111111111");class Ro{constructor(t,e,r){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=t,this.epoch=e,this.custodian=r}}zo=Ro;Ro.default=new zo(0,0,R.default);Object.freeze({Initialize:{index:0,layout:M([N("instruction"),Xc(),Jc()])},Authorize:{index:1,layout:M([N("instruction"),Q("newAuthorized"),N("stakeAuthorizationType")])},Delegate:{index:2,layout:M([N("instruction")])},Split:{index:3,layout:M([N("instruction"),qt("lamports")])},Withdraw:{index:4,layout:M([N("instruction"),qt("lamports")])},Deactivate:{index:5,layout:M([N("instruction")])},Merge:{index:7,layout:M([N("instruction")])},AuthorizeWithSeed:{index:8,layout:M([N("instruction"),Q("newAuthorized"),N("stakeAuthorizationType"),Fe("authoritySeed"),Q("authorityOwner")])}});Object.freeze({Staker:{index:0},Withdrawer:{index:1}});new R("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:M([N("instruction"),ta()])},Authorize:{index:1,layout:M([N("instruction"),Q("newAuthorized"),N("voteAuthorizationType")])},Withdraw:{index:3,layout:M([N("instruction"),qt("lamports")])},UpdateValidatorIdentity:{index:4,layout:M([N("instruction")])},AuthorizeWithSeed:{index:10,layout:M([N("instruction"),ea()])}});Object.freeze({Voter:{index:0},Withdrawer:{index:1}});new R("Vote111111111111111111111111111111111111111");new R("Va1idator1nfo111111111111111111111111111111");x({name:v(),website:$(v()),details:$(v()),iconUrl:$(v()),keybaseUsername:$(v())});new R("Vote111111111111111111111111111111111111111");M([Q("nodePubkey"),Q("authorizedWithdrawer"),st("commission"),Bt(),Pt(M([Bt("slot"),N("confirmationCount")]),De(N(),-8),"votes"),st("rootSlotValid"),Bt("rootSlot"),Bt(),Pt(M([Bt("epoch"),Q("authorizedVoter")]),De(N(),-8),"authorizedVoters"),M([Pt(M([Q("authorizedPubkey"),Bt("epochOfLastAuthorizedSwitch"),Bt("targetEpoch")]),32,"buf"),Bt("idx"),st("isEmpty")],"priorVoters"),Bt(),Pt(M([Bt("epoch"),Bt("credits"),Bt("prevCredits")]),De(N(),-8),"epochCredits"),M([Bt("slot"),Bt("timestamp")],"lastTimestamp")]);const La=[156,194,70,44,22,88,137,44];class we{multisig;creator;index;bump;vaultIndex;vaultBump;size;executedTransactionIndex;constructor(t,e,r,s,o,i,u,c){this.multisig=t,this.creator=e,this.index=r,this.bump=s,this.vaultIndex=o,this.vaultBump=i,this.size=u,this.executedTransactionIndex=c}static fromArgs(t){return new we(t.multisig,t.creator,t.index,t.bump,t.vaultIndex,t.vaultBump,t.size,t.executedTransactionIndex)}static fromAccountInfo(t,e=0){return we.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find Batch account at ${e}`);return we.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,gn)}static deserialize(t,e=0){return gn.deserialize(t,e)}serialize(){return gn.serialize({accountDiscriminator:La,...this})}static get byteSize(){return gn.byteSize}static async getMinimumBalanceForRentExemption(t,e){return t.getMinimumBalanceForRentExemption(we.byteSize,e)}static hasCorrectByteSize(t,e=0){return t.byteLength-e===we.byteSize}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const t=this.index;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,vaultIndex:this.vaultIndex,vaultBump:this.vaultBump,size:this.size,executedTransactionIndex:this.executedTransactionIndex}}}const gn=new a.BeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["multisig",P.publicKey],["creator",P.publicKey],["index",a.u64],["bump",a.u8],["vaultIndex",a.u8],["vaultBump",a.u8],["size",a.u32],["executedTransactionIndex",a.u32]],we.fromArgs,"Batch"),za=new a.BeetArgsStruct([["mask",a.u8]],"Permissions"),an=new a.BeetArgsStruct([["key",P.publicKey],["permissions",za]],"Member");var _n;(function(n){n[n.OneTime=0]="OneTime",n[n.Day=1]="Day",n[n.Week=2]="Week",n[n.Month=3]="Month"})(_n||(_n={}));const is=a.fixedScalarEnum(_n),Mo=a.dataEnum([["AddMember",new a.BeetArgsStruct([["newMember",an]],'ConfigActionRecord["AddMember"]')],["RemoveMember",new a.BeetArgsStruct([["oldMember",P.publicKey]],'ConfigActionRecord["RemoveMember"]')],["ChangeThreshold",new a.BeetArgsStruct([["newThreshold",a.u16]],'ConfigActionRecord["ChangeThreshold"]')],["SetTimeLock",new a.BeetArgsStruct([["newTimeLock",a.u32]],'ConfigActionRecord["SetTimeLock"]')],["AddSpendingLimit",new a.FixableBeetArgsStruct([["createKey",P.publicKey],["vaultIndex",a.u8],["mint",P.publicKey],["amount",a.u64],["period",is],["members",a.array(P.publicKey)],["destinations",a.array(P.publicKey)]],'ConfigActionRecord["AddSpendingLimit"]')],["RemoveSpendingLimit",new a.BeetArgsStruct([["spendingLimit",P.publicKey]],'ConfigActionRecord["RemoveSpendingLimit"]')],["SetRentCollector",new a.FixableBeetArgsStruct([["newRentCollector",a.coption(P.publicKey)]],'ConfigActionRecord["SetRentCollector"]')]]),Ns=[94,8,4,35,113,139,139,112];class xe{multisig;creator;index;bump;actions;constructor(t,e,r,s,o){this.multisig=t,this.creator=e,this.index=r,this.bump=s,this.actions=o}static fromArgs(t){return new xe(t.multisig,t.creator,t.index,t.bump,t.actions)}static fromAccountInfo(t,e=0){return xe.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find ConfigTransaction account at ${e}`);return xe.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,pn)}static deserialize(t,e=0){return pn.deserialize(t,e)}serialize(){return pn.serialize({accountDiscriminator:Ns,...this})}static byteSize(t){const e=xe.fromArgs(t);return pn.toFixedFromValue({accountDiscriminator:Ns,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(xe.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const t=this.index;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,actions:this.actions}}}const pn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["multisig",P.publicKey],["creator",P.publicKey],["index",a.u64],["bump",a.u8],["actions",a.array(Mo)]],xe.fromArgs,"ConfigTransaction"),qs=[224,116,121,186,68,161,79,236];class he{createKey;configAuthority;threshold;timeLock;transactionIndex;staleTransactionIndex;rentCollector;bump;members;constructor(t,e,r,s,o,i,u,c,l){this.createKey=t,this.configAuthority=e,this.threshold=r,this.timeLock=s,this.transactionIndex=o,this.staleTransactionIndex=i,this.rentCollector=u,this.bump=c,this.members=l}static fromArgs(t){return new he(t.createKey,t.configAuthority,t.threshold,t.timeLock,t.transactionIndex,t.staleTransactionIndex,t.rentCollector,t.bump,t.members)}static fromAccountInfo(t,e=0){return he.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find Multisig account at ${e}`);return he.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,mn)}static deserialize(t,e=0){return mn.deserialize(t,e)}serialize(){return mn.serialize({accountDiscriminator:qs,...this})}static byteSize(t){const e=he.fromArgs(t);return mn.toFixedFromValue({accountDiscriminator:qs,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(he.byteSize(t),r)}pretty(){return{createKey:this.createKey.toBase58(),configAuthority:this.configAuthority.toBase58(),threshold:this.threshold,timeLock:this.timeLock,transactionIndex:(()=>{const t=this.transactionIndex;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),staleTransactionIndex:(()=>{const t=this.staleTransactionIndex;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),rentCollector:this.rentCollector,bump:this.bump,members:this.members}}}const mn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["createKey",P.publicKey],["configAuthority",P.publicKey],["threshold",a.u16],["timeLock",a.u32],["transactionIndex",a.u64],["staleTransactionIndex",a.u64],["rentCollector",a.coption(P.publicKey)],["bump",a.u8],["members",a.array(an)]],he.fromArgs,"Multisig"),Ra=[196,210,90,231,144,149,140,63];class Se{authority;multisigCreationFee;treasury;reserved;constructor(t,e,r,s){this.authority=t,this.multisigCreationFee=e,this.treasury=r,this.reserved=s}static fromArgs(t){return new Se(t.authority,t.multisigCreationFee,t.treasury,t.reserved)}static fromAccountInfo(t,e=0){return Se.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find ProgramConfig account at ${e}`);return Se.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,yn)}static deserialize(t,e=0){return yn.deserialize(t,e)}serialize(){return yn.serialize({accountDiscriminator:Ra,...this})}static get byteSize(){return yn.byteSize}static async getMinimumBalanceForRentExemption(t,e){return t.getMinimumBalanceForRentExemption(Se.byteSize,e)}static hasCorrectByteSize(t,e=0){return t.byteLength-e===Se.byteSize}pretty(){return{authority:this.authority.toBase58(),multisigCreationFee:(()=>{const t=this.multisigCreationFee;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),treasury:this.treasury.toBase58(),reserved:this.reserved}}}const yn=new a.BeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["authority",P.publicKey],["multisigCreationFee",a.u64],["treasury",P.publicKey],["reserved",a.uniformFixedSizeArray(a.u8,64)]],Se.fromArgs,"ProgramConfig"),Ma=a.dataEnum([["Draft",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Draft"]')],["Active",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Active"]')],["Rejected",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Rejected"]')],["Approved",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Approved"]')],["Executing",a.unit],["Executed",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Executed"]')],["Cancelled",new a.BeetArgsStruct([["timestamp",a.i64]],'ProposalStatusRecord["Cancelled"]')]]),$s=[26,94,189,187,116,136,53,33];class Ae{multisig;transactionIndex;status;bump;approved;rejected;cancelled;constructor(t,e,r,s,o,i,u){this.multisig=t,this.transactionIndex=e,this.status=r,this.bump=s,this.approved=o,this.rejected=i,this.cancelled=u}static fromArgs(t){return new Ae(t.multisig,t.transactionIndex,t.status,t.bump,t.approved,t.rejected,t.cancelled)}static fromAccountInfo(t,e=0){return Ae.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find Proposal account at ${e}`);return Ae.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,bn)}static deserialize(t,e=0){return bn.deserialize(t,e)}serialize(){return bn.serialize({accountDiscriminator:$s,...this})}static byteSize(t){const e=Ae.fromArgs(t);return bn.toFixedFromValue({accountDiscriminator:$s,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(Ae.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),transactionIndex:(()=>{const t=this.transactionIndex;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),status:this.status.__kind,bump:this.bump,approved:this.approved,rejected:this.rejected,cancelled:this.cancelled}}}const bn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["multisig",P.publicKey],["transactionIndex",a.u64],["status",Ma],["bump",a.u8],["approved",a.array(P.publicKey)],["rejected",a.array(P.publicKey)],["cancelled",a.array(P.publicKey)]],Ae.fromArgs,"Proposal"),Us=[10,201,27,160,218,195,222,152];class ke{multisig;createKey;vaultIndex;mint;amount;period;remainingAmount;lastReset;bump;members;destinations;constructor(t,e,r,s,o,i,u,c,l,d,f){this.multisig=t,this.createKey=e,this.vaultIndex=r,this.mint=s,this.amount=o,this.period=i,this.remainingAmount=u,this.lastReset=c,this.bump=l,this.members=d,this.destinations=f}static fromArgs(t){return new ke(t.multisig,t.createKey,t.vaultIndex,t.mint,t.amount,t.period,t.remainingAmount,t.lastReset,t.bump,t.members,t.destinations)}static fromAccountInfo(t,e=0){return ke.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find SpendingLimit account at ${e}`);return ke.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,wn)}static deserialize(t,e=0){return wn.deserialize(t,e)}serialize(){return wn.serialize({accountDiscriminator:Us,...this})}static byteSize(t){const e=ke.fromArgs(t);return wn.toFixedFromValue({accountDiscriminator:Us,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(ke.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),createKey:this.createKey.toBase58(),vaultIndex:this.vaultIndex,mint:this.mint.toBase58(),amount:(()=>{const t=this.amount;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),period:"Period."+_n[this.period],remainingAmount:(()=>{const t=this.remainingAmount;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),lastReset:(()=>{const t=this.lastReset;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,members:this.members,destinations:this.destinations}}}const wn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["multisig",P.publicKey],["createKey",P.publicKey],["vaultIndex",a.u8],["mint",P.publicKey],["amount",a.u64],["period",is],["remainingAmount",a.u64],["lastReset",a.i64],["bump",a.u8],["members",a.array(P.publicKey)],["destinations",a.array(P.publicKey)]],ke.fromArgs,"SpendingLimit"),Ca=new a.FixableBeetArgsStruct([["programIdIndex",a.u8],["accountIndexes",a.bytes],["data",a.bytes]],"MultisigCompiledInstruction"),Ka=new a.FixableBeetArgsStruct([["accountKey",P.publicKey],["writableIndexes",a.bytes],["readonlyIndexes",a.bytes]],"MultisigMessageAddressTableLookup"),Co=new a.FixableBeetArgsStruct([["numSigners",a.u8],["numWritableSigners",a.u8],["numWritableNonSigners",a.u8],["accountKeys",a.array(P.publicKey)],["instructions",a.array(Ca)],["addressTableLookups",a.array(Ka)]],"VaultTransactionMessage"),Os=[196,121,46,36,12,19,252,7];class Ie{bump;ephemeralSignerBumps;message;constructor(t,e,r){this.bump=t,this.ephemeralSignerBumps=e,this.message=r}static fromArgs(t){return new Ie(t.bump,t.ephemeralSignerBumps,t.message)}static fromAccountInfo(t,e=0){return Ie.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find VaultBatchTransaction account at ${e}`);return Ie.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,xn)}static deserialize(t,e=0){return xn.deserialize(t,e)}serialize(){return xn.serialize({accountDiscriminator:Os,...this})}static byteSize(t){const e=Ie.fromArgs(t);return xn.toFixedFromValue({accountDiscriminator:Os,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(Ie.byteSize(t),r)}pretty(){return{bump:this.bump,ephemeralSignerBumps:this.ephemeralSignerBumps,message:this.message}}}const xn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["bump",a.u8],["ephemeralSignerBumps",a.bytes],["message",Co]],Ie.fromArgs,"VaultBatchTransaction"),Hs=[168,250,162,100,81,14,162,207];class Be{multisig;creator;index;bump;vaultIndex;vaultBump;ephemeralSignerBumps;message;constructor(t,e,r,s,o,i,u,c){this.multisig=t,this.creator=e,this.index=r,this.bump=s,this.vaultIndex=o,this.vaultBump=i,this.ephemeralSignerBumps=u,this.message=c}static fromArgs(t){return new Be(t.multisig,t.creator,t.index,t.bump,t.vaultIndex,t.vaultBump,t.ephemeralSignerBumps,t.message)}static fromAccountInfo(t,e=0){return Be.deserialize(t.data,e)}static async fromAccountAddress(t,e,r){const s=await t.getAccountInfo(e,r);if(s==null)throw new Error(`Unable to find VaultTransaction account at ${e}`);return Be.fromAccountInfo(s,0)[0]}static gpaBuilder(t=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){return P.GpaBuilder.fromStruct(t,Sn)}static deserialize(t,e=0){return Sn.deserialize(t,e)}serialize(){return Sn.serialize({accountDiscriminator:Hs,...this})}static byteSize(t){const e=Be.fromArgs(t);return Sn.toFixedFromValue({accountDiscriminator:Hs,...e}).byteSize}static async getMinimumBalanceForRentExemption(t,e,r){return e.getMinimumBalanceForRentExemption(Be.byteSize(t),r)}pretty(){return{multisig:this.multisig.toBase58(),creator:this.creator.toBase58(),index:(()=>{const t=this.index;if(typeof t.toNumber=="function")try{return t.toNumber()}catch{return t}return t})(),bump:this.bump,vaultIndex:this.vaultIndex,vaultBump:this.vaultBump,ephemeralSignerBumps:this.ephemeralSignerBumps,message:this.message}}}const Sn=new a.FixableBeetStruct([["accountDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["multisig",P.publicKey],["creator",P.publicKey],["index",a.u64],["bump",a.u8],["vaultIndex",a.u8],["vaultBump",a.u8],["ephemeralSignerBumps",a.bytes],["message",Co]],Be.fromArgs,"VaultTransaction"),j=new Map,Z=new Map;class Nn extends Error{code=6e3;name="DuplicateMember";constructor(){super("Found multiple members with the same pubkey"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Nn)}}j.set(6e3,()=>new Nn);Z.set("DuplicateMember",()=>new Nn);class qn extends Error{code=6001;name="EmptyMembers";constructor(){super("Members array is empty"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,qn)}}j.set(6001,()=>new qn);Z.set("EmptyMembers",()=>new qn);class $n extends Error{code=6002;name="TooManyMembers";constructor(){super("Too many members, can be up to 65535"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$n)}}j.set(6002,()=>new $n);Z.set("TooManyMembers",()=>new $n);class Un extends Error{code=6003;name="InvalidThreshold";constructor(){super("Invalid threshold, must be between 1 and number of members with Vote permission"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Un)}}j.set(6003,()=>new Un);Z.set("InvalidThreshold",()=>new Un);class On extends Error{code=6004;name="Unauthorized";constructor(){super("Attempted to perform an unauthorized action"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,On)}}j.set(6004,()=>new On);Z.set("Unauthorized",()=>new On);class Hn extends Error{code=6005;name="NotAMember";constructor(){super("Provided pubkey is not a member of multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Hn)}}j.set(6005,()=>new Hn);Z.set("NotAMember",()=>new Hn);class Wn extends Error{code=6006;name="InvalidTransactionMessage";constructor(){super("TransactionMessage is malformed."),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Wn)}}j.set(6006,()=>new Wn);Z.set("InvalidTransactionMessage",()=>new Wn);class Vn extends Error{code=6007;name="StaleProposal";constructor(){super("Proposal is stale"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Vn)}}j.set(6007,()=>new Vn);Z.set("StaleProposal",()=>new Vn);class jn extends Error{code=6008;name="InvalidProposalStatus";constructor(){super("Invalid proposal status"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,jn)}}j.set(6008,()=>new jn);Z.set("InvalidProposalStatus",()=>new jn);class Gn extends Error{code=6009;name="InvalidTransactionIndex";constructor(){super("Invalid transaction index"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Gn)}}j.set(6009,()=>new Gn);Z.set("InvalidTransactionIndex",()=>new Gn);class Zn extends Error{code=6010;name="AlreadyApproved";constructor(){super("Member already approved the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Zn)}}j.set(6010,()=>new Zn);Z.set("AlreadyApproved",()=>new Zn);class Yn extends Error{code=6011;name="AlreadyRejected";constructor(){super("Member already rejected the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Yn)}}j.set(6011,()=>new Yn);Z.set("AlreadyRejected",()=>new Yn);class Qn extends Error{code=6012;name="AlreadyCancelled";constructor(){super("Member already cancelled the transaction"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Qn)}}j.set(6012,()=>new Qn);Z.set("AlreadyCancelled",()=>new Qn);class Xn extends Error{code=6013;name="InvalidNumberOfAccounts";constructor(){super("Wrong number of accounts provided"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Xn)}}j.set(6013,()=>new Xn);Z.set("InvalidNumberOfAccounts",()=>new Xn);class Jn extends Error{code=6014;name="InvalidAccount";constructor(){super("Invalid account provided"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Jn)}}j.set(6014,()=>new Jn);Z.set("InvalidAccount",()=>new Jn);class tr extends Error{code=6015;name="RemoveLastMember";constructor(){super("Cannot remove last member"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,tr)}}j.set(6015,()=>new tr);Z.set("RemoveLastMember",()=>new tr);class er extends Error{code=6016;name="NoVoters";constructor(){super("Members don't include any voters"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,er)}}j.set(6016,()=>new er);Z.set("NoVoters",()=>new er);class nr extends Error{code=6017;name="NoProposers";constructor(){super("Members don't include any proposers"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,nr)}}j.set(6017,()=>new nr);Z.set("NoProposers",()=>new nr);class rr extends Error{code=6018;name="NoExecutors";constructor(){super("Members don't include any executors"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,rr)}}j.set(6018,()=>new rr);Z.set("NoExecutors",()=>new rr);class sr extends Error{code=6019;name="InvalidStaleTransactionIndex";constructor(){super("`stale_transaction_index` must be <= `transaction_index`"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,sr)}}j.set(6019,()=>new sr);Z.set("InvalidStaleTransactionIndex",()=>new sr);class or extends Error{code=6020;name="NotSupportedForControlled";constructor(){super("Instruction not supported for controlled multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,or)}}j.set(6020,()=>new or);Z.set("NotSupportedForControlled",()=>new or);class ir extends Error{code=6021;name="TimeLockNotReleased";constructor(){super("Proposal time lock has not been released"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ir)}}j.set(6021,()=>new ir);Z.set("TimeLockNotReleased",()=>new ir);class cr extends Error{code=6022;name="NoActions";constructor(){super("Config transaction must have at least one action"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,cr)}}j.set(6022,()=>new cr);Z.set("NoActions",()=>new cr);class ar extends Error{code=6023;name="MissingAccount";constructor(){super("Missing account"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ar)}}j.set(6023,()=>new ar);Z.set("MissingAccount",()=>new ar);class ur extends Error{code=6024;name="InvalidMint";constructor(){super("Invalid mint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,ur)}}j.set(6024,()=>new ur);Z.set("InvalidMint",()=>new ur);class lr extends Error{code=6025;name="InvalidDestination";constructor(){super("Invalid destination"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,lr)}}j.set(6025,()=>new lr);Z.set("InvalidDestination",()=>new lr);class dr extends Error{code=6026;name="SpendingLimitExceeded";constructor(){super("Spending limit exceeded"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,dr)}}j.set(6026,()=>new dr);Z.set("SpendingLimitExceeded",()=>new dr);class fr extends Error{code=6027;name="DecimalsMismatch";constructor(){super("Decimals don't match the mint"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,fr)}}j.set(6027,()=>new fr);Z.set("DecimalsMismatch",()=>new fr);class hr extends Error{code=6028;name="UnknownPermission";constructor(){super("Member has unknown permission"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,hr)}}j.set(6028,()=>new hr);Z.set("UnknownPermission",()=>new hr);class gr extends Error{code=6029;name="ProtectedAccount";constructor(){super("Account is protected, it cannot be passed into a CPI as writable"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,gr)}}j.set(6029,()=>new gr);Z.set("ProtectedAccount",()=>new gr);class pr extends Error{code=6030;name="TimeLockExceedsMaxAllowed";constructor(){super("Time lock exceeds the maximum allowed (90 days)"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,pr)}}j.set(6030,()=>new pr);Z.set("TimeLockExceedsMaxAllowed",()=>new pr);class mr extends Error{code=6031;name="IllegalAccountOwner";constructor(){super("Account is not owned by Multisig program"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,mr)}}j.set(6031,()=>new mr);Z.set("IllegalAccountOwner",()=>new mr);class yr extends Error{code=6032;name="RentReclamationDisabled";constructor(){super("Rent reclamation is disabled for this multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,yr)}}j.set(6032,()=>new yr);Z.set("RentReclamationDisabled",()=>new yr);class br extends Error{code=6033;name="InvalidRentCollector";constructor(){super("Invalid rent collector address"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,br)}}j.set(6033,()=>new br);Z.set("InvalidRentCollector",()=>new br);class wr extends Error{code=6034;name="ProposalForAnotherMultisig";constructor(){super("Proposal is for another multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,wr)}}j.set(6034,()=>new wr);Z.set("ProposalForAnotherMultisig",()=>new wr);class xr extends Error{code=6035;name="TransactionForAnotherMultisig";constructor(){super("Transaction is for another multisig"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,xr)}}j.set(6035,()=>new xr);Z.set("TransactionForAnotherMultisig",()=>new xr);class Sr extends Error{code=6036;name="TransactionNotMatchingProposal";constructor(){super("Transaction doesn't match proposal"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Sr)}}j.set(6036,()=>new Sr);Z.set("TransactionNotMatchingProposal",()=>new Sr);class Ar extends Error{code=6037;name="TransactionNotLastInBatch";constructor(){super("Transaction is not last in batch"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ar)}}j.set(6037,()=>new Ar);Z.set("TransactionNotLastInBatch",()=>new Ar);class kr extends Error{code=6038;name="BatchNotEmpty";constructor(){super("Batch is not empty"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,kr)}}j.set(6038,()=>new kr);Z.set("BatchNotEmpty",()=>new kr);class Ir extends Error{code=6039;name="SpendingLimitInvalidAmount";constructor(){super("Invalid SpendingLimit amount"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,Ir)}}j.set(6039,()=>new Ir);Z.set("SpendingLimitInvalidAmount",()=>new Ir);function Pa(n){const t=j.get(n);return t!=null?t():null}new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"BatchAccountsCloseInstructionArgs");const Fa=new a.FixableBeetArgsStruct([["ephemeralSigners",a.u8],["transactionMessage",a.bytes]],"BatchAddTransactionArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Fa]],"BatchAddTransactionInstructionArgs");const Da=new a.FixableBeetArgsStruct([["vaultIndex",a.u8],["memo",a.coption(a.utf8String)]],"BatchCreateArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Da]],"BatchCreateInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"BatchExecuteTransactionInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"ConfigTransactionAccountsCloseInstructionArgs");const Na=new a.FixableBeetArgsStruct([["actions",a.array(Mo)],["memo",a.coption(a.utf8String)]],"ConfigTransactionCreateArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Na]],"ConfigTransactionCreateInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"ConfigTransactionExecuteInstructionArgs");const qa=new a.FixableBeetArgsStruct([["newMember",an],["memo",a.coption(a.utf8String)]],"MultisigAddMemberArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",qa]],"MultisigAddMemberInstructionArgs");const $a=new a.FixableBeetArgsStruct([["createKey",P.publicKey],["vaultIndex",a.u8],["mint",P.publicKey],["amount",a.u64],["period",is],["members",a.array(P.publicKey)],["destinations",a.array(P.publicKey)],["memo",a.coption(a.utf8String)]],"MultisigAddSpendingLimitArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",$a]],"MultisigAddSpendingLimitInstructionArgs");const Ua=new a.FixableBeetArgsStruct([["newThreshold",a.u16],["memo",a.coption(a.utf8String)]],"MultisigChangeThresholdArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Ua]],"MultisigChangeThresholdInstructionArgs");const Oa=new a.FixableBeetArgsStruct([["configAuthority",a.coption(P.publicKey)],["threshold",a.u16],["members",a.array(an)],["timeLock",a.u32],["memo",a.coption(a.utf8String)]],"MultisigCreateArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Oa]],"MultisigCreateInstructionArgs");const Ha=new a.FixableBeetArgsStruct([["configAuthority",a.coption(P.publicKey)],["threshold",a.u16],["members",a.array(an)],["timeLock",a.u32],["rentCollector",a.coption(P.publicKey)],["memo",a.coption(a.utf8String)]],"MultisigCreateArgsV2");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Ha]],"MultisigCreateV2InstructionArgs");const Wa=new a.FixableBeetArgsStruct([["oldMember",P.publicKey],["memo",a.coption(a.utf8String)]],"MultisigRemoveMemberArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Wa]],"MultisigRemoveMemberInstructionArgs");const Va=new a.FixableBeetArgsStruct([["memo",a.coption(a.utf8String)]],"MultisigRemoveSpendingLimitArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Va]],"MultisigRemoveSpendingLimitInstructionArgs");const ja=new a.FixableBeetArgsStruct([["configAuthority",P.publicKey],["memo",a.coption(a.utf8String)]],"MultisigSetConfigAuthorityArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",ja]],"MultisigSetConfigAuthorityInstructionArgs");const Ga=new a.FixableBeetArgsStruct([["rentCollector",a.coption(P.publicKey)],["memo",a.coption(a.utf8String)]],"MultisigSetRentCollectorArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Ga]],"MultisigSetRentCollectorInstructionArgs");const Za=new a.FixableBeetArgsStruct([["timeLock",a.u32],["memo",a.coption(a.utf8String)]],"MultisigSetTimeLockArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Za]],"MultisigSetTimeLockInstructionArgs");const Ya=new a.BeetArgsStruct([["authority",P.publicKey],["multisigCreationFee",a.u64],["treasury",P.publicKey]],"ProgramConfigInitArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Ya]],"ProgramConfigInitInstructionArgs");const Qa=new a.BeetArgsStruct([["newAuthority",P.publicKey]],"ProgramConfigSetAuthorityArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Qa]],"ProgramConfigSetAuthorityInstructionArgs");const Xa=new a.BeetArgsStruct([["newMultisigCreationFee",a.u64]],"ProgramConfigSetMultisigCreationFeeArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Xa]],"ProgramConfigSetMultisigCreationFeeInstructionArgs");const Ja=new a.BeetArgsStruct([["newTreasury",P.publicKey]],"ProgramConfigSetTreasuryArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",Ja]],"ProgramConfigSetTreasuryInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"ProposalActivateInstructionArgs");const cs=new a.FixableBeetArgsStruct([["memo",a.coption(a.utf8String)]],"ProposalVoteArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",cs]],"ProposalApproveInstructionArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",cs]],"ProposalCancelInstructionArgs");const tu=new a.BeetArgsStruct([["transactionIndex",a.u64],["draft",a.bool]],"ProposalCreateArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",tu]],"ProposalCreateInstructionArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",cs]],"ProposalRejectInstructionArgs");const eu=new a.FixableBeetArgsStruct([["amount",a.u64],["decimals",a.u8],["memo",a.coption(a.utf8String)]],"SpendingLimitUseArgs");new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",eu]],"SpendingLimitUseInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"VaultBatchTransactionAccountCloseInstructionArgs");new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"VaultTransactionAccountsCloseInstructionArgs");const nu=new a.FixableBeetArgsStruct([["vaultIndex",a.u8],["ephemeralSigners",a.u8],["transactionMessage",a.bytes],["memo",a.coption(a.utf8String)]],"VaultTransactionCreateArgs"),ru=new a.FixableBeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)],["args",nu]],"VaultTransactionCreateInstructionArgs"),su=[48,250,78,168,208,226,218,211];function ou(n,t,e=new R("SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf")){const[r]=ru.serialize({instructionDiscriminator:su,...t}),s=[{pubkey:n.multisig,isWritable:!0,isSigner:!1},{pubkey:n.transaction,isWritable:!0,isSigner:!1},{pubkey:n.creator,isWritable:!1,isSigner:!0},{pubkey:n.rentPayer,isWritable:!0,isSigner:!0},{pubkey:n.systemProgram??en.programId,isWritable:!1,isSigner:!1}];if(n.anchorRemainingAccounts!=null)for(const i of n.anchorRemainingAccounts)s.push(i);return new Nt({programId:e,keys:s,data:r})}new a.BeetArgsStruct([["instructionDiscriminator",a.uniformFixedSizeArray(a.u8,8)]],"VaultTransactionExecuteInstructionArgs");var Or;(function(n){n[n.Approve=0]="Approve",n[n.Reject=1]="Reject",n[n.Cancel=2]="Cancel"})(Or||(Or={}));a.fixedScalarEnum(Or);const iu="SQDS4ep65T869zMMBKyuUq6aD6EgTu8psMjkvj52pCf",as=new R(iu);oi.initCusper(Pa);var cu=function(n,t,e,r,s,o,i,u){if(!n){var c;if(t===void 0)c=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var l=[e,r,s,o,i,u],d=0;c=new Error(t.replace(/%s/g,function(){return l[d++]})),c.name="Invariant Violation"}throw c.framesToPop=1,c}},Ln=cu;function Ws(n,t,e){const r=t.length,s=r===0?"<EMPTY>":t[0].description;return{write:function(o,i,u){Ln(u.length===r,`array length ${u.length} should match len ${r}`),n.write(o,i,r);let c=i+n.byteSize;for(let l=0;l<r;l++){const d=t[l];d.write(o,c,u[l]),c+=d.byteSize}},read:function(o,i){const u=n.read(o,i);Ln(u===r,"invalid byte size");let c=i+n.byteSize;const l=new Array(r);for(let d=0;d<r;d++){const f=t[d];l[d]=f.read(o,c),c+=f.byteSize}return l},byteSize:n.byteSize+e,length:r,description:`Array<${s}>(${r})[ ${n.byteSize} + ${e} ]`}}function Te(n,t){return{toFixedFromData(e,r){const s=n.read(e,r),o=r+n.byteSize;let i=o;const u=new Array(s);for(let c=0;c<s;c++){const l=a.fixBeetFromData(t,e,i);u[c]=l,i+=l.byteSize}return Ws(n,u,i-o)},toFixedFromValue(e){Ln(Array.isArray(e),`${e} should be an array`);let r=0;const s=new Array(e.length);for(let o=0;o<e.length;o++){const i=a.fixBeetFromValue(t,e[o]);s[o]=i,r+=i.byteSize}return Ws(n,s,r)},description:"smallArray"}}const au=new a.FixableBeetArgsStruct([["programIdIndex",a.u8],["accountIndexes",Te(a.u8,a.u8)],["data",Te(a.u16,a.u8)]],"CompiledMsInstruction"),uu=new a.FixableBeetArgsStruct([["accountKey",P.publicKey],["writableIndexes",Te(a.u8,a.u8)],["readonlyIndexes",Te(a.u8,a.u8)]],"MessageAddressTableLookup"),lu=new a.FixableBeetArgsStruct([["numSigners",a.u8],["numWritableSigners",a.u8],["numWritableNonSigners",a.u8],["accountKeys",Te(a.u8,P.publicKey)],["instructions",Te(a.u8,au)],["addressTableLookups",Te(a.u8,uu)]],"TransactionMessage");class us{payer;keyMetaMap;constructor(t,e){this.payer=t,this.keyMetaMap=e}static compile(t,e){const r=new Map,s=i=>{const u=i.toBase58();let c=r.get(u);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},r.set(u,c)),c},o=s(e);o.isSigner=!0,o.isWritable=!0;for(const i of t){s(i.programId).isInvoked=!1;for(const u of i.keys){const c=s(u.pubkey);c.isSigner||=u.isSigner,c.isWritable||=u.isWritable}}return new us(e,r)}getMessageComponents(){const t=[...this.keyMetaMap.entries()];ln(t.length<=256,"Max static account keys length exceeded");const e=t.filter(([,c])=>c.isSigner&&c.isWritable),r=t.filter(([,c])=>c.isSigner&&!c.isWritable),s=t.filter(([,c])=>!c.isSigner&&c.isWritable),o=t.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:e.length+r.length,numReadonlySignedAccounts:r.length,numReadonlyUnsignedAccounts:o.length};{ln(e.length>0,"Expected at least one writable signer key");const[c]=e[0];ln(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const u=[...e.map(([c])=>new R(c)),...r.map(([c])=>new R(c)),...s.map(([c])=>new R(c)),...o.map(([c])=>new R(c))];return[i,u]}extractTableLookup(t){const[e,r]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[s,o]=this.drainKeysFoundInLookupTable(t.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(e.length===0&&s.length===0))return[{accountKey:t.key,writableIndexes:e,readonlyIndexes:s},{writable:r,readonly:o}]}drainKeysFoundInLookupTable(t,e){const r=new Array,s=new Array;for(const[o,i]of this.keyMetaMap.entries())if(e(i)){const u=new R(o),c=t.findIndex(l=>l.equals(u));c>=0&&(ln(c<256,"Max lookup table index exceeded"),r.push(c),s.push(u),this.keyMetaMap.delete(o))}return[r,s]}}function du({payerKey:n,recentBlockhash:t,instructions:e,addressLookupTableAccounts:r}){const s=us.compile(e,n),o=new Array,i={writable:[],readonly:[]},u=r||[];for(const S of u){const I=s.extractTableLookup(S);if(I!==void 0){const[b,{writable:h,readonly:p}]=I;o.push(b),i.writable.push(...h),i.readonly.push(...p)}}const[c,l]=s.getMessageComponents(),f=new Je(l,i).compileInstructions(e);return new vn({header:c,staticAccountKeys:l,recentBlockhash:t,compiledInstructions:f,addressTableLookups:o})}function ce(n){return new TextEncoder().encode(n)}function fu(n){const t=V.Buffer.alloc(1);return a.u8.write(t,0,n),t}function hu(n){const t=V.Buffer.alloc(8);return a.u64.write(t,0,n),t}function gu({message:n,addressLookupTableAccounts:t,vaultPda:e}){const r=du({payerKey:n.payerKey,recentBlockhash:n.recentBlockhash,instructions:n.instructions,addressLookupTableAccounts:t}),[s]=lu.serialize({numSigners:r.header.numRequiredSignatures,numWritableSigners:r.header.numRequiredSignatures-r.header.numReadonlySignedAccounts,numWritableNonSigners:r.staticAccountKeys.length-r.header.numRequiredSignatures-r.header.numReadonlyUnsignedAccounts,accountKeys:r.staticAccountKeys,instructions:r.compiledInstructions.map(o=>({programIdIndex:o.programIdIndex,accountIndexes:o.accountKeyIndexes,data:Array.from(o.data)})),addressTableLookups:r.addressTableLookups});return s}const Ko=ce("multisig");ce("program_config");ce("multisig");const pu=ce("vault"),mu=ce("transaction");ce("proposal");ce("batch_transaction");ce("ephemeral_signer");ce("spending_limit");function Hr({multisigPda:n,index:t,programId:e=as}){return Ln(t>=0&&t<256,"Invalid vault index"),R.findProgramAddressSync([Ko,n.toBytes(),pu,fu(t)],e)}function yu({multisigPda:n,index:t,programId:e=as}){return R.findProgramAddressSync([Ko,n.toBytes(),mu,hu(t)],e)}function bu({multisigPda:n,transactionIndex:t,creator:e,rentPayer:r,vaultIndex:s,ephemeralSigners:o,transactionMessage:i,addressLookupTableAccounts:u,memo:c,programId:l=as}){const[d]=Hr({multisigPda:n,index:s,programId:l}),[f]=yu({multisigPda:n,index:t,programId:l}),S=gu({message:i,addressLookupTableAccounts:u,vaultPda:d});return ou({multisig:n,transaction:f,creator:e,rentPayer:r??e},{args:{vaultIndex:s,ephemeralSigners:o,transactionMessage:S,memo:c??null}},l)}const Ke="[ATLAS-LOCKER] ",Po=8,ge=new Jt("ATLASXmbPQxBUYbxPsV97usA3fPQYEqzQBUHgiFCUsXx"),Ze=new Jt("poLisWXnNRwC6oBu1vHiuKQzFjGL4XDSu4g9qjz9qVk"),Xt=new Jt("ATLocKpzDbTokxgvnLew3d7drZkEzLzDpzwgrgWKDbmc"),Vs=new Jt("ATLkZsBofSKG845dNFpNoUyMciGpeH29BCbMqYFUoxzU"),F=Xo("globalStarAtlasLockerStore",{state:()=>({multisigPDA:Jo("multisigPDA",""),vaultPDA:{},multisigInfo:{},registeredStakeAtlas:{},registeredStakePolis:{},stakingAccountAtlas:{},stakingAccountAtlasInfo:{},atlas_balance_wallet:"0",polis_balance_wallet:"0",atlas_balance_squads:"0",polis_balance_squads:"0",atlas_balance_locker:"0",polis_balance_locker:"0"}),getters:{getMultisigPDA(n){return new Jt(n.multisigPDA)},getVaultPDA(){try{const[n]=Hr({multisigPda:new Jt(this.multisigPDA),index:0});return n}catch{return""}},getNewTransactionIndex(n){const t=Number(n.multisigInfo.transactionIndex);return BigInt(t+1)}},actions:{async setAccounts(){F().atlas_balance_wallet="0",F().polis_balance_wallet="0",F().atlas_balance_squads="0",F().polis_balance_squads="0",F().atlas_balance_locker="0",F().polis_balance_locker="0",F().stakingAccountAtlasInfo=void 0;const[n]=Hr({multisigPda:new Jt(this.multisigPDA),index:0});this.vaultPDA=n,this.multisigInfo=await he.fromAccountAddress(Et().connection,new Jt(this.multisigPDA));const[t]=await Yt.getRegisteredStake(Xt,Vs,ge,Ze);this.registeredStakeAtlas=t;const[e]=await Yt.getRegisteredStake(Xt,Vs,ge,Ze);this.registeredStakePolis=e;try{const[r]=await Yt.getStakingAccount(Xt,this.vaultPDA,this.registeredStakeAtlas);this.stakingAccountAtlas=r}catch{}try{this.stakingAccountAtlasInfo=await Yt.getStakingAccountInfo(Et().connection,this.stakingAccountAtlas,Xt)}catch{}await wu()},async build_CreateStatingAccount(){const n=await Yt.createStakingAccountInstruction({connection:Et().connection,user:this.vaultPDA,registeredStake:this.registeredStakeAtlas,programId:Xt});await Pe(Ke+"CreateStatingAccount: "+ii,[n.instructions[0]])},async build_StakeTokens(n){const[t]=Jt.findProgramAddressSync([this.vaultPDA.toBuffer(),ui.toBuffer(),ge.toBuffer()],ai.ASSOCIATED_PROGRAM_ID),e=await Yt.stakeTokensInstruction({connection:Et().connection,user:this.vaultPDA,stakeMint:ge,tokenSource:t,stakingAccount:this.stakingAccountAtlas,stakeQuantity:new Kr(parseFloat(n.toString())*Math.pow(10,Po)),registeredStake:this.registeredStakeAtlas,programId:Xt});await Pe(Ke+"StakeTokens: "+n,[e.instructions[0]])},async build_harvestRewards(){const n=await Yt.harvestRewardsInstruction({connection:Et().connection,user:this.vaultPDA,rewardMint:Ze,registeredStake:this.registeredStakeAtlas,stakingAccount:this.stakingAccountAtlas,programId:Xt});await Pe(Ke+"HarvestRewards",[n.instructions[0]])},async build_withdrawTokens(){const n=await Yt.withdrawTokensInstruction({connection:Et().connection,user:this.vaultPDA,authority:this.vaultPDA,stakeMint:ge,registeredStake:this.registeredStakeAtlas,stakingAccount:this.stakingAccountAtlas,programId:Xt});await Pe(Ke+"WithdrawTokens",[n.instructions[0]])},async build_unstakeTokens(){const n=await Yt.unstakeTokensInstruction({connection:Et().connection,user:this.vaultPDA,registeredStake:this.registeredStakeAtlas,stakingAccount:this.stakingAccountAtlas,programId:Xt});await Pe(Ke+"UnstakeTokens",[n.instructions[0]])},async build_cancelUnstake(){const n=await Yt.cancelUnstakeInstruction({connection:Et().connection,user:this.vaultPDA,registeredStake:this.registeredStakeAtlas,programId:Xt});await Pe(Ke+"CancelUnstake",[n.instructions[0]])}}});async function Pe(n,t){const{sendTransaction:e,publicKey:r}=zn(),s=new ti({payerKey:F().vaultPDA,recentBlockhash:(await Et().connection.getLatestBlockhash()).blockhash,instructions:t}),o=bu({multisigPda:new Jt(F().multisigPDA),transactionIndex:F().getNewTransactionIndex,creator:r.value,vaultIndex:0,ephemeralSigners:0,transactionMessage:s,memo:n});console.log("build: "+n);const i=await e(new ei().add(o),Et().connection);await ci(i)}async function wu(){const{publicKey:n}=zn();if(!n.value)return;const t=await Ge(ge,n.value),e=await Ge(Ze,n.value),r=await Ge(ge,F().vaultPDA,!0),s=await Ge(Ze,F().vaultPDA,!0),o=await Ge(ge,F().stakingAccountAtlas,!0);try{F().atlas_balance_wallet=(await Et().connection.getTokenAccountBalance(t)).value.uiAmountString??"0"}catch{F().atlas_balance_wallet="-"}try{F().polis_balance_wallet=(await Et().connection.getTokenAccountBalance(e)).value.uiAmountString??"0"}catch{F().polis_balance_wallet="-"}try{F().atlas_balance_squads=(await Et().connection.getTokenAccountBalance(r)).value.uiAmountString??"0"}catch{F().atlas_balance_squads="-"}try{F().polis_balance_squads=(await Et().connection.getTokenAccountBalance(s)).value.uiAmountString??"0"}catch{F().polis_balance_squads="-"}try{F().atlas_balance_locker=(await Et().connection.getTokenAccountBalance(o)).value.uiAmountString??""}catch{F().atlas_balance_locker="-"}}const xu=w("div",{class:"text-h6 text-weight-thin"}," This Tool is build for easy interaction between StarAtlasLockers using a Squads.so multi signature account! ",-1),Su=w("div",{class:"text-subtitle1"}," Please enter the required information so send instructions to your Squads Account ",-1),Au=w("div",{class:"text-subtitle2 text-weight-thin text-orange-5"}," You will still need to approve the transaction in you squads account! ",-1),ku={class:"row q-gutter-x-sm items-center"},Iu={class:"col"},Bu=w("div",{class:"col text-weight-light"}," Squads.so -> Settings -> Multisig Account ",-1),vu={class:"row q-gutter-x-sm items-center"},Eu={class:"col"},Tu=w("div",{class:"col text-weight-light"},"Your Squads Account",-1),_u={class:"row items-center"},Lu=w("div",{class:"text-subtitle1"},"Squads Multisig Info",-1),zu={key:0},Ru=w("div",{class:"text-subtitle2"},"Members",-1),Mu=w("div",{class:"row"},[w("div",{class:"col"},"Member Address"),w("div",null,"Permission")],-1),Cu={class:"row"},Ku={class:"col"},Pu=Rn({__name:"SetupLockerView",setup(n){return(t,e)=>(ht(),oe(Wr,{flat:""},{default:At(()=>[tt(pe,null,{default:At(()=>[xu]),_:1}),tt(pe,null,{default:At(()=>[Su,Au]),_:1}),tt(pe,{class:"q-gutter-y-sm"},{default:At(()=>[w("div",ku,[w("div",Iu,[tt(Cr,{dense:"",standout:"",modelValue:rt(F)().multisigPDA,"onUpdate:modelValue":e[0]||(e[0]=r=>rt(F)().multisigPDA=r),label:"MultisigPDA"},null,8,["modelValue"])]),Bu]),w("div",vu,[w("div",Eu,[tt(Cr,{disable:"",dense:"",standout:"",modelValue:rt(F)().getVaultPDA,"onUpdate:modelValue":e[1]||(e[1]=r=>rt(F)().getVaultPDA=r),label:"VaultPDA"},null,8,["modelValue"])]),Tu])]),_:1}),tt(pe,null,{default:At(()=>{var r,s;return[w("div",_u,[Lu,tt(Vo),tt(ye,{square:"",color:"primary",label:"Update Squads info",onClick:e[2]||(e[2]=o=>rt(F)().setAccounts())})]),(s=(r=rt(F)().multisigInfo)==null?void 0:r.members)!=null&&s.length?(ht(),Kt("div",zu,[Ru,tt(si,{dense:"",bordered:"",padding:"",class:"rounded-borders"},{default:At(()=>[ys((ht(),oe(ws,null,{default:At(()=>[tt(xs,null,{default:At(()=>[Mu]),_:1})]),_:1})),[[bs]]),(ht(!0),Kt(Gs,null,Zs(rt(F)().multisigInfo.members,o=>ys((ht(),oe(ws,{clickable:"",key:o.key},{default:At(()=>[tt(xs,null,{default:At(()=>[w("div",Cu,[w("div",Ku,Tt(o.key),1),w("div",null,Tt(o.permissions.mask),1)])]),_:2},1024)]),_:2},1024)),[[bs]])),128))]),_:1})])):An("",!0)]}),_:1})]),_:1}))}}),Fu={class:"row"},Du={class:"col-1"},Nu={class:"col"},qu={class:"row q-pr-md items-center"},$u=w("div",{class:"col text-right text-subtitle2 text-weight-light"},[w("div",null,"Squads Vault Account")],-1),Uu={class:"col text-right text-subtitle1"},Ou={class:"row q-pr-md items-center"},Hu=w("div",{class:"col text-right text-subtitle2 text-weight-light"},[w("div",null,"Squads Registered Stake")],-1),Wu={class:"col text-right text-subtitle1"},Vu={class:"row q-pr-md items-center"},ju=w("div",{class:"col text-right text-subtitle2 text-weight-light"},[w("div",null,"Squads Staking Account")],-1),Gu={class:"col text-right text-subtitle1"},Zu=w("div",{class:"row items-center q-mx-md"},[w("div",{class:"col"},[w("div",{class:"text-h4"},"Instruction")]),w("div",{class:"col-4"},[w("div",{class:"text-h4 text-center"},"Action")])],-1),Yu={class:"row items-center q-mx-md"},Qu=w("div",{class:"col"},[w("div",{class:"text-h6"},"Create Staking Account"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will create a new locker instance for you ")],-1),Xu={class:"col-4"},Ju={class:"row items-center q-mx-md"},tl=w("div",{class:"col"},[w("div",{class:"text-h6"},"Stake Tokens"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will stake additional tokens ")],-1),el={class:"col-4"},nl={class:"row q-gutter-x-xs"},rl={class:"row items-center q-mx-md"},sl=w("div",{class:"col"},[w("div",{class:"col text-h6"},"Harvest"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will claim your rewards ")],-1),ol={class:"col-4"},il={class:"row items-center q-mx-md"},cl=w("div",{class:"col"},[w("div",{class:"text-h6"},"Unstake Tokens"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will initiate unstake of all tokens ")],-1),al={class:"col-4"},ul={class:"row items-center q-mx-md"},ll=w("div",{class:"col"},[w("div",{class:"text-h6"},"Cancel Unstake"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will cancel unstake of all tokens ")],-1),dl={class:"col-4"},fl={class:"row items-center q-mx-md"},hl=w("div",{class:"col"},[w("div",{class:"text-h6"},"Withdraw Tokens"),w("div",{class:"text-subtitle2 text-weight-light"}," This instruction will withdraw of all tokens after unstake ")],-1),gl={class:"col-4"},pl={class:"row items-center"},ml=w("div",{class:"col-1 text-h5"},"Locker Info",-1),yl={key:0,class:"col"},bl={class:"col text-right text-subtitle2 text-weight-light"},wl={class:"col text-right text-subtitle1"},xl={key:0},Sl={key:1},Al={key:0},kl={key:1},Il={key:2},Bl={key:1,class:"text-subtitle2 text-center"},vl=Rn({__name:"AtlasLockerView",setup(n){const t=Ys(0);return Qs(async()=>{await F().setAccounts()}),(e,r)=>(ht(),oe(Wr,{flat:""},{default:At(()=>[tt(pe,null,{default:At(()=>[w("div",Fu,[w("div",Du,[tt(li,{src:"/currencies/ATLAS.webp"})]),tt(dn,{class:"q-mx-sm",vertical:""}),w("div",Nu,[w("div",qu,[$u,w("div",Uu,[w("div",null,Tt(rt(F)().vaultPDA),1)])]),w("div",Ou,[Hu,w("div",Wu,[w("div",null,Tt(rt(F)().registeredStakeAtlas),1)])]),w("div",Vu,[ju,w("div",Gu,[w("div",null,Tt(rt(F)().stakingAccountAtlas),1)])])])])]),_:1}),tt(pe,null,{default:At(()=>[Zu,tt(dn,{class:"q-my-sm"}),w("div",Yu,[Qu,w("div",Xu,[tt(ye,{class:"full-width",square:"",label:"Sign",color:"primary",onClick:r[0]||(r[0]=s=>rt(F)().build_CreateStatingAccount())})])]),w("div",Ju,[tl,w("div",el,[w("div",nl,[tt(Cr,{dense:"",square:"",class:"col",standout:"",type:"number",modelValue:t.value,"onUpdate:modelValue":r[1]||(r[1]=s=>t.value=s),label:"Amount to stake"},null,8,["modelValue"]),tt(ye,{square:"",class:"col-3",label:"Sign",color:"primary",onClick:r[2]||(r[2]=s=>rt(F)().build_StakeTokens(t.value))})])])]),w("div",rl,[sl,w("div",ol,[tt(ye,{class:"full-width",label:"Sign",color:"primary",onClick:r[3]||(r[3]=s=>rt(F)().build_harvestRewards())})])]),w("div",il,[cl,w("div",al,[tt(ye,{class:"full-width",label:"Sign",color:"primary",onClick:r[4]||(r[4]=s=>rt(F)().build_unstakeTokens())})])]),w("div",ul,[ll,w("div",dl,[tt(ye,{class:"full-width",label:"Sign",color:"primary"})])]),w("div",fl,[hl,w("div",gl,[tt(ye,{class:"full-width",label:"Sign",color:"primary",onClick:r[5]||(r[5]=s=>rt(F)().build_withdrawTokens())})])])]),_:1}),tt(pe,null,{default:At(()=>[tt(dn,{class:"q-my-sm"}),w("div",pl,[ml,tt(dn,{class:"q-mx-sm",vertical:""}),rt(F)().stakingAccountAtlasInfo?(ht(),Kt("div",yl,[(ht(!0),Kt(Gs,null,Zs(Object.keys(rt(F)().stakingAccountAtlasInfo),(s,o)=>(ht(),Kt("div",{class:"row q-pr-md items-center",key:o},[w("div",bl,[w("div",null,Tt(s),1)]),w("div",wl,[["totalStake","activeStake","paidRewards","pendingRewards"].includes(s)?(ht(),Kt("div",xl,Tt(parseInt(rt(F)().stakingAccountAtlasInfo[s])*Math.pow(10,-rt(Po))),1)):["stakedAtTs","lastPendingRewardCalcTs","lastHarvestTs","unstakedTs"].includes(s)?(ht(),Kt("div",Sl,[parseInt(rt(F)().stakingAccountAtlasInfo[s])==0?(ht(),Kt("div",Al," - ")):(ht(),Kt("div",kl,Tt(new Date(parseInt(rt(F)().stakingAccountAtlasInfo[s])*1e3).toLocaleString()),1))])):(ht(),Kt("div",Il,Tt(rt(F)().stakingAccountAtlasInfo[s]),1))])]))),128))])):(ht(),Kt("div",Bl,"No Locker found!"))])]),_:1})]),_:1}))}}),El={};function Tl(n,t){return"!Under construction!"}var _l=di(El,[["render",Tl]]);const Ll={class:"row"},zl=w("div",{class:"col-3"},"Wallet",-1),Rl={class:"col"},Ml={class:"row q-gutter-x-xs no-wrap justify-end"},Cl=w("div",null,"Atlas",-1),Kl={class:"col"},Pl={class:"row q-gutter-x-xs no-wrap justify-end"},Fl=w("div",null,"Polis",-1),Dl={class:"row"},Nl=w("div",{class:"col-3"},"Squads",-1),ql={class:"col"},$l={class:"row q-gutter-x-xs no-wrap justify-end"},Ul=w("div",null,"Atlas",-1),Ol={class:"col"},Hl={class:"row q-gutter-x-xs no-wrap justify-end"},Wl=w("div",null,"Polis",-1),Vl={class:"row"},jl=w("div",{class:"col-3"},"Locker",-1),Gl={class:"col"},Zl={class:"row q-gutter-x-xs no-wrap justify-end"},Yl=w("div",null,"Atlas",-1),Ql={class:"col"},Xl={class:"row q-gutter-x-xs no-wrap justify-end"},Jl=w("div",null,"Polis",-1),td=Rn({__name:"TokenLockerBalances",setup(n){return Qs(async()=>{await F().setAccounts()}),ni(()=>zn().publicKey.value,async()=>{await F().setAccounts()}),(t,e)=>(ht(),oe(Wr,{class:""},{default:At(()=>[tt(pe,null,{default:At(()=>[w("div",Ll,[zl,w("div",Rl,[w("div",Ml,[w("div",null,Tt(rt(F)().atlas_balance_wallet),1),Cl])]),w("div",Kl,[w("div",Pl,[w("div",null,Tt(rt(F)().polis_balance_wallet),1),Fl])])]),w("div",Dl,[Nl,w("div",ql,[w("div",$l,[w("div",null,Tt(rt(F)().atlas_balance_squads),1),Ul])]),w("div",Ol,[w("div",Hl,[w("div",null,Tt(rt(F)().polis_balance_squads),1),Wl])])]),w("div",Vl,[jl,w("div",Gl,[w("div",Zl,[w("div",null,Tt(rt(F)().atlas_balance_locker),1),Yl])]),w("div",Ql,[w("div",Xl,[w("div",null,Tt(rt(F)().polis_balance_locker),1),Jl])])])]),_:1})]),_:1}))}}),ed={key:0,class:"col absolute-center"},nd={key:1},rd=w("div",{class:"col"},null,-1),kd=Rn({__name:"StarAtlasLocker",setup(n){const t=Ys("setup");return(e,r)=>(ht(),oe(Wo,{class:"bg-black"},{default:At(()=>{var s,o;return[(o=(s=rt(zn)().publicKey)==null?void 0:s.value)!=null&&o.toString()?(ht(),Kt("div",nd,[tt(Ho,{modelValue:t.value,"onUpdate:modelValue":r[0]||(r[0]=i=>t.value=i),align:"left",class:""},{default:At(()=>[tt(vr,{name:"setup",label:"Setup"}),tt(vr,{name:"atlas",label:"Atlas"}),tt(vr,{name:"polis",label:"Polis"}),rd,tt(td,{class:"q-pr-md col"})]),_:1},8,["modelValue"]),t.value=="setup"?(ht(),oe(Pu,{key:0})):An("",!0),t.value=="atlas"?(ht(),oe(vl,{key:1})):An("",!0),t.value=="polis"?(ht(),oe(_l,{key:2})):An("",!0)])):(ht(),Kt("div",ed,[tt(rt(ri),{dark:""})]))]}),_:1}))}});export{kd as default};
