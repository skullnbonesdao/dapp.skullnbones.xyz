import{u as n}from"./SquadsStore.074a7ae1.js";import{P as o,cN as i,dd as h,cn as a,de as p,da as m}from"./index.4796aa65.js";import"./pda.7d3c6642.js";import"./assert.7b0088ad.js";import{v as f}from"./vaultTransactionCreate.45690309.js";function S(){return n().useSquads?new o(n().vaultPDA):i().publicKey.value??new o("")}const T=async(s,r="Unlabeled transaction")=>{const{sendTransaction:c}=i(),e=h.create({group:!1,timeout:0,spinner:!0,message:r,caption:"...",position:"bottom-right"});try{e({caption:"Waiting for user to sign..."});let t="";if(!n().useSquads)t=await c(s,a().connection);else{const u=await a().connection.getRecentBlockhash(),g=new p({payerKey:new o(n().vaultPDA),recentBlockhash:u.blockhash,instructions:s.instructions});await n().loadMultisigInfo();const d=f({multisigPda:new o(n().multisigPDA),transactionIndex:n().getNewTransactionIndex,creator:i().publicKey.value,vaultIndex:0,ephemeralSigners:0,transactionMessage:g,memo:r});t=await c(new m().add(d),a().connection)}e({caption:`Waiting for confirmation: ${t}`});const l=await a().connection.getLatestBlockhash();return await a().connection.confirmTransaction({blockhash:l.blockhash,lastValidBlockHeight:l.lastValidBlockHeight,signature:t}),e({color:"positive",timeout:5e3,icon:"done",spinner:!1,caption:`Confirmed: ${t}`}),0}catch(t){e({progress:!0,spinner:!1,icon:"error",color:"negative",timeout:5e3,caption:`Error handling transaction: ${t.toString()}`})}};export{S as g,T as h};
