import{u as n}from"./SquadsStore.78a954bd.js";import{P as o,cN as i,dc as h,cn as a,dd as p,d9 as m}from"./index.c6ca1f90.js";import"./pda.386d6c74.js";import"./assert.6afcd24c.js";import{v as f}from"./vaultTransactionCreate.deafa28a.js";function S(){return n().useSquads?new o(n().vaultPDA):i().publicKey.value??new o("")}const T=async(s,c="Unlabeled transaction")=>{const{sendTransaction:r}=i(),e=h.create({group:!1,timeout:0,spinner:!0,message:c,caption:"...",position:"bottom-right"});try{e({caption:"Waiting for user to sign..."});let t="";if(!n().useSquads)t=await r(s,a().connection);else{const u=await a().connection.getRecentBlockhash(),g=new p({payerKey:new o(n().vaultPDA),recentBlockhash:u.blockhash,instructions:s.instructions});await n().loadMultisigInfo();const d=f({multisigPda:new o(n().multisigPDA),transactionIndex:n().getNewTransactionIndex,creator:i().publicKey.value,vaultIndex:0,ephemeralSigners:0,transactionMessage:g,memo:c});t=await r(new m().add(d),a().connection)}e({caption:`Waiting for confirmation: ${t}`});const l=await a().connection.getLatestBlockhash();return await a().connection.confirmTransaction({blockhash:l.blockhash,lastValidBlockHeight:l.lastValidBlockHeight,signature:t}),e({color:"positive",timeout:5e3,icon:"done",spinner:!1,caption:`Confirmed: ${t}`}),0}catch(t){e({progress:!0,spinner:!1,icon:"error",color:"negative",timeout:5e3,caption:`Error handling transaction: ${t.toString()}`})}};export{S as g,T as h};
