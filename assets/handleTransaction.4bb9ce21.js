import{cU as r,cT as d,cj as o,cp as n,cV as m,P as l,cP as p}from"./index.e3ff99be.js";import{v as f}from"./vaultTransactionCreate.c9b9fc1a.js";const T=async(i,s="Unlabeled transaction")=>{const{sendTransaction:c}=r(),t=d.create({group:!1,timeout:0,spinner:!0,message:s,position:"bottom-right"});try{t({caption:"Waiting for user to sign..."});let a="";if(!o().useSquads)a=await c(i,n().connection);else{console.log(i.instructions);const g=await n().connection.getLatestBlockhash(),h=new m({payerKey:new l(o().vaultPDA),recentBlockhash:g.blockhash,instructions:i.instructions});await o().loadMultisigInfo();const u=f({multisigPda:new l(o().multisigPDA),transactionIndex:o().getNewTransactionIndex,creator:r().publicKey.value,vaultIndex:0,ephemeralSigners:0,transactionMessage:h,memo:s});a=await c(new p().add(u),n().connection)}t({color:"green-5",message:"[1/2] Waiting for confirmation...",caption:`${a}`});const e=await n().connection.getLatestBlockhash();return await n().connection.confirmTransaction({blockhash:e.blockhash,lastValidBlockHeight:e.lastValidBlockHeight,signature:a},"confirmed"),t({color:"green-8",message:"[2/2]  Waiting for finalization...",caption:`${a}`}),await n().connection.confirmTransaction({blockhash:e.blockhash,lastValidBlockHeight:e.lastValidBlockHeight,signature:a},"finalized"),t({color:"positive",timeout:5e3,icon:"done",spinner:!1,message:"Finalized",caption:`${a}`}),0}catch(a){t({progress:!0,spinner:!1,icon:"error",color:"negative",timeout:5e3,caption:`Error handling transaction: ${a.toString()}`})}};export{T as h};
