import{cR as st,cS as U,P as k,cT as Ot,co as Wt,bX as Bt,cU as Re,d as O,cV as ue,cW as le,cX as Oe,cY as Be,cZ as Ne,cK as de,c_ as xe,c$ as Me}from"./index.cc6cd167.js";import{L as Gt,r as De,u as fe,a as j,s as P,n as z,b as lt,c as bt,o as Ue,d as $e,e as qe,i as Ve}from"./pako.esm.9bbd9f7c.js";var Pt;const at={}.ANCHOR_BROWSER||typeof window<"u"&&!(!((Pt=window.process)===null||Pt===void 0)&&Pt.hasOwnProperty("type"));function je(r,t){return Array.apply(0,new Array(Math.ceil(r.length/t))).map((e,n)=>r.slice(n*t,(n+1)*t))}const rt=r=>"version"in r;function ze(r){return(at?new TextDecoder("utf-8"):new(require("util")).TextDecoder("utf-8")).decode(r)}function Fe(r){return(at?new TextEncoder:new(require("util")).TextEncoder("utf-8")).encode(r)}function Ht(r){return st.encode(r)}function Xt(r){return r.toString("base64")}function he(r){return U.Buffer.from(r,"base64")}function Ke(r){const t=new Map;return r.errors&&r.errors.forEach(e=>{var n;let o=(n=e.msg)!==null&&n!==void 0?n:e.name;t.set(e.code,o)}),t}function We(r,...t){if(r.args.length!=t.length)throw new Error("Invalid argument length");const e={};let n=0;return r.args.forEach(o=>{e[o.name]=t[n],n+=1}),e}function pe(r,t={}){r.forEach(e=>{if("accounts"in e)pe(e.accounts,t[e.name]);else if(t[e.name]===void 0)throw new Error(`Invalid arguments: ${e.name} not provided.`)})}function x(r){return r instanceof k?r:new k(r)}class Ge extends TypeError{constructor(t,e){let n;const{message:o,...s}=t,{path:i}=t,c=i.length===0?o:"At path: "+i.join(".")+" -- "+o;super(c),this.value=void 0,this.key=void 0,this.type=void 0,this.refinement=void 0,this.path=void 0,this.branch=void 0,this.failures=void 0,Object.assign(this,s),this.name=this.constructor.name,this.failures=()=>{var l;return(l=n)!=null?l:n=[t,...e()]}}}function He(r){return tt(r)&&typeof r[Symbol.iterator]=="function"}function tt(r){return typeof r=="object"&&r!=null}function K(r){return typeof r=="string"?JSON.stringify(r):""+r}function Xe(r){const{done:t,value:e}=r.next();return t?void 0:e}function Ze(r,t,e,n){if(r===!0)return;r===!1?r={}:typeof r=="string"&&(r={message:r});const{path:o,branch:s}=t,{type:i}=e,{refinement:c,message:l="Expected a value of type `"+i+"`"+(c?" with refinement `"+c+"`":"")+", but received: `"+K(n)+"`"}=r;return{value:n,type:i,refinement:c,key:o[o.length-1],path:o,branch:s,...r,message:l}}function*Zt(r,t,e,n){He(r)||(r=[r]);for(const o of r){const s=Ze(o,t,e,n);s&&(yield s)}}function*qt(r,t,e){e===void 0&&(e={});const{path:n=[],branch:o=[r],coerce:s=!1,mask:i=!1}=e,c={path:n,branch:o};if(s&&(r=t.coercer(r,c),i&&t.type!=="type"&&tt(t.schema)&&tt(r)&&!Array.isArray(r)))for(const d in r)t.schema[d]===void 0&&delete r[d];let l=!0;for(const d of t.validator(r,c))l=!1,yield[d,void 0];for(let[d,f,v]of t.entries(r,c)){const g=qt(f,v,{path:d===void 0?n:[...n,d],branch:d===void 0?o:[...o,f],coerce:s,mask:i});for(const p of g)p[0]?(l=!1,yield[p[0],void 0]):s&&(f=p[1],d===void 0?r=f:r instanceof Map?r.set(d,f):r instanceof Set?r.add(f):tt(r)&&(r[d]=f))}if(l)for(const d of t.refiner(r,c))l=!1,yield[d,void 0];l&&(yield[void 0,r])}class W{constructor(t){this.TYPE=void 0,this.type=void 0,this.schema=void 0,this.coercer=void 0,this.validator=void 0,this.refiner=void 0,this.entries=void 0;const{type:e,schema:n,validator:o,refiner:s,coercer:i=l=>l,entries:c=function*(){}}=t;this.type=e,this.schema=n,this.entries=c,this.coercer=i,o?this.validator=(l,d)=>{const f=o(l,d);return Zt(f,d,this,l)}:this.validator=()=>[],s?this.refiner=(l,d)=>{const f=s(l,d);return Zt(f,d,this,l)}:this.refiner=()=>[]}assert(t){return Je(t,this)}create(t){return Vt(t,this)}is(t){return me(t,this)}mask(t){return Ye(t,this)}validate(t,e){return e===void 0&&(e={}),dt(t,this,e)}}function Je(r,t){const e=dt(r,t);if(e[0])throw e[0]}function Vt(r,t){const e=dt(r,t,{coerce:!0});if(e[0])throw e[0];return e[1]}function Ye(r,t){const e=dt(r,t,{coerce:!0,mask:!0});if(e[0])throw e[0];return e[1]}function me(r,t){return!dt(r,t)[0]}function dt(r,t,e){e===void 0&&(e={});const n=qt(r,t,e),o=Xe(n);if(o[0])return[new Ge(o[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0];{const s=o[1];return[void 0,s]}}function ft(r,t){return new W({type:r,schema:null,validator:t})}function Qe(){return ft("any",()=>!0)}function kt(r){return new W({type:"array",schema:r,*entries(t){if(r&&Array.isArray(t))for(const[e,n]of t.entries())yield[e,n,r]},coercer(t){return Array.isArray(t)?t.slice():t},validator(t){return Array.isArray(t)||"Expected an array value, but received: "+K(t)}})}function tn(){return ft("boolean",r=>typeof r=="boolean")}function Jt(r){const t=K(r),e=typeof r;return new W({type:"literal",schema:e==="string"||e==="number"||e==="boolean"?r:null,validator(n){return n===r||"Expected the literal `"+t+"`, but received: "+K(n)}})}function mt(r){return new W({...r,validator:(t,e)=>t===null||r.validator(t,e),refiner:(t,e)=>t===null||r.refiner(t,e)})}function gt(){return ft("number",r=>typeof r=="number"&&!isNaN(r)||"Expected a number, but received: "+K(r))}function wt(r){return new W({...r,validator:(t,e)=>t===void 0||r.validator(t,e),refiner:(t,e)=>t===void 0||r.refiner(t,e)})}function H(){return ft("string",r=>typeof r=="string"||"Expected a string, but received: "+K(r))}function F(r){const t=Object.keys(r);return new W({type:"type",schema:r,*entries(e){if(tt(e))for(const n of t)yield[n,e[n],r[n]]},validator(e){return tt(e)||"Expected an object, but received: "+K(e)}})}function ye(r){const t=r.map(e=>e.type).join(" | ");return new W({type:"union",schema:null,coercer(e,n){return(r.find(s=>{const[i]=s.validate(e,{coerce:!0});return!i})||jt()).coercer(e,n)},validator(e,n){const o=[];for(const s of r){const[...i]=qt(e,s,n),[c]=i;if(c[0])for(const[l]of i)l&&o.push(l);else return[]}return["Expected the value to satisfy a union of `"+t+"`, but received: "+K(e),...o]}})}function jt(){return ft("unknown",()=>!0)}function en(r,t,e){return new W({...r,coercer:(n,o)=>me(n,t)?r.coercer(e(n,o),o):r.coercer(n,o)})}const Yt=99;async function nn(r,t,e){if(t.length<=Yt)return await Qt(r,t,e);{const n=je(t,Yt);return(await Promise.all(n.map(s=>Qt(r,s,e)))).flat()}}async function Qt(r,t,e){const n=e??r.commitment,{value:o,context:s}=await r.getMultipleAccountsInfoAndContext(t,n);return o.map((c,l)=>c===null?null:{publicKey:t[l],account:c,context:s})}async function rn(r,t,e,n,o){var s;e&&e.length>0&&t.sign(...e);const i=t._compile(),c=i.serialize(),d=t._serialize(c).toString("base64"),f={encoding:"base64",commitment:n??r.commitment};if(o){const m=(Array.isArray(o)?o:i.nonProgramIds()).map(b=>b.toBase58());f.accounts={encoding:"base64",addresses:m}}e&&(f.sigVerify=!0);const v=[d,f],g=await r._rpcRequest("simulateTransaction",v),p=Vt(g,cn);if("error"in p){let m;if("data"in p.error&&(m=(s=p.error.data)===null||s===void 0?void 0:s.logs,m&&Array.isArray(m))){const b=`
    `,L=b+m.join(b);console.error(p.error.message,L)}throw new Ot("failed to simulate transaction: "+p.error.message,m)}return p.result}function on(r){return en(ge(r),sn,t=>"error"in t?t:{...t,result:Vt(t.result,r)})}const sn=ge(jt());function ge(r){return ye([F({jsonrpc:Jt("2.0"),id:H(),result:r}),F({jsonrpc:Jt("2.0"),id:H(),error:F({code:jt(),message:H(),data:wt(Qe())})})])}function an(r){return on(F({context:F({slot:gt()}),value:r}))}const cn=an(F({err:mt(ye([F({}),H()])),logs:mt(kt(H())),accounts:wt(mt(kt(mt(F({executable:tn(),owner:H(),lamports:gt(),data:kt(H()),rentEpoch:wt(gt())}))))),unitsConsumed:wt(gt())}));class Y{constructor(t,e,n){this.connection=t,this.wallet=e,this.opts=n,this.publicKey=e==null?void 0:e.publicKey}static defaultOptions(){return{preflightCommitment:"processed",commitment:"processed"}}static local(t,e){if(at)throw new Error("Provider local is not available on browser.");e=e??Y.defaultOptions();const n=new Wt(t??"http://localhost:8899",e.preflightCommitment),s=require("./nodewallet.js").default.local();return new Y(n,s,e)}static env(){if(at)throw new Error("Provider env is not available on browser.");require("process");const t={}.ANCHOR_PROVIDER_URL;if(t===void 0)throw new Error("ANCHOR_PROVIDER_URL is not defined");const e=Y.defaultOptions(),n=new Wt(t,e.commitment),s=require("./nodewallet.js").default.local();return new Y(n,s,e)}async sendAndConfirm(t,e,n){var o,s,i,c;if(n===void 0&&(n=this.opts),rt(t))e&&t.sign(e);else if(t.feePayer=(o=t.feePayer)!==null&&o!==void 0?o:this.wallet.publicKey,t.recentBlockhash=(await this.connection.getLatestBlockhash(n.preflightCommitment)).blockhash,e)for(const d of e)t.partialSign(d);t=await this.wallet.signTransaction(t);const l=t.serialize();try{return await te(this.connection,l,n)}catch(d){if(d instanceof Nt){const f=Ht(rt(t)?((s=t.signatures)===null||s===void 0?void 0:s[0])||new Uint8Array:(i=t.signature)!==null&&i!==void 0?i:new Uint8Array),v=await this.connection.getTransaction(f,{commitment:"confirmed"});if(v){const g=(c=v.meta)===null||c===void 0?void 0:c.logMessages;throw g?new Ot(d.message,g):d}else throw d}else throw d}}async sendAll(t,e){var n,o,s;e===void 0&&(e=this.opts);const i=(await this.connection.getLatestBlockhash(e.preflightCommitment)).blockhash;let c=t.map(f=>{var v,g;if(rt(f.tx)){let p=f.tx;return f.signers&&p.sign(f.signers),p}else{let p=f.tx,m=(v=f.signers)!==null&&v!==void 0?v:[];return p.feePayer=(g=p.feePayer)!==null&&g!==void 0?g:this.wallet.publicKey,p.recentBlockhash=i,m.forEach(b=>{p.partialSign(b)}),p}});const l=await this.wallet.signAllTransactions(c),d=[];for(let f=0;f<c.length;f+=1){const v=l[f],g=v.serialize();try{d.push(await te(this.connection,g,e))}catch(p){if(p instanceof Nt){const m=Ht(rt(v)?((n=v.signatures)===null||n===void 0?void 0:n[0])||new Uint8Array:(o=v.signature)!==null&&o!==void 0?o:new Uint8Array),b=await this.connection.getTransaction(m,{commitment:"confirmed"});if(b){const L=(s=b.meta)===null||s===void 0?void 0:s.logMessages;throw L?new Ot(p.message,L):p}else throw p}else throw p}}return d}async simulate(t,e,n,o){let s=(await this.connection.getLatestBlockhash(n??this.connection.commitment)).blockhash,i;if(rt(t)?(e&&(t.sign(e),t=await this.wallet.signTransaction(t)),i=await this.connection.simulateTransaction(t,{commitment:n})):(t.feePayer=t.feePayer||this.wallet.publicKey,t.recentBlockhash=s,e&&(t=await this.wallet.signTransaction(t)),i=await rn(this.connection,t,e,n,o)),i.value.err)throw new un(i.value);return i.value}}class un extends Error{constructor(t,e){super(e),this.simulationResponse=t}}async function te(r,t,e){const n=e&&{skipPreflight:e.skipPreflight,preflightCommitment:e.preflightCommitment||e.commitment},o=await r.sendRawTransaction(t,n),s=(await r.confirmTransaction(o,e&&e.commitment)).value;if(s.err)throw new Nt(`Raw transaction ${o} failed (${JSON.stringify(s)})`);return o}class Nt extends Error{constructor(t){super(t)}}function xt(){return Y.local()}const ln=new Map;function we(r){return ln.get(r)!==void 0}class vt extends Error{constructor(t){super(t),this.name="IdlError"}}class ht{constructor(t){this.stack=t}static parse(t){var e;const n=/^Program (\w*) invoke/,o=/^Program \w* success/,s=[];for(let i=0;i<t.length;i++){if(o.exec(t[i])){s.pop();continue}const c=(e=n.exec(t[i]))===null||e===void 0?void 0:e[1];!c||s.push(new k(c))}return new ht(s)}}class it extends Error{constructor(t,e,n,o,s,i){super(n.join(`
`).replace("Program log: ","")),this.errorLogs=n,this.logs=o,this.error={errorCode:t,errorMessage:e,comparedValues:i,origin:s},this._programErrorStack=ht.parse(o)}static parse(t){if(!t)return null;const e=t.findIndex(g=>g.startsWith("Program log: AnchorError"));if(e===-1)return null;const n=t[e],o=[n];let s;if(e+1<t.length){if(t[e+1]==="Program log: Left:"){const g=/^Program log: (.*)$/,p=g.exec(t[e+2])[1],m=g.exec(t[e+4])[1];s=[new k(p),new k(m)],o.push(...t.slice(e+1,e+5))}else if(t[e+1].startsWith("Program log: Left:")){const g=/^Program log: (Left|Right): (.*)$/,p=g.exec(t[e+1])[2],m=g.exec(t[e+2])[2];o.push(...t.slice(e+1,e+3)),s=[p,m]}}const c=/^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n),d=/^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n),v=/^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(n);if(c){const[g,p,m]=c.slice(1,4),b={code:g,number:parseInt(p)};return new it(b,m,o,t,void 0,s)}else if(d){const[g,p,m,b,L]=d.slice(1,6),T={code:m,number:parseInt(b)},q={file:g,line:parseInt(p)};return new it(T,L,o,t,q,s)}else if(v){const[g,p,m,b]=v.slice(1,5),L=g,T={code:p,number:parseInt(m)};return new it(T,b,o,t,L,s)}else return null}get program(){return this._programErrorStack.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){return this._programErrorStack.stack}toString(){return this.message}}class _t extends Error{constructor(t,e,n){super(),this.code=t,this.msg=e,this.logs=n,n&&(this._programErrorStack=ht.parse(n))}static parse(t,e){const n=t.toString();let o;if(n.includes("custom program error:")){let c=n.split("custom program error: ");if(c.length!==2)return null;o=c[1]}else{const c=n.match(/"Custom":([0-9]+)}/g);if(!c||c.length>1)return null;o=c[0].match(/([0-9]+)/g)[0]}let s;try{s=parseInt(o)}catch{return null}let i=e.get(s);return i!==void 0?new _t(s,i,t.logs):(i=dn.get(s),i!==void 0?new _t(s,i,t.logs):null)}get program(){var t;return(t=this._programErrorStack)===null||t===void 0?void 0:t.stack[this._programErrorStack.stack.length-1]}get programErrorStack(){var t;return(t=this._programErrorStack)===null||t===void 0?void 0:t.stack}toString(){return this.msg}}function ve(r,t){we("debug-logs")&&console.log("Translating error:",r);const e=it.parse(r.logs);if(e)return e;const n=_t.parse(r,t);if(n)return n;if(r.logs){const o={get:function(s,i){return i==="programErrorStack"?s.programErrorStack.stack:i==="program"?s.programErrorStack.stack[r.programErrorStack.stack.length-1]:Reflect.get(...arguments)}};return r.programErrorStack=ht.parse(r.logs),new Proxy(r,o)}return r}const w={InstructionMissing:100,InstructionFallbackNotFound:101,InstructionDidNotDeserialize:102,InstructionDidNotSerialize:103,IdlInstructionStub:1e3,IdlInstructionInvalidProgram:1001,ConstraintMut:2e3,ConstraintHasOne:2001,ConstraintSigner:2002,ConstraintRaw:2003,ConstraintOwner:2004,ConstraintRentExempt:2005,ConstraintSeeds:2006,ConstraintExecutable:2007,ConstraintState:2008,ConstraintAssociated:2009,ConstraintAssociatedInit:2010,ConstraintClose:2011,ConstraintAddress:2012,ConstraintZero:2013,ConstraintTokenMint:2014,ConstraintTokenOwner:2015,ConstraintMintMintAuthority:2016,ConstraintMintFreezeAuthority:2017,ConstraintMintDecimals:2018,ConstraintSpace:2019,ConstraintAccountIsNone:2020,RequireViolated:2500,RequireEqViolated:2501,RequireKeysEqViolated:2502,RequireNeqViolated:2503,RequireKeysNeqViolated:2504,RequireGtViolated:2505,RequireGteViolated:2506,AccountDiscriminatorAlreadySet:3e3,AccountDiscriminatorNotFound:3001,AccountDiscriminatorMismatch:3002,AccountDidNotDeserialize:3003,AccountDidNotSerialize:3004,AccountNotEnoughKeys:3005,AccountNotMutable:3006,AccountOwnedByWrongProgram:3007,InvalidProgramId:3008,InvalidProgramExecutable:3009,AccountNotSigner:3010,AccountNotSystemOwned:3011,AccountNotInitialized:3012,AccountNotProgramData:3013,AccountNotAssociatedTokenAccount:3014,AccountSysvarMismatch:3015,AccountReallocExceedsLimit:3016,AccountDuplicateReallocs:3017,DeclaredProgramIdMismatch:4100,Deprecated:5e3},dn=new Map([[w.InstructionMissing,"8 byte instruction identifier not provided"],[w.InstructionFallbackNotFound,"Fallback functions are not supported"],[w.InstructionDidNotDeserialize,"The program could not deserialize the given instruction"],[w.InstructionDidNotSerialize,"The program could not serialize the given instruction"],[w.IdlInstructionStub,"The program was compiled without idl instructions"],[w.IdlInstructionInvalidProgram,"The transaction was given an invalid program for the IDL instruction"],[w.ConstraintMut,"A mut constraint was violated"],[w.ConstraintHasOne,"A has one constraint was violated"],[w.ConstraintSigner,"A signer constraint was violated"],[w.ConstraintRaw,"A raw constraint was violated"],[w.ConstraintOwner,"An owner constraint was violated"],[w.ConstraintRentExempt,"A rent exemption constraint was violated"],[w.ConstraintSeeds,"A seeds constraint was violated"],[w.ConstraintExecutable,"An executable constraint was violated"],[w.ConstraintState,"Deprecated Error, feel free to replace with something else"],[w.ConstraintAssociated,"An associated constraint was violated"],[w.ConstraintAssociatedInit,"An associated init constraint was violated"],[w.ConstraintClose,"A close constraint was violated"],[w.ConstraintAddress,"An address constraint was violated"],[w.ConstraintZero,"Expected zero account discriminant"],[w.ConstraintTokenMint,"A token mint constraint was violated"],[w.ConstraintTokenOwner,"A token owner constraint was violated"],[w.ConstraintMintMintAuthority,"A mint mint authority constraint was violated"],[w.ConstraintMintFreezeAuthority,"A mint freeze authority constraint was violated"],[w.ConstraintMintDecimals,"A mint decimals constraint was violated"],[w.ConstraintSpace,"A space constraint was violated"],[w.ConstraintAccountIsNone,"A required account for the constraint is None"],[w.RequireViolated,"A require expression was violated"],[w.RequireEqViolated,"A require_eq expression was violated"],[w.RequireKeysEqViolated,"A require_keys_eq expression was violated"],[w.RequireNeqViolated,"A require_neq expression was violated"],[w.RequireKeysNeqViolated,"A require_keys_neq expression was violated"],[w.RequireGtViolated,"A require_gt expression was violated"],[w.RequireGteViolated,"A require_gte expression was violated"],[w.AccountDiscriminatorAlreadySet,"The account discriminator was already set on this account"],[w.AccountDiscriminatorNotFound,"No 8 byte discriminator was found on the account"],[w.AccountDiscriminatorMismatch,"8 byte discriminator did not match what was expected"],[w.AccountDidNotDeserialize,"Failed to deserialize the account"],[w.AccountDidNotSerialize,"Failed to serialize the account"],[w.AccountNotEnoughKeys,"Not enough account keys given to the instruction"],[w.AccountNotMutable,"The given account is not mutable"],[w.AccountOwnedByWrongProgram,"The given account is owned by a different program than expected"],[w.InvalidProgramId,"Program ID was not as expected"],[w.InvalidProgramExecutable,"Program account is not executable"],[w.AccountNotSigner,"The given account did not sign"],[w.AccountNotSystemOwned,"The given account is not owned by the system program"],[w.AccountNotInitialized,"The program expected this account to be already initialized"],[w.AccountNotProgramData,"The given account is not a program data account"],[w.AccountNotAssociatedTokenAccount,"The given account is not the associated token account"],[w.AccountSysvarMismatch,"The given public key does not match the required sysvar"],[w.AccountReallocExceedsLimit,"The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"],[w.AccountDuplicateReallocs,"The account was duplicated for more than one reallocation"],[w.DeclaredProgramIdMismatch,"The declared program id does not match the actual program id"],[w.Deprecated,"The API being used is deprecated and should no longer be used"]]);var zt={exports:{}};const fn=/[\p{Lu}]/u,hn=/[\p{Ll}]/u,ee=/^[\p{Lu}](?![\p{Lu}])/gu,_e=/([\p{Alpha}\p{N}_]|$)/u,Ae=/[_.\- ]+/,pn=new RegExp("^"+Ae.source),ne=new RegExp(Ae.source+_e.source,"gu"),re=new RegExp("\\d+"+_e.source,"gu"),mn=(r,t,e)=>{let n=!1,o=!1,s=!1;for(let i=0;i<r.length;i++){const c=r[i];n&&fn.test(c)?(r=r.slice(0,i)+"-"+r.slice(i),n=!1,s=o,o=!0,i++):o&&s&&hn.test(c)?(r=r.slice(0,i-1)+"-"+r.slice(i-1),s=o,o=!1,n=!0):(n=t(c)===c&&e(c)!==c,s=o,o=e(c)===c&&t(c)!==c)}return r},yn=(r,t)=>(ee.lastIndex=0,r.replace(ee,e=>t(e))),gn=(r,t)=>(ne.lastIndex=0,re.lastIndex=0,r.replace(ne,(e,n)=>t(n)).replace(re,e=>t(e))),be=(r,t)=>{if(!(typeof r=="string"||Array.isArray(r)))throw new TypeError("Expected the input to be `string | string[]`");if(t={pascalCase:!1,preserveConsecutiveUppercase:!1,...t},Array.isArray(r)?r=r.map(s=>s.trim()).filter(s=>s.length).join("-"):r=r.trim(),r.length===0)return"";const e=t.locale===!1?s=>s.toLowerCase():s=>s.toLocaleLowerCase(t.locale),n=t.locale===!1?s=>s.toUpperCase():s=>s.toLocaleUpperCase(t.locale);return r.length===1?t.pascalCase?n(r):e(r):(r!==e(r)&&(r=mn(r,e,n)),r=r.replace(pn,""),t.preserveConsecutiveUppercase?r=yn(r,e):r=e(r),t.pascalCase&&(r=n(r.charAt(0))+r.slice(1)),gn(r,n))};zt.exports=be;zt.exports.default=be;var S=zt.exports,Mt=function(){return Mt=Object.assign||function(t){for(var e,n=1,o=arguments.length;n<o;n++){e=arguments[n];for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s])}return t},Mt.apply(this,arguments)};var Dt=function(){return Dt=Object.assign||function(t){for(var e,n=1,o=arguments.length;n<o;n++){e=arguments[n];for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s])}return t},Dt.apply(this,arguments)};function wn(r){return r.toLowerCase()}var vn=[/([a-z0-9])([A-Z])/g,/([A-Z])([A-Z][a-z])/g],_n=/[^A-Z0-9]+/gi;function An(r,t){t===void 0&&(t={});for(var e=t.splitRegexp,n=e===void 0?vn:e,o=t.stripRegexp,s=o===void 0?_n:o,i=t.transform,c=i===void 0?wn:i,l=t.delimiter,d=l===void 0?" ":l,f=oe(oe(r,n,"$1\0$2"),s,"\0"),v=0,g=f.length;f.charAt(v)==="\0";)v++;for(;f.charAt(g-1)==="\0";)g--;return f.slice(v,g).split("\0").map(c).join(d)}function oe(r,t,e){return t instanceof RegExp?r.replace(t,e):t.reduce(function(n,o){return n.replace(o,e)},r)}function bn(r,t){return t===void 0&&(t={}),An(r,Dt({delimiter:"."},t))}function En(r,t){return t===void 0&&(t={}),bn(r,Mt({delimiter:"_"},t))}var A={};(function(r){var t=Bt&&Bt.__importDefault||function(_){return _&&_.__esModule?_:{default:_}};Object.defineProperty(r,"__esModule",{value:!0}),r.map=r.array=r.rustEnum=r.str=r.vecU8=r.tagged=r.vec=r.bool=r.option=r.publicKey=r.i256=r.u256=r.i128=r.u128=r.i64=r.u64=r.struct=r.f64=r.f32=r.i32=r.u32=r.i16=r.u16=r.i8=r.u8=void 0;const e=Gt,n=De,o=t(Re.exports);var s=Gt;Object.defineProperty(r,"u8",{enumerable:!0,get:function(){return s.u8}}),Object.defineProperty(r,"i8",{enumerable:!0,get:function(){return s.s8}}),Object.defineProperty(r,"u16",{enumerable:!0,get:function(){return s.u16}}),Object.defineProperty(r,"i16",{enumerable:!0,get:function(){return s.s16}}),Object.defineProperty(r,"u32",{enumerable:!0,get:function(){return s.u32}}),Object.defineProperty(r,"i32",{enumerable:!0,get:function(){return s.s32}}),Object.defineProperty(r,"f32",{enumerable:!0,get:function(){return s.f32}}),Object.defineProperty(r,"f64",{enumerable:!0,get:function(){return s.f64}}),Object.defineProperty(r,"struct",{enumerable:!0,get:function(){return s.struct}});class i extends e.Layout{constructor(h,a,u){super(h,u),this.blob=(0,e.blob)(h),this.signed=a}decode(h,a=0){const u=new o.default(this.blob.decode(h,a),10,"le");return this.signed?u.fromTwos(this.span*8).clone():u}encode(h,a,u=0){return this.signed&&(h=h.toTwos(this.span*8)),this.blob.encode(h.toArrayLike(O.Buffer,"le",this.span),a,u)}}function c(_){return new i(8,!1,_)}r.u64=c;function l(_){return new i(8,!0,_)}r.i64=l;function d(_){return new i(16,!1,_)}r.u128=d;function f(_){return new i(16,!0,_)}r.i128=f;function v(_){return new i(32,!1,_)}r.u256=v;function g(_){return new i(32,!0,_)}r.i256=g;class p extends e.Layout{constructor(h,a,u,y){super(h.span,y),this.layout=h,this.decoder=a,this.encoder=u}decode(h,a){return this.decoder(this.layout.decode(h,a))}encode(h,a,u){return this.layout.encode(this.encoder(h),a,u)}getSpan(h,a){return this.layout.getSpan(h,a)}}function m(_){return new p((0,e.blob)(32),h=>new n.PublicKey(h),h=>h.toBuffer(),_)}r.publicKey=m;class b extends e.Layout{constructor(h,a){super(-1,a),this.layout=h,this.discriminator=(0,e.u8)()}encode(h,a,u=0){return h==null?this.discriminator.encode(0,a,u):(this.discriminator.encode(1,a,u),this.layout.encode(h,a,u+1)+1)}decode(h,a=0){const u=this.discriminator.decode(h,a);if(u===0)return null;if(u===1)return this.layout.decode(h,a+1);throw new Error("Invalid option "+this.property)}getSpan(h,a=0){const u=this.discriminator.decode(h,a);if(u===0)return 1;if(u===1)return this.layout.getSpan(h,a+1)+1;throw new Error("Invalid option "+this.property)}}function L(_,h){return new b(_,h)}r.option=L;function T(_){return new p((0,e.u8)(),q,G,_)}r.bool=T;function q(_){if(_===0)return!1;if(_===1)return!0;throw new Error("Invalid bool: "+_)}function G(_){return _?1:0}function Z(_,h){const a=(0,e.u32)("length"),u=(0,e.struct)([a,(0,e.seq)(_,(0,e.offset)(a,-a.span),"values")]);return new p(u,({values:y})=>y,y=>({values:y}),h)}r.vec=Z;function D(_,h,a){const u=(0,e.struct)([c("tag"),h.replicate("data")]);function y({tag:E,data:C}){if(!E.eq(_))throw new Error("Invalid tag, expected: "+_.toString("hex")+", got: "+E.toString("hex"));return C}return new p(u,y,E=>({tag:_,data:E}),a)}r.tagged=D;function J(_){const h=(0,e.u32)("length"),a=(0,e.struct)([h,(0,e.blob)((0,e.offset)(h,-h.span),"data")]);return new p(a,({data:u})=>u,u=>({data:u}),_)}r.vecU8=J;function et(_){return new p(J(),h=>h.toString("utf-8"),h=>O.Buffer.from(h,"utf-8"),_)}r.str=et;function V(_,h,a){const u=(0,e.union)(a??(0,e.u8)(),h);return _.forEach((y,E)=>u.addVariant(E,y,y.property)),u}r.rustEnum=V;function St(_,h,a){const u=(0,e.struct)([(0,e.seq)(_,h,"values")]);return new p(u,({values:y})=>y,y=>({values:y}),a)}r.array=St;class Lt extends e.Layout{constructor(h,a,u){super(h.span+a.span,u),this.keyLayout=h,this.valueLayout=a}decode(h,a){a=a||0;const u=this.keyLayout.decode(h,a),y=this.valueLayout.decode(h,a+this.keyLayout.getSpan(h,a));return[u,y]}encode(h,a,u){u=u||0;const y=this.keyLayout.encode(h[0],a,u),E=this.valueLayout.encode(h[1],a,u+y);return y+E}getSpan(h,a){return this.keyLayout.getSpan(h,a)+this.valueLayout.getSpan(h,a)}}function N(_,h,a){const u=(0,e.u32)("length"),y=(0,e.struct)([u,(0,e.seq)(new Lt(_,h),(0,e.offset)(u,-u.span),"values")]);return new p(y,({values:E})=>new Map(E),E=>({values:Array.from(E.entries())}),a)}r.map=N})(A);class R{static fieldLayout(t,e){const n=t.name!==void 0?S(t.name):void 0;switch(t.type){case"bool":return A.bool(n);case"u8":return A.u8(n);case"i8":return A.i8(n);case"u16":return A.u16(n);case"i16":return A.i16(n);case"u32":return A.u32(n);case"i32":return A.i32(n);case"f32":return A.f32(n);case"u64":return A.u64(n);case"i64":return A.i64(n);case"f64":return A.f64(n);case"u128":return A.u128(n);case"i128":return A.i128(n);case"u256":return A.u256(n);case"i256":return A.i256(n);case"bytes":return A.vecU8(n);case"string":return A.str(n);case"publicKey":return A.publicKey(n);default:{if("vec"in t.type)return A.vec(R.fieldLayout({name:void 0,type:t.type.vec},e),n);if("option"in t.type)return A.option(R.fieldLayout({name:void 0,type:t.type.option},e),n);if("defined"in t.type){if(!e)throw new vt("User defined types not provided");const o=t.type.defined,s=e.filter(i=>i.name===o);if(s.length!==1)throw new vt(`Type not found: ${JSON.stringify(t)}`);return R.typeDefLayout(s[0],e,n)}else if("array"in t.type){let o=t.type.array[0],s=t.type.array[1],i=R.fieldLayout({name:void 0,type:o},e);return A.array(i,s,n)}else throw new Error(`Not yet implemented: ${t}`)}}}static typeDefLayout(t,e=[],n){switch(t.type.kind){case"struct":{const o=t.type.fields.map(s=>R.fieldLayout(s,e));return A.struct(o,n)}case"enum":{let o=t.type.variants.map(s=>{const i=S(s.name);if(!s.fields)return A.struct([],i);const c=s.fields.map((l,d)=>l!=null&&l.name?R.fieldLayout(l,e):R.fieldLayout({type:l,name:d.toString()},e));return A.struct(c,i)});return n!==void 0?A.rustEnum(o).replicate(n):A.rustEnum(o,n)}case"alias":return R.fieldLayout({type:t.type.value,name:t.name},e)}}}const se="global";class Ft{constructor(t){this.idl=t,this.ixLayout=Ft.parseIxLayout(t);const e=new Map;t.instructions.forEach(n=>{const o=ie(se,n.name);e.set(st.encode(o),{layout:this.ixLayout.get(n.name),name:n.name})}),this.sighashLayouts=e}encode(t,e){return this._encode(se,t,e)}_encode(t,e,n){const o=U.Buffer.alloc(1e3),s=S(e),i=this.ixLayout.get(s);if(!i)throw new Error(`Unknown method: ${s}`);const c=i.encode(n,o),l=o.slice(0,c);return U.Buffer.concat([ie(t,e),l])}static parseIxLayout(t){const e=t.instructions.map(n=>{let o=n.args.map(i=>{var c,l;return R.fieldLayout(i,Array.from([...(c=t.accounts)!==null&&c!==void 0?c:[],...(l=t.types)!==null&&l!==void 0?l:[]]))});const s=S(n.name);return[s,A.struct(o,s)]});return new Map(e)}decode(t,e="hex"){typeof t=="string"&&(t=e==="hex"?U.Buffer.from(t,"hex"):st.decode(t));let n=st.encode(t.slice(0,8)),o=t.slice(8);const s=this.sighashLayouts.get(n);return s?{data:s.layout.decode(o),name:s.name}:null}format(t,e){return $.format(t,e,this.idl)}}class ${static format(t,e,n){const o=n.instructions.filter(l=>t.name===l.name)[0];if(o===void 0)return console.error("Invalid instruction given"),null;const s=o.args.map(l=>({name:l.name,type:$.formatIdlType(l.type),data:$.formatIdlData(l,t.data[l.name],n.types)})),i=$.flattenIdlAccounts(o.accounts),c=e.map((l,d)=>d<i.length?{name:i[d].name,...l}:{name:void 0,...l});return{args:s,accounts:c}}static formatIdlType(t){if(typeof t=="string")return t;if("vec"in t)return`Vec<${this.formatIdlType(t.vec)}>`;if("option"in t)return`Option<${this.formatIdlType(t.option)}>`;if("defined"in t)return t.defined;if("array"in t)return`Array<${t.array[0]}; ${t.array[1]}>`;throw new Error(`Unknown IDL type: ${t}`)}static formatIdlData(t,e,n){if(typeof t.type=="string")return e.toString();if(t.type.hasOwnProperty("vec"))return"["+e.map(o=>this.formatIdlData({name:"",type:t.type.vec},o)).join(", ")+"]";if(t.type.hasOwnProperty("option"))return e===null?"null":this.formatIdlData({name:"",type:t.type.option},e,n);if(t.type.hasOwnProperty("defined")){if(n===void 0)throw new Error("User defined types not provided");const o=n.filter(s=>s.name===t.type.defined);if(o.length!==1)throw new Error(`Type not found: ${t.type.defined}`);return $.formatIdlDataDefined(o[0],e,n)}return"unknown"}static formatIdlDataDefined(t,e,n){switch(t.type.kind){case"struct":{const o=t.type,s=Object.keys(e).map(i=>{const c=o.fields.find(l=>l.name===i);if(!c)throw new Error("Unable to find type");return i+": "+$.formatIdlData(c,e[i],n)}).join(", ");return"{ "+s+" }"}case"enum":{if(t.type.variants.length===0)return"{}";if(t.type.variants[0].name){const o=t.type.variants,s=Object.keys(e)[0],i=e[s],c=Object.keys(i).map(d=>{var f;const v=i[d],g=(f=o[s])===null||f===void 0?void 0:f.find(p=>p.name===d);if(!g)throw new Error("Unable to find variant");return d+": "+$.formatIdlData(g,v,n)}).join(", "),l=S(s,{pascalCase:!0});return c.length===0?l:`${l} { ${c} }`}else return"Tuple formatting not yet implemented"}case"alias":return $.formatIdlType(t.type.value)}}static flattenIdlAccounts(t,e){return t.map(n=>{const o=In(n.name);if(n.hasOwnProperty("accounts")){const s=e?`${e} > ${o}`:o;return $.flattenIdlAccounts(n.accounts,s)}else return{...n,name:e?`${e} > ${o}`:o}}).flat()}}function In(r){const t=r.replace(/([A-Z])/g," $1");return t.charAt(0).toUpperCase()+t.slice(1)}function ie(r,t){let e=En(t),n=`${r}:${e}`;return U.Buffer.from(ue(n).slice(0,8))}function Ee(r,t){switch(t.type.kind){case"struct":return t.type.fields.map(e=>X(r,e.type)).reduce((e,n)=>e+n,0);case"enum":{const e=t.type.variants.map(n=>n.fields?n.fields.map(o=>typeof o=="object"&&"name"in o?X(r,o.type):X(r,o)).reduce((o,s)=>o+s,0):0);return Math.max(...e)+1}case"alias":return X(r,t.type.value)}}function X(r,t){var e,n;switch(t){case"bool":return 1;case"u8":return 1;case"i8":return 1;case"i16":return 2;case"u16":return 2;case"u32":return 4;case"i32":return 4;case"f32":return 4;case"u64":return 8;case"i64":return 8;case"f64":return 8;case"u128":return 16;case"i128":return 16;case"u256":return 32;case"i256":return 32;case"bytes":return 1;case"string":return 1;case"publicKey":return 32;default:if("vec"in t)return 1;if("option"in t)return 1+X(r,t.option);if("coption"in t)return 4+X(r,t.coption);if("defined"in t){const o=(n=(e=r.types)===null||e===void 0?void 0:e.filter(i=>i.name===t.defined))!==null&&n!==void 0?n:[];if(o.length!==1)throw new vt(`Type not found: ${JSON.stringify(t)}`);let s=o[0];return Ee(r,s)}if("array"in t){let o=t.array[0],s=t.array[1];return X(r,o)*s}throw new Error(`Invalid type ${JSON.stringify(t)}`)}}const Ut=8;function Ie(r){return O.Buffer.from(ue(r).slice(0,Ut))}class Q{constructor(t){if(t.accounts===void 0){this.accountLayouts=new Map;return}const e=t.accounts.map(n=>[n.name,R.typeDefLayout(n,t.types)]);this.accountLayouts=new Map(e),this.idl=t}async encode(t,e){const n=U.Buffer.alloc(1e3),o=this.accountLayouts.get(t);if(!o)throw new Error(`Unknown account: ${t}`);const s=o.encode(e,n);let i=n.slice(0,s),c=Q.accountDiscriminator(t);return U.Buffer.concat([c,i])}decode(t,e){if(Q.accountDiscriminator(t).compare(e.slice(0,8)))throw new Error("Invalid account discriminator");return this.decodeUnchecked(t,e)}decodeAny(t){const e=t.slice(0,8),n=Array.from(this.accountLayouts.keys()).find(o=>Q.accountDiscriminator(o).equals(e));if(!n)throw new Error("Account descriminator not found");return this.decodeUnchecked(n,t)}decodeUnchecked(t,e){const n=e.subarray(Ut),o=this.accountLayouts.get(t);if(!o)throw new Error(`Unknown account: ${t}`);return o.decode(n)}memcmp(t,e){const n=Q.accountDiscriminator(t);return{offset:0,bytes:st.encode(e?U.Buffer.concat([n,e]):n)}}size(t){var e;return Ut+((e=Ee(this.idl,t))!==null&&e!==void 0?e:0)}static accountDiscriminator(t){const e=`account:${S(t,{pascalCase:!0,preserveConsecutiveUppercase:!0})}`;return Ie(e)}}class Sn{constructor(t){if(t.events===void 0){this.layouts=new Map;return}const e=t.events.map(n=>{let o={name:n.name,type:{kind:"struct",fields:n.fields.map(s=>({name:s.name,type:s.type}))}};return[n.name,R.typeDefLayout(o,t.types)]});this.layouts=new Map(e),this.discriminators=new Map(t.events===void 0?[]:t.events.map(n=>[Xt(Ln(n.name)),n.name]))}decode(t){let e;try{e=he(t)}catch{return null}const n=Xt(e.slice(0,8)),o=this.discriminators.get(n);if(o===void 0)return null;const s=this.layouts.get(o);if(!s)throw new Error(`Unknown event: ${o}`);return{data:s.decode(e.slice(8)),name:o}}}function Ln(r){return Ie(`event:${r}`)}class Cn{constructor(t){if(t.types===void 0){this.typeLayouts=new Map;return}const e=t.types.map(n=>[n.name,R.typeDefLayout(n,t.types)]);this.typeLayouts=new Map(e),this.idl=t}encode(t,e){const n=U.Buffer.alloc(1e3),o=this.typeLayouts.get(t);if(!o)throw new Error(`Unknown type: ${t}`);const s=o.encode(e,n);return n.slice(0,s)}decode(t,e){const n=this.typeLayouts.get(t);if(!n)throw new Error(`Unknown type: ${t}`);return n.decode(e)}}class Se{constructor(t){this.instruction=new Ft(t),this.accounts=new Q(t),this.events=new Sn(t),this.types=new Cn(t)}}class Pn extends bt{constructor(t){super(-1,t),this.property=t,this.layout=P([j("length"),j("lengthPadding"),lt(Ue(j(),-8),"chars")],this.property)}encode(t,e,n=0){if(t==null)return this.layout.span;const o={chars:O.Buffer.from(t,"utf8")};return this.layout.encode(o,e,n)}decode(t,e=0){return this.layout.decode(t,e).chars.toString()}getSpan(t,e=0){return j().span+j().span+new le(new Uint8Array(t).slice(e,e+4),10,"le").toNumber()}}function Et(r){return new Pn(r)}function M(r){return lt(32,r)}const B=fe(j("instruction"));B.addVariant(0,P([z("lamports"),z("space"),M("owner")]),"createAccount");B.addVariant(1,P([M("owner")]),"assign");B.addVariant(2,P([z("lamports")]),"transfer");B.addVariant(3,P([M("base"),Et("seed"),z("lamports"),z("space"),M("owner")]),"createAccountWithSeed");B.addVariant(4,P([M("authorized")]),"advanceNonceAccount");B.addVariant(5,P([z("lamports")]),"withdrawNonceAccount");B.addVariant(6,P([M("authorized")]),"initializeNonceAccount");B.addVariant(7,P([M("authorized")]),"authorizeNonceAccount");B.addVariant(8,P([z("space")]),"allocate");B.addVariant(9,P([M("base"),Et("seed"),z("space"),M("owner")]),"allocateWithSeed");B.addVariant(10,P([M("base"),Et("seed"),M("owner")]),"assignWithSeed");B.addVariant(11,P([z("lamports"),Et("seed"),M("owner")]),"transferWithSeed");Math.max(...Object.values(B.registry).map(r=>r.span));class kn extends bt{constructor(t,e,n,o){super(t.span,o),this.layout=t,this.decoder=e,this.encoder=n}decode(t,e){return this.decoder(this.layout.decode(t,e))}encode(t,e,n){return this.layout.encode(this.encoder(t),e,n)}getSpan(t,e){return this.layout.getSpan(t,e)}}function ae(r){return new kn(lt(32),t=>new k(t),t=>t.toBuffer(),r)}P([j("version"),j("state"),ae("authorizedPubkey"),ae("nonce"),P([$e("lamportsPerSignature")],"feeCalculator")]);function Tn(r,...t){let e=[U.Buffer.from([97,110,99,104,111,114])];t.forEach(o=>{e.push(o instanceof U.Buffer?o:x(o).toBuffer())});const[n]=k.findProgramAddressSync(e,x(r));return n}const Rn=new k("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),On=new k("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");var ce={exports:{}};(function(r,t){var e=typeof self<"u"?self:Bt,n=function(){function s(){this.fetch=!1,this.DOMException=e.DOMException}return s.prototype=e,new s}();(function(s){(function(i){var c={searchParams:"URLSearchParams"in s,iterable:"Symbol"in s&&"iterator"in Symbol,blob:"FileReader"in s&&"Blob"in s&&function(){try{return new Blob,!0}catch{return!1}}(),formData:"FormData"in s,arrayBuffer:"ArrayBuffer"in s};function l(a){return a&&DataView.prototype.isPrototypeOf(a)}if(c.arrayBuffer)var d=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],f=ArrayBuffer.isView||function(a){return a&&d.indexOf(Object.prototype.toString.call(a))>-1};function v(a){if(typeof a!="string"&&(a=String(a)),/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(a))throw new TypeError("Invalid character in header field name");return a.toLowerCase()}function g(a){return typeof a!="string"&&(a=String(a)),a}function p(a){var u={next:function(){var y=a.shift();return{done:y===void 0,value:y}}};return c.iterable&&(u[Symbol.iterator]=function(){return u}),u}function m(a){this.map={},a instanceof m?a.forEach(function(u,y){this.append(y,u)},this):Array.isArray(a)?a.forEach(function(u){this.append(u[0],u[1])},this):a&&Object.getOwnPropertyNames(a).forEach(function(u){this.append(u,a[u])},this)}m.prototype.append=function(a,u){a=v(a),u=g(u);var y=this.map[a];this.map[a]=y?y+", "+u:u},m.prototype.delete=function(a){delete this.map[v(a)]},m.prototype.get=function(a){return a=v(a),this.has(a)?this.map[a]:null},m.prototype.has=function(a){return this.map.hasOwnProperty(v(a))},m.prototype.set=function(a,u){this.map[v(a)]=g(u)},m.prototype.forEach=function(a,u){for(var y in this.map)this.map.hasOwnProperty(y)&&a.call(u,this.map[y],y,this)},m.prototype.keys=function(){var a=[];return this.forEach(function(u,y){a.push(y)}),p(a)},m.prototype.values=function(){var a=[];return this.forEach(function(u){a.push(u)}),p(a)},m.prototype.entries=function(){var a=[];return this.forEach(function(u,y){a.push([y,u])}),p(a)},c.iterable&&(m.prototype[Symbol.iterator]=m.prototype.entries);function b(a){if(a.bodyUsed)return Promise.reject(new TypeError("Already read"));a.bodyUsed=!0}function L(a){return new Promise(function(u,y){a.onload=function(){u(a.result)},a.onerror=function(){y(a.error)}})}function T(a){var u=new FileReader,y=L(u);return u.readAsArrayBuffer(a),y}function q(a){var u=new FileReader,y=L(u);return u.readAsText(a),y}function G(a){for(var u=new Uint8Array(a),y=new Array(u.length),E=0;E<u.length;E++)y[E]=String.fromCharCode(u[E]);return y.join("")}function Z(a){if(a.slice)return a.slice(0);var u=new Uint8Array(a.byteLength);return u.set(new Uint8Array(a)),u.buffer}function D(){return this.bodyUsed=!1,this._initBody=function(a){this._bodyInit=a,a?typeof a=="string"?this._bodyText=a:c.blob&&Blob.prototype.isPrototypeOf(a)?this._bodyBlob=a:c.formData&&FormData.prototype.isPrototypeOf(a)?this._bodyFormData=a:c.searchParams&&URLSearchParams.prototype.isPrototypeOf(a)?this._bodyText=a.toString():c.arrayBuffer&&c.blob&&l(a)?(this._bodyArrayBuffer=Z(a.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):c.arrayBuffer&&(ArrayBuffer.prototype.isPrototypeOf(a)||f(a))?this._bodyArrayBuffer=Z(a):this._bodyText=a=Object.prototype.toString.call(a):this._bodyText="",this.headers.get("content-type")||(typeof a=="string"?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):c.searchParams&&URLSearchParams.prototype.isPrototypeOf(a)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},c.blob&&(this.blob=function(){var a=b(this);if(a)return a;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?b(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(T)}),this.text=function(){var a=b(this);if(a)return a;if(this._bodyBlob)return q(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(G(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},c.formData&&(this.formData=function(){return this.text().then(St)}),this.json=function(){return this.text().then(JSON.parse)},this}var J=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function et(a){var u=a.toUpperCase();return J.indexOf(u)>-1?u:a}function V(a,u){u=u||{};var y=u.body;if(a instanceof V){if(a.bodyUsed)throw new TypeError("Already read");this.url=a.url,this.credentials=a.credentials,u.headers||(this.headers=new m(a.headers)),this.method=a.method,this.mode=a.mode,this.signal=a.signal,!y&&a._bodyInit!=null&&(y=a._bodyInit,a.bodyUsed=!0)}else this.url=String(a);if(this.credentials=u.credentials||this.credentials||"same-origin",(u.headers||!this.headers)&&(this.headers=new m(u.headers)),this.method=et(u.method||this.method||"GET"),this.mode=u.mode||this.mode||null,this.signal=u.signal||this.signal,this.referrer=null,(this.method==="GET"||this.method==="HEAD")&&y)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(y)}V.prototype.clone=function(){return new V(this,{body:this._bodyInit})};function St(a){var u=new FormData;return a.trim().split("&").forEach(function(y){if(y){var E=y.split("="),C=E.shift().replace(/\+/g," "),I=E.join("=").replace(/\+/g," ");u.append(decodeURIComponent(C),decodeURIComponent(I))}}),u}function Lt(a){var u=new m,y=a.replace(/\r?\n[\t ]+/g," ");return y.split(/\r?\n/).forEach(function(E){var C=E.split(":"),I=C.shift().trim();if(I){var pt=C.join(":").trim();u.append(I,pt)}}),u}D.call(V.prototype);function N(a,u){u||(u={}),this.type="default",this.status=u.status===void 0?200:u.status,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in u?u.statusText:"OK",this.headers=new m(u.headers),this.url=u.url||"",this._initBody(a)}D.call(N.prototype),N.prototype.clone=function(){return new N(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new m(this.headers),url:this.url})},N.error=function(){var a=new N(null,{status:0,statusText:""});return a.type="error",a};var _=[301,302,303,307,308];N.redirect=function(a,u){if(_.indexOf(u)===-1)throw new RangeError("Invalid status code");return new N(null,{status:u,headers:{location:a}})},i.DOMException=s.DOMException;try{new i.DOMException}catch{i.DOMException=function(u,y){this.message=u,this.name=y;var E=Error(u);this.stack=E.stack},i.DOMException.prototype=Object.create(Error.prototype),i.DOMException.prototype.constructor=i.DOMException}function h(a,u){return new Promise(function(y,E){var C=new V(a,u);if(C.signal&&C.signal.aborted)return E(new i.DOMException("Aborted","AbortError"));var I=new XMLHttpRequest;function pt(){I.abort()}I.onload=function(){var nt={status:I.status,statusText:I.statusText,headers:Lt(I.getAllResponseHeaders()||"")};nt.url="responseURL"in I?I.responseURL:nt.headers.get("X-Request-URL");var Ct="response"in I?I.response:I.responseText;y(new N(Ct,nt))},I.onerror=function(){E(new TypeError("Network request failed"))},I.ontimeout=function(){E(new TypeError("Network request failed"))},I.onabort=function(){E(new i.DOMException("Aborted","AbortError"))},I.open(C.method,C.url,!0),C.credentials==="include"?I.withCredentials=!0:C.credentials==="omit"&&(I.withCredentials=!1),"responseType"in I&&c.blob&&(I.responseType="blob"),C.headers.forEach(function(nt,Ct){I.setRequestHeader(Ct,nt)}),C.signal&&(C.signal.addEventListener("abort",pt),I.onreadystatechange=function(){I.readyState===4&&C.signal.removeEventListener("abort",pt)}),I.send(typeof C._bodyInit>"u"?null:C._bodyInit)})}return h.polyfill=!0,s.fetch||(s.fetch=h,s.Headers=m,s.Request=V,s.Response=N),i.Headers=m,i.Request=V,i.Response=N,i.fetch=h,Object.defineProperty(i,"__esModule",{value:!0}),i})({})})(n),n.fetch.ponyfill=!0,delete n.fetch.polyfill;var o=n;t=o.fetch,t.default=o.fetch,t.fetch=o.fetch,t.Headers=o.Headers,t.Request=o.Request,t.Response=o.Response,r.exports=t})(ce,ce.exports);A.rustEnum([A.struct([],"uninitialized"),A.struct([A.option(A.publicKey(),"authorityAddress")],"buffer"),A.struct([A.publicKey("programdataAddress")],"program"),A.struct([A.u64("slot"),A.option(A.publicKey(),"upgradeAuthorityAddress")],"programData")],void 0,A.u32());function Bn(r){return"accounts"in r}async function Nn(r){const t=(await k.findProgramAddress([],r))[0];return await k.createWithSeed(t,xn(),r)}function xn(){return"anchor:idl"}const Mn=A.struct([A.publicKey("authority"),A.vecU8("data")]);function Dn(r){return Mn.decode(r)}function It(r,t){var e,n;let o={};const s=r.args?r.args.length:0;if(t.length>s){if(t.length!==s+1)throw new Error(`provided too many arguments ${t} to instruction ${r==null?void 0:r.name} expecting: ${(n=(e=r.args)===null||e===void 0?void 0:e.map(i=>i.name))!==null&&n!==void 0?n:[]}`);o=t.pop()}return[t,o]}class At{static build(t,e,n){if(t.name==="_inner")throw new vt("the _inner name is reserved");const o=(...s)=>{const[i,c]=It(t,[...s]);pe(t.accounts,c.accounts),Un(t,...s);const l=o.accounts(c.accounts);return c.remainingAccounts!==void 0&&l.push(...c.remainingAccounts),we("debug-logs")&&console.log("Outgoing account metas:",l),new Oe({keys:l,programId:n,data:e(t.name,We(t,...i))})};return o.accounts=s=>At.accountsArray(s,t.accounts,n,t.name),o}static accountsArray(t,e,n,o){return t?e.map(s=>{if(("accounts"in s?s.accounts:void 0)!==void 0){const c=t[s.name];return At.accountsArray(c,s.accounts,n,o).flat()}else{const c=s;let l;try{l=x(t[s.name])}catch{throw new Error(`Wrong input type for account "${s.name}" in the instruction accounts object${o!==void 0?' for instruction "'+o+'"':""}. Expected PublicKey or string.`)}const d=c.isOptional&&l.equals(n),f=c.isMut&&!d,v=c.isSigner&&!d;return{pubkey:l,isWritable:f,isSigner:v}}}).flat():[]}}function Un(r,...t){}class $n{static build(t,e){return(...o)=>{var s,i,c;const[,l]=It(t,[...o]),d=new Be;if(l.preInstructions&&l.instructions)throw new Error("instructions is deprecated, use preInstructions");return(s=l.preInstructions)===null||s===void 0||s.forEach(f=>d.add(f)),(i=l.instructions)===null||i===void 0||i.forEach(f=>d.add(f)),d.add(e(...o)),(c=l.postInstructions)===null||c===void 0||c.forEach(f=>d.add(f)),d}}}class qn{static build(t,e,n,o){return async(...i)=>{var c;const l=e(...i),[,d]=It(t,[...i]);if(o.sendAndConfirm===void 0)throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");try{return await o.sendAndConfirm(l,(c=d.signers)!==null&&c!==void 0?c:[],d.options)}catch(f){throw ve(f,n)}}}}class Vn{static build(t,e,n,o){var s;const i={};return(s=t.accounts)===null||s===void 0||s.forEach(c=>{const l=S(c.name);i[l]=new jn(t,c,n,o,e)}),i}}class jn{get size(){return this._size}get programId(){return this._programId}get provider(){return this._provider}get coder(){return this._coder}get idlAccount(){return this._idlAccount}constructor(t,e,n,o,s){this._idlAccount=e,this._programId=n,this._provider=o??xt(),this._coder=s??new Se(t),this._size=this._coder.accounts.size(e)}async fetchNullable(t,e){const{data:n}=await this.fetchNullableAndContext(t,e);return n}async fetchNullableAndContext(t,e){const n=await this.getAccountInfoAndContext(t,e),{value:o,context:s}=n;return{data:o&&o.data.length!==0?this._coder.accounts.decode(this._idlAccount.name,o.data):null,context:s}}async fetch(t,e){const{data:n}=await this.fetchNullableAndContext(t,e);if(n===null)throw new Error(`Account does not exist or has no data ${t.toString()}`);return n}async fetchAndContext(t,e){const{data:n,context:o}=await this.fetchNullableAndContext(t,e);if(n===null)throw new Error(`Account does not exist ${t.toString()}`);return{data:n,context:o}}async fetchMultiple(t,e){return(await this.fetchMultipleAndContext(t,e)).map(o=>o?o.data:null)}async fetchMultipleAndContext(t,e){return(await nn(this._provider.connection,t.map(o=>x(o)),e)).map(o=>{if(o==null)return null;const{account:s,context:i}=o;return{data:this._coder.accounts.decode(this._idlAccount.name,s.data),context:i}})}async all(t){const e=this.coder.accounts.memcmp(this._idlAccount.name,t instanceof O.Buffer?t:void 0),n=[];return(e==null?void 0:e.offset)!=null&&(e==null?void 0:e.bytes)!=null&&n.push({memcmp:{offset:e.offset,bytes:e.bytes}}),(e==null?void 0:e.dataSize)!=null&&n.push({dataSize:e.dataSize}),(await this._provider.connection.getProgramAccounts(this._programId,{commitment:this._provider.connection.commitment,filters:[...n,...Array.isArray(t)?t:[]]})).map(({pubkey:s,account:i})=>({publicKey:s,account:this._coder.accounts.decode(this._idlAccount.name,i.data)}))}subscribe(t,e){const n=ot.get(t.toString());if(n)return n.ee;const o=new Ne;t=x(t);const s=this._provider.connection.onAccountChange(t,i=>{const c=this._coder.accounts.decode(this._idlAccount.name,i.data);o.emit("change",c)},e);return ot.set(t.toString(),{ee:o,listener:s}),o}async unsubscribe(t){let e=ot.get(t.toString());if(!e){console.warn("Address is not subscribed");return}ot&&await this._provider.connection.removeAccountChangeListener(e.listener).then(()=>{ot.delete(t.toString())}).catch(console.error)}async createInstruction(t,e){const n=this.size;if(this._provider.publicKey===void 0)throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");return de.createAccount({fromPubkey:this._provider.publicKey,newAccountPubkey:t.publicKey,space:e??n,lamports:await this._provider.connection.getMinimumBalanceForRentExemption(e??n),programId:this._programId})}async associated(...t){const e=await this.associatedAddress(...t);return await this.fetch(e)}async associatedAddress(...t){return await Tn(this._programId,...t)}async getAccountInfo(t,e){return await this._provider.connection.getAccountInfo(x(t),e)}async getAccountInfoAndContext(t,e){return await this._provider.connection.getAccountInfoAndContext(x(t),e)}}const ot=new Map,$t="Program log: ",Le="Program data: ",zn=$t.length,Fn=Le.length;class Kn{constructor(t,e,n){this._programId=t,this._provider=e,this._eventParser=new Ce(t,n),this._eventCallbacks=new Map,this._eventListeners=new Map,this._listenerIdCount=0}addEventListener(t,e){var n;let o=this._listenerIdCount;return this._listenerIdCount+=1,this._eventListeners.has(t)||this._eventListeners.set(t,[]),this._eventListeners.set(t,((n=this._eventListeners.get(t))!==null&&n!==void 0?n:[]).concat(o)),this._eventCallbacks.set(o,[t,e]),this._onLogsSubscriptionId!==void 0||(this._onLogsSubscriptionId=this._provider.connection.onLogs(this._programId,(s,i)=>{if(!s.err)for(const c of this._eventParser.parseLogs(s.logs)){const l=this._eventListeners.get(c.name);l&&l.forEach(d=>{const f=this._eventCallbacks.get(d);if(f){const[,v]=f;v(c.data,i.slot,s.signature)}})}})),o}async removeEventListener(t){const e=this._eventCallbacks.get(t);if(!e)throw new Error(`Event listener ${t} doesn't exist!`);const[n]=e;let o=this._eventListeners.get(n);if(!o)throw new Error(`Event listeners don't exist for ${n}!`);if(this._eventCallbacks.delete(t),o=o.filter(s=>s!==t),this._eventListeners.set(n,o),o.length===0&&this._eventListeners.delete(n),this._eventCallbacks.size===0){if(this._eventListeners.size!==0)throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);this._onLogsSubscriptionId!==void 0&&(await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId),this._onLogsSubscriptionId=void 0)}}}class Ce{constructor(t,e){this.coder=e,this.programId=t}*parseLogs(t,e=!1){const n=new Gn(t),o=new Wn;let s=n.next();for(;s!==null;){let[i,c,l]=this.handleLog(o,s,e);i&&(yield i),c&&o.push(c),l&&o.pop(),s=n.next()}}handleLog(t,e,n){return t.stack.length>0&&t.program()===this.programId.toString()?this.handleProgramLog(e,n):[null,...this.handleSystemLog(e)]}handleProgramLog(t,e){if(t.startsWith($t)||t.startsWith(Le)){const n=t.startsWith($t)?t.slice(zn):t.slice(Fn),o=this.coder.events.decode(n);if(e&&o===null)throw new Error(`Unable to decode event ${n}`);return[o,null,!1]}else return[null,...this.handleSystemLog(t)]}handleSystemLog(t){const e=t.split(":")[0];return e.match(/^Program (.*) success/g)!==null?[null,!0]:e.startsWith(`Program ${this.programId.toString()} invoke`)?[this.programId.toString(),!1]:e.includes("invoke")?["cpi",!1]:[null,!1]}}class Wn{constructor(){this.stack=[]}program(){if(!this.stack.length)throw new Error("Expected the stack to have elements");return this.stack[this.stack.length-1]}push(t){this.stack.push(t)}pop(){if(!this.stack.length)throw new Error("Expected the stack to have elements");this.stack.pop()}}class Gn{constructor(t){this.logs=t}next(){if(this.logs.length===0)return null;let t=this.logs[0];return this.logs=this.logs.slice(1),t}}class Hn{static build(t,e,n,o,s,i,c){return async(...d)=>{var f;const v=e(...d),[,g]=It(t,[...d]);let p;if(o.simulate===void 0)throw new Error("This function requires 'Provider.simulate' to be implemented.");try{p=await o.simulate(v,g.signers,(f=g.options)===null||f===void 0?void 0:f.commitment)}catch(L){throw ve(L,n)}if(p===void 0)throw new Error("Unable to simulate transaction");const m=p.logs;if(!m)throw new Error("Simulated logs not found");const b=[];if(c.events){let L=new Ce(i,s);for(const T of L.parseLogs(m))b.push(T)}return{events:b,raw:m}}}}function Tt(r){return new Pe(lt(8),t=>Kt.fromBuffer(t),t=>t.toBuffer(),r)}function yt(r){return new Pe(lt(32),t=>new k(t),t=>t.toBuffer(),r)}function Rt(r,t){return new Xn(r,t)}class Pe extends bt{constructor(t,e,n,o){super(t.span,o),this.layout=t,this.decoder=e,this.encoder=n}decode(t,e){return this.decoder(this.layout.decode(t,e))}encode(t,e,n){return this.layout.encode(this.encoder(t),e,n)}getSpan(t,e){return this.layout.getSpan(t,e)}}class Xn extends bt{constructor(t,e){super(-1,e),this.layout=t,this.discriminator=j()}encode(t,e,n=0){return t==null?this.layout.span+this.discriminator.encode(0,e,n):(this.discriminator.encode(1,e,n),this.layout.encode(t,e,n+4)+4)}decode(t,e=0){const n=this.discriminator.decode(t,e);if(n===0)return null;if(n===1)return this.layout.decode(t,e+4);throw new Error("Invalid coption "+this.layout.property)}getSpan(t,e=0){return this.layout.getSpan(t,e+4)+4}}class Kt extends le{toBuffer(){const t=super.toArray().reverse(),e=O.Buffer.from(t);if(e.length===8)return e;if(e.length>=8)throw new Error("u64 too large");const n=O.Buffer.alloc(8);return e.copy(n),n}static fromBuffer(t){if(t.length!==8)throw new Error(`Invalid buffer length: ${t.length}`);return new Kt([...t].reverse().map(e=>`00${e.toString(16)}`.slice(-2)).join(""),16)}}const Zn=P([yt("mint"),yt("owner"),Tt("amount"),Rt(yt(),"delegate"),(r=>{const t=fe(qe("discriminator"),null,r);return t.addVariant(0,P([]),"uninitialized"),t.addVariant(1,P([]),"initialized"),t.addVariant(2,P([]),"frozen"),t})("state"),Rt(Tt(),"isNative"),Tt("delegatedAmount"),Rt(yt(),"closeAuthority")]);function Jn(r){return Zn.decode(r)}class ct{constructor(t,e,n,o,s,i,c,l){this._accounts=e,this._provider=n,this._programId=o,this._idlIx=s,this._idlTypes=c,this._customResolver=l,this._args=t,this._accountStore=new Yn(n,i,this._programId)}args(t){this._args=t}async resolve(){for(await this.resolveConst(this._idlIx.accounts),this._resolveEventCpi(this._idlIx.accounts);await this.resolvePdas(this._idlIx.accounts)+await this.resolveRelations(this._idlIx.accounts)+await this.resolveCustom()>0;);}async resolveCustom(){if(this._customResolver){const{accounts:t,resolved:e}=await this._customResolver({args:this._args,accounts:this._accounts,provider:this._provider,programId:this._programId,idlIx:this._idlIx});return this._accounts=t,e}return 0}resolveOptionalsHelper(t,e){const n={};for(const o of e){const s=o.name,i=t[s];i!==void 0&&(ke(i)?Bn(o)?n[s]=this.resolveOptionalsHelper(i,o.accounts):n[s]=Te(i,!0):i!==null?n[s]=x(i):o.isOptional&&(n[s]=this._programId))}return n}resolveOptionals(t){Object.assign(this._accounts,this.resolveOptionalsHelper(t,this._idlIx.accounts))}get(t){const e=t.reduce((n,o)=>n&&n[o],this._accounts);if(e&&e.toBase58)return e}set(t,e){let n=this._accounts;t.forEach((o,s)=>{s==t.length-1&&(n[o]=e),n[o]=n[o]||{},n=n[o]})}async resolveConst(t,e=[]){for(let n=0;n<t.length;n+=1){const o=t[n],s=o.accounts;s&&await this.resolveConst(s,[...e,S(o.name)]);const i=o,c=S(o.name);if(i.isSigner&&!this.get([...e,c])){if(this._provider.wallet===void 0)throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");this.set([...e,c],this._provider.wallet.publicKey)}Reflect.has(ct.CONST_ACCOUNTS,c)&&!this.get([...e,c])&&this.set([...e,c],ct.CONST_ACCOUNTS[c])}}_resolveEventCpi(t,e=[]){for(const n in t){const o=t[n],s=o.accounts;s&&this._resolveEventCpi(s,[...e,S(o.name)]);const i=+n+1;if(i===t.length)return;const c=S(t[n].name),l=S(t[i].name);if(c==="eventAuthority"&&l==="program"){const d=[...e,c],f=[...e,l];this.get(d)||this.set(d,k.findProgramAddressSync([O.Buffer.from("__event_authority")],this._programId)[0]),this.get(f)||this.set(f,this._programId);return}}}async resolvePdas(t,e=[]){let n=0;for(let o=0;o<t.length;o+=1){const s=t[o],i=s.accounts;i&&(n+=await this.resolvePdas(i,[...e,S(s.name)]));const c=s,l=S(s.name);c.pda&&c.pda.seeds.length>0&&!this.get([...e,l])&&Boolean(await this.autoPopulatePda(c,e))&&(n+=1)}return n}async resolveRelations(t,e=[]){let n=0;for(let o=0;o<t.length;o+=1){const s=t[o],i=s.accounts;i&&(n+=await this.resolveRelations(i,[...e,S(s.name)]));const c=s.relations||[],l=S(s.name),d=[...e,l],f=this.get(d);if(f){const v=c.filter(g=>!this.get([...e,S(g)]));if(n+=v.length,v.length>0){const g=await this._accountStore.fetchAccount({publicKey:f});await Promise.all(v.map(async p=>{const m=S(p);return this.set([...e,m],g[m]),g[m]}))}}}return n}async autoPopulatePda(t,e=[]){if(!t.pda||!t.pda.seeds)throw new Error("Must have seeds");const n=await Promise.all(t.pda.seeds.map(i=>this.toBuffer(i,e)));if(n.some(i=>typeof i>"u"))return;const o=await this.parseProgramId(t,e);if(!o)return;const[s]=await k.findProgramAddress(n,o);this.set([...e,S(t.name)],s)}async parseProgramId(t,e=[]){var n;if(!(!((n=t.pda)===null||n===void 0)&&n.programId))return this._programId;switch(t.pda.programId.kind){case"const":return new k(this.toBufferConst(t.pda.programId.value));case"arg":return this.argValue(t.pda.programId);case"account":return await this.accountValue(t.pda.programId,e);default:throw new Error(`Unexpected program seed kind: ${t.pda.programId.kind}`)}}async toBuffer(t,e=[]){switch(t.kind){case"const":return this.toBufferConst(t);case"arg":return await this.toBufferArg(t);case"account":return await this.toBufferAccount(t,e);default:throw new Error(`Unexpected seed kind: ${t.kind}`)}}getType(t,e=[]){if(e.length>0&&t.defined){const n=this._idlTypes.find(i=>i.name===t.defined);if(!n)throw new Error(`Cannot find type ${t.defined}`);const s=n.type.fields.find(i=>i.name===e[0]);return this.getType(s.type,e.slice(1))}return t}toBufferConst(t){return this.toBufferValue(this.getType(t.type,(t.path||"").split(".").slice(1)),t.value)}async toBufferArg(t){const e=this.argValue(t);if(!(typeof e>"u"))return this.toBufferValue(this.getType(t.type,(t.path||"").split(".").slice(1)),e)}argValue(t){const e=t.path.split("."),n=S(e[0]),o=this._idlIx.args.findIndex(s=>s.name===n);if(o===-1)throw new Error(`Unable to find argument for seed: ${n}`);return e.slice(1).reduce((s,i)=>(s||{})[i],this._args[o])}async toBufferAccount(t,e=[]){const n=await this.accountValue(t,e);if(!!n)return this.toBufferValue(t.type,n)}async accountValue(t,e=[]){const n=t.path.split("."),o=n[0],s=this.get([...e,S(o)]);if(s===null)throw new Error("fieldPubkey is null");if(n.length===1)return s;const i=await this._accountStore.fetchAccount({publicKey:s,name:t.account});return this.parseAccountValue(i,n.slice(1))}parseAccountValue(t,e){let n;for(;e.length>0;)n=t[S(e[0])],e=e.slice(1);return n}toBufferValue(t,e){switch(t){case"u8":return O.Buffer.from([e]);case"u16":let n=O.Buffer.alloc(2);return n.writeUInt16LE(e),n;case"u32":let o=O.Buffer.alloc(4);return o.writeUInt32LE(e),o;case"u64":let s=O.Buffer.alloc(8);return s.writeBigUInt64LE(BigInt(e)),s;case"string":return O.Buffer.from(Fe(e));case"publicKey":return e.toBuffer();default:if(t.array)return O.Buffer.from(e);throw new Error(`Unexpected seed type: ${t}`)}}}ct.CONST_ACCOUNTS={associatedTokenProgram:On,rent:xe,systemProgram:de.programId,tokenProgram:Rn,clock:Me};class Yn{constructor(t,e,n){this._provider=t,this._programId=n,this._cache=new Map,this._idls={},this._idls[n.toBase58()]=e}async ensureIdl(t){if(!this._idls[t.toBase58()]){const e=await ut.fetchIdl(t,this._provider);if(e){const n=new ut(e,t,this._provider);this._idls[t.toBase58()]=n.account}}return this._idls[t.toBase58()]}async fetchAccount({publicKey:t,name:e,programId:n=this._programId}){const o=t.toString();if(!this._cache.has(o))if(e==="TokenAccount"){const s=await this._provider.connection.getAccountInfo(t);if(s===null)throw new Error(`invalid account info for ${o}`);const i=Jn(s.data);this._cache.set(o,i)}else if(e){const s=await this.ensureIdl(n);if(s){const i=s[S(e)];if(i){const c=await i.fetch(t);this._cache.set(o,c)}}}else{const s=await this._provider.connection.getAccountInfo(t);if(s===null)throw new Error(`invalid account info for ${o}`);const i=s.data,c=await this.ensureIdl(s.owner);if(c){const l=Object.values(c)[0];if(!l)throw new Error("No accounts for this program");const d=l.coder.accounts.decodeAny(i);this._cache.set(o,d)}}return this._cache.get(o)}}class Qn{static build(t,e,n,o,s,i,c,l,d,f,v){return(...g)=>new tr(g,o,s,i,c,l,t,e,n,d,f,v)}}function ke(r){return typeof r=="object"&&r!==null&&!("_bn"in r)}function Te(r,t){const e={};for(const n in r){const o=r[n];if(o===null){if(t)throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");continue}e[n]=ke(o)?Te(o,!0):x(o)}return e}class tr{constructor(t,e,n,o,s,i,c,l,d,f,v,g){this._ixFn=e,this._txFn=n,this._rpcFn=o,this._simulateFn=s,this._viewFn=i,this._programId=l,this._accounts={},this._remainingAccounts=[],this._signers=[],this._preInstructions=[],this._postInstructions=[],this._autoResolveAccounts=!0,this._args=t,this._accountsResolver=new ct(t,this._accounts,c,l,d,f,v,g)}args(t){this._args=t,this._accountsResolver.args(t)}async pubkeys(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._accounts}accounts(t){return this._autoResolveAccounts=!0,this._accountsResolver.resolveOptionals(t),this}accountsStrict(t){return this._autoResolveAccounts=!1,this._accountsResolver.resolveOptionals(t),this}signers(t){return this._signers=this._signers.concat(t),this}remainingAccounts(t){return this._remainingAccounts=this._remainingAccounts.concat(t),this}preInstructions(t){return this._preInstructions=this._preInstructions.concat(t),this}postInstructions(t){return this._postInstructions=this._postInstructions.concat(t),this}async rpc(t){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._rpcFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async rpcAndKeys(t){return{pubkeys:await this.pubkeys(),signature:await this.rpc(t)}}async view(t){if(this._autoResolveAccounts&&await this._accountsResolver.resolve(),!this._viewFn)throw new Error("Method does not support views");return this._viewFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async simulate(t){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._simulateFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions,options:t})}async instruction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._ixFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}async prepare(){return{instruction:await this.instruction(),pubkeys:await this.pubkeys(),signers:await this._signers}}async transaction(){return this._autoResolveAccounts&&await this._accountsResolver.resolve(),this._txFn(...this._args,{accounts:this._accounts,signers:this._signers,remainingAccounts:this._remainingAccounts,preInstructions:this._preInstructions,postInstructions:this._postInstructions})}}class er{static build(t,e,n,o){const s=e.accounts.find(l=>l.isMut),i=!!e.returns;return s||!i?void 0:async(...l)=>{var d,f;let v=await n(...l);const g=`Program return: ${t} `;let p=v.raw.find(T=>T.startsWith(g));if(!p)throw new Error("View expected return log");let m=he(p.slice(g.length)),b=e.returns;if(!b)throw new Error("View expected return type");return R.fieldLayout({type:b},Array.from([...(d=o.accounts)!==null&&d!==void 0?d:[],...(f=o.types)!==null&&f!==void 0?f:[]])).decode(m)}}}class nr{static build(t,e,n,o,s){const i={},c={},l={},d={},f={},v={},g=Ke(t),p=t.accounts?Vn.build(t,e,n,o):{};return t.instructions.forEach(m=>{const b=At.build(m,(J,et)=>e.instruction.encode(J,et),n),L=$n.build(m,b),T=qn.build(m,L,g,o),q=Hn.build(m,L,g,o,e,n,t),G=er.build(n,m,q,t),Z=Qn.build(o,n,m,b,L,T,q,G,p,t.types||[],s&&s(m)),D=S(m.name);c[D]=b,l[D]=L,i[D]=T,d[D]=q,f[D]=Z,G&&(v[D]=G)}),[i,c,l,p,d,f,v]}}class ut{get programId(){return this._programId}get idl(){return this._idl}get coder(){return this._coder}get provider(){return this._provider}constructor(t,e,n,o,s){e=x(e),n||(n=xt()),this._idl=t,this._provider=n,this._programId=e,this._coder=o??new Se(t),this._events=new Kn(this._programId,n,this._coder);const[i,c,l,d,f,v,g]=nr.build(t,this._coder,e,n,s??(()=>{}));this.rpc=i,this.instruction=c,this.transaction=l,this.account=d,this.simulate=f,this.methods=v,this.views=g}static async at(t,e){const n=x(t),o=await ut.fetchIdl(n,e);if(!o)throw new Error(`IDL not found for program: ${t.toString()}`);return new ut(o,n,e)}static async fetchIdl(t,e){e=e??xt();const n=x(t),o=await Nn(n),s=await e.connection.getAccountInfo(o);if(!s)return null;let i=Dn(s.data.slice(8));const c=Ve(i.data);return JSON.parse(ze(c))}addEventListener(t,e){return this._events.addEventListener(t,e)}async removeEventListener(t){return await this._events.removeEventListener(t)}}new k("11111111111111111111111111111111");at||(exports.workspace=require("./workspace.js").default,exports.Wallet=require("./nodewallet.js").default);export{Y as A,ut as P,Fe as e};
