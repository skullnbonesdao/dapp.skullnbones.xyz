import{bX as _,d7 as vt,d6 as j,d8 as At}from"./index.6f9d9acd.js";import{b as x}from"./assert.fbaabdee.js";var Ue={},S={},h={};Object.defineProperty(h,"__esModule",{value:!0});h.isElementCollectionFixedSizeBeet=h.isFixableBeet=h.assertFixedSizeBeet=h.isFixedSizeBeet=h.BEET_TYPE_ARG_INNER=h.BEET_TYPE_ARG_LEN=h.BEET_PACKAGE=void 0;const wt=x.exports;h.BEET_PACKAGE="@metaplex-foundation/beet";h.BEET_TYPE_ARG_LEN="len";h.BEET_TYPE_ARG_INNER="Beet<{innner}>";function ut(e){return Object.keys(e).includes("byteSize")}h.isFixedSizeBeet=ut;function zt(e,r=`${e} should have been a fixed beet`){(0,wt.strict)(ut(e),r)}h.assertFixedSizeBeet=zt;function Bt(e){return typeof e.toFixedFromData=="function"&&typeof e.toFixedFromValue=="function"}h.isFixableBeet=Bt;function Tt(e){const r=Object.keys(e);return r.includes("length")&&r.includes("elementByteSize")&&r.includes("lenPrefixByteSize")}h.isElementCollectionFixedSizeBeet=Tt;var K={};(function(e){var r=_&&_.__importDefault||function(o){return o&&o.__esModule?o:{default:o}};Object.defineProperty(e,"__esModule",{value:!0}),e.numbersTypeMap=e.bool=e.i512=e.i256=e.i128=e.i64=e.i32=e.i16=e.i8=e.u512=e.u256=e.u128=e.u64=e.u32=e.u16=e.u8=void 0;const t=r(vt.exports),i=h;e.u8={write:function(o,s,c){o.writeUInt8(c,s)},read:function(o,s){return o.readUInt8(s)},byteSize:1,description:"u8"},e.u16={write:function(o,s,c){o.writeUInt16LE(c,s)},read:function(o,s){return o.readUInt16LE(s)},byteSize:2,description:"u16"},e.u32={write:function(o,s,c){o.writeUInt32LE(c,s)},read:function(o,s){return o.readUInt32LE(s)},byteSize:4,description:"u32"};function n(o,s){return{write:function(c,d,u){const b=(t.default.isBN(u)?u:new t.default(u)).toArray("le",this.byteSize);j.Buffer.from(b).copy(c,d,0,this.byteSize)},read:function(c,d){const u=c.slice(d,d+this.byteSize);return new t.default(u,"le")},byteSize:o,description:s}}e.u64=n(8,"u64"),e.u128=n(16,"u128"),e.u256=n(32,"u256"),e.u512=n(64,"u512"),e.i8={write:function(o,s,c){o.writeInt8(c,s)},read:function(o,s){return o.readInt8(s)},byteSize:1,description:"i8"},e.i16={write:function(o,s,c){o.writeInt16LE(c,s)},read:function(o,s){return o.readInt16LE(s)},byteSize:2,description:"i16"},e.i32={write:function(o,s,c){o.writeInt32LE(c,s)},read:function(o,s){return o.readInt32LE(s)},byteSize:4,description:"i32"};function a(o,s){const c=o*8;return{write:function(d,u,l){const f=(t.default.isBN(l)?l:new t.default(l)).toTwos(c).toArray("le",this.byteSize);j.Buffer.from(f).copy(d,u,0,this.byteSize)},read:function(d,u){const l=d.slice(u,u+this.byteSize);return new t.default(l,"le").fromTwos(c)},byteSize:o,description:s}}e.i64=a(8,"i64"),e.i128=a(16,"i128"),e.i256=a(32,"i256"),e.i512=a(64,"i512"),e.bool={write:function(o,s,c){const d=c?1:0;e.u8.write(o,s,d)},read:function(o,s){return e.u8.read(o,s)===1},byteSize:1,description:"bool"},e.numbersTypeMap={u8:{beet:"u8",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"number"},u16:{beet:"u16",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"number"},u32:{beet:"u32",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"number"},i8:{beet:"i8",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"number"},i16:{beet:"i16",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"number"},i32:{beet:"i32",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"number"},bool:{beet:"bool",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"boolean"},u64:{beet:"u64",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"bignum",pack:i.BEET_PACKAGE},u128:{beet:"u128",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"bignum",pack:i.BEET_PACKAGE},u256:{beet:"u256",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"bignum",pack:i.BEET_PACKAGE},u512:{beet:"u512",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"bignum",pack:i.BEET_PACKAGE},i64:{beet:"i64",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"bignum",pack:i.BEET_PACKAGE},i128:{beet:"i128",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"bignum",pack:i.BEET_PACKAGE},i256:{beet:"i256",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"bignum",pack:i.BEET_PACKAGE},i512:{beet:"i512",isFixable:!1,sourcePack:i.BEET_PACKAGE,ts:"bignum",pack:i.BEET_PACKAGE}}})(K);var E={},me={exports:{}},ie=1e3,ne=ie*60,oe=ne*60,Y=oe*24,Pt=Y*7,xt=Y*365.25,$t=function(e,r){r=r||{};var t=typeof e;if(t==="string"&&e.length>0)return Mt(e);if(t==="number"&&isFinite(e))return r.long?It(e):Ot(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))};function Mt(e){if(e=String(e),!(e.length>100)){var r=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(!!r){var t=parseFloat(r[1]),i=(r[2]||"ms").toLowerCase();switch(i){case"years":case"year":case"yrs":case"yr":case"y":return t*xt;case"weeks":case"week":case"w":return t*Pt;case"days":case"day":case"d":return t*Y;case"hours":case"hour":case"hrs":case"hr":case"h":return t*oe;case"minutes":case"minute":case"mins":case"min":case"m":return t*ne;case"seconds":case"second":case"secs":case"sec":case"s":return t*ie;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function Ot(e){var r=Math.abs(e);return r>=Y?Math.round(e/Y)+"d":r>=oe?Math.round(e/oe)+"h":r>=ne?Math.round(e/ne)+"m":r>=ie?Math.round(e/ie)+"s":e+"ms"}function It(e){var r=Math.abs(e);return r>=Y?fe(e,r,Y,"day"):r>=oe?fe(e,r,oe,"hour"):r>=ne?fe(e,r,ne,"minute"):r>=ie?fe(e,r,ie,"second"):e+" ms"}function fe(e,r,t,i){var n=r>=t*1.5;return Math.round(e/t)+" "+i+(n?"s":"")}function kt(e){t.debug=t,t.default=t,t.coerce=c,t.disable=a,t.enable=n,t.enabled=o,t.humanize=$t,t.destroy=d,Object.keys(e).forEach(u=>{t[u]=e[u]}),t.names=[],t.skips=[],t.formatters={};function r(u){let l=0;for(let b=0;b<u.length;b++)l=(l<<5)-l+u.charCodeAt(b),l|=0;return t.colors[Math.abs(l)%t.colors.length]}t.selectColor=r;function t(u){let l,b=null,f,y;function p(...g){if(!p.enabled)return;const m=p,C=Number(new Date),w=C-(l||C);m.diff=w,m.prev=l,m.curr=C,l=C,g[0]=t.coerce(g[0]),typeof g[0]!="string"&&g.unshift("%O");let F=0;g[0]=g[0].replace(/%([a-zA-Z%])/g,(v,B)=>{if(v==="%%")return"%";F++;const q=t.formatters[B];if(typeof q=="function"){const Ft=g[F];v=q.call(m,Ft),g.splice(F,1),F--}return v}),t.formatArgs.call(m,g),(m.log||t.log).apply(m,g)}return p.namespace=u,p.useColors=t.useColors(),p.color=t.selectColor(u),p.extend=i,p.destroy=t.destroy,Object.defineProperty(p,"enabled",{enumerable:!0,configurable:!1,get:()=>b!==null?b:(f!==t.namespaces&&(f=t.namespaces,y=t.enabled(u)),y),set:g=>{b=g}}),typeof t.init=="function"&&t.init(p),p}function i(u,l){const b=t(this.namespace+(typeof l>"u"?":":l)+u);return b.log=this.log,b}function n(u){t.save(u),t.namespaces=u,t.names=[],t.skips=[];let l;const b=(typeof u=="string"?u:"").split(/[\s,]+/),f=b.length;for(l=0;l<f;l++)!b[l]||(u=b[l].replace(/\*/g,".*?"),u[0]==="-"?t.skips.push(new RegExp("^"+u.slice(1)+"$")):t.names.push(new RegExp("^"+u+"$")))}function a(){const u=[...t.names.map(s),...t.skips.map(s).map(l=>"-"+l)].join(",");return t.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let l,b;for(l=0,b=t.skips.length;l<b;l++)if(t.skips[l].test(u))return!1;for(l=0,b=t.names.length;l<b;l++)if(t.names[l].test(u))return!0;return!1}function s(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function c(u){return u instanceof Error?u.stack||u.message:u}function d(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.enable(t.load()),t}var Lt=kt;(function(e,r){r.formatArgs=i,r.save=n,r.load=a,r.useColors=t,r.storage=o(),r.destroy=(()=>{let c=!1;return()=>{c||(c=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),r.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function t(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function i(c){if(c[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+c[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const d="color: "+this.color;c.splice(1,0,d,"color: inherit");let u=0,l=0;c[0].replace(/%[a-zA-Z%]/g,b=>{b!=="%%"&&(u++,b==="%c"&&(l=u))}),c.splice(l,0,d)}r.log=console.debug||console.log||(()=>{});function n(c){try{c?r.storage.setItem("debug",c):r.storage.removeItem("debug")}catch{}}function a(){let c;try{c=r.storage.getItem("debug")}catch{}return!c&&typeof j.process<"u"&&"env"in j.process&&(c={}.DEBUG),c}function o(){try{return localStorage}catch{}}e.exports=Lt(r);const{formatters:s}=e.exports;s.j=function(c){try{return JSON.stringify(c)}catch(d){return"[UnexpectedJSONParseError]: "+d.message}}})(me,me.exports);var Ze={white:37,black:30,blue:34,cyan:36,green:32,magenta:35,red:31,yellow:33,brightBlack:90,brightRed:91,brightGreen:92,brightYellow:93,brightBlue:94,brightMagenta:95,brightCyan:96,brightWhite:97},Je={bgBlack:40,bgRed:41,bgGreen:42,bgYellow:43,bgBlue:44,bgMagenta:45,bgCyan:46,bgWhite:47,bgBrightBlack:100,bgBrightRed:101,bgBrightGreen:102,bgBrightYellow:103,bgBrightBlue:104,bgBrightMagenta:105,bgBrightCyan:106,bgBrightWhite:107},Re={},Ve={},le={};Object.keys(Ze).forEach(function(e){var r=Re[e]="\x1B["+Ze[e]+"m",t=Ve[e]="\x1B[39m";le[e]=function(i){return r+i+t}});Object.keys(Je).forEach(function(e){var r=Re[e]="\x1B["+Je[e]+"m",t=Ve[e]="\x1B[49m";le[e]=function(i){return r+i+t}});var dt=le;le.open=Re;le.close=Ve;var lt=_&&_.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(E,"__esModule",{value:!0});E.UnreachableCaseError=E.stringify=E.bytes=E.beetBytes=E.logTrace=E.logDebug=E.logInfo=E.logError=void 0;const _e=lt(me.exports),Dt=lt(dt),Xe=h,{brightBlack:ft}=Dt.default;E.logError=(0,_e.default)("beet:error");E.logInfo=(0,_e.default)("beet:info");E.logDebug=(0,_e.default)("beet:debug");E.logTrace=(0,_e.default)("beet:trace");function Nt(e,r=!1){let t;if((0,Xe.isFixableBeet)(e))t="? B";else if((0,Xe.isElementCollectionFixedSizeBeet)(e)){const i=r?"length":e.length,n=e.lenPrefixByteSize;t=n>0?`${n} + (${e.elementByteSize} * ${i}) B  (${e.byteSize} B)`:`(${e.elementByteSize} * ${i}) B (${e.byteSize} B)`}else t=`${e.byteSize} B`;return ft(t)}E.beetBytes=Nt;function jt(e){return ft(`${e} B`)}E.bytes=jt;function Gt(e){return e.toString==="function"?e.toString():e}E.stringify=Gt;class Kt extends Error{constructor(r){super(`Unreachable case: ${r}`)}}E.UnreachableCaseError=Kt;var I={};Object.defineProperty(I,"__esModule",{value:!0});I.fixBeetFromValue=I.fixBeetFromData=void 0;const pe=h,bt=E;function Ut(e,r,t){if((0,pe.isFixedSizeBeet)(e))return e;if((0,pe.isFixableBeet)(e))return e.toFixedFromData(r,t);throw new bt.UnreachableCaseError(e)}I.fixBeetFromData=Ut;function Rt(e,r){if((0,pe.isFixedSizeBeet)(e))return e;if((0,pe.isFixableBeet)(e))return e.toFixedFromValue(r);throw new bt.UnreachableCaseError(e)}I.fixBeetFromValue=Rt;Object.defineProperty(S,"__esModule",{value:!0});S.collectionsTypeMap=S.uint8Array=S.fixedSizeUint8Array=S.fixedSizeBuffer=S.array=S.fixedSizeArray=S.uniformFixedSizeArray=void 0;const ee=h,W=x.exports,U=K,te=h,gt=E,Qe=I;function Vt(e,r,t=!1){const i=e.byteSize*r,n=t?4+i:i;return{write:function(a,o,s){W.strict.equal(s.length,r,`array length ${s.length} should match len ${r}`),t&&(U.u32.write(a,o,r),o+=4);for(let c=0;c<r;c++)e.write(a,o+c*e.byteSize,s[c])},read:function(a,o){if(t){const c=U.u32.read(a,o);W.strict.equal(c,r,"invalid byte size"),o+=4}const s=new Array(r);for(let c=0;c<r;c++)s[c]=e.read(a,o+c*e.byteSize);return s},byteSize:n,length:r,elementByteSize:e.byteSize,lenPrefixByteSize:4,description:`Array<${e.description}>(${r})`}}S.uniformFixedSizeArray=Vt;function $e(e,r){const t=e.length,i=t===0?"<EMPTY>":e[0].description;return{write:function(n,a,o){W.strict.equal(o.length,t,`array length ${o.length} should match len ${t}`),U.u32.write(n,a,t);let s=a+4;for(let c=0;c<t;c++){const d=e[c];d.write(n,s,o[c]),s+=d.byteSize}},read:function(n,a){const o=U.u32.read(n,a);W.strict.equal(o,t,"invalid byte size");let s=a+4;const c=new Array(t);for(let d=0;d<t;d++){const u=e[d];c[d]=u.read(n,s),s+=u.byteSize}return c},byteSize:4+r,length:t,description:`Array<${i}>(${t})[ 4 + ${r} ]`}}S.fixedSizeArray=$e;function qt(e){return{toFixedFromData(r,t){const i=U.u32.read(r,t);(0,gt.logTrace)(`${this.description}[${i}]`);const n=t+4;let a=n;const o=new Array(i);for(let s=0;s<i;s++){const c=(0,Qe.fixBeetFromData)(e,r,a);o[s]=c,a+=c.byteSize}return $e(o,a-n)},toFixedFromValue(r){(0,W.strict)(Array.isArray(r),`${r} should be an array`);let t=0;const i=new Array(r.length);for(let n=0;n<r.length;n++){const a=(0,Qe.fixBeetFromValue)(e,r[n]);i[n]=a,t+=a.byteSize}return $e(i,t)},description:"array"}}S.array=qt;function yt(e){return{write:function(r,t,i){i.copy(r,t,0,e)},read:function(r,t){return r.slice(t,t+e)},byteSize:e,description:`Buffer(${e})`}}S.fixedSizeBuffer=yt;function Me(e,r=!1){const t=yt(e),i=r?e+4:e;return{write:function(n,a,o){W.strict.equal(o.byteLength,e,`Uint8Array length ${o.byteLength} should match len ${e}`),r&&(U.u32.write(n,a,e),a+=4);const s=j.Buffer.from(o);t.write(n,a,s)},read:function(n,a){if(r){const s=U.u32.read(n,a);W.strict.equal(s,e,"invalid byte size"),a+=4}const o=t.read(n,a);return Uint8Array.from(o)},byteSize:i,description:`Uint8Array(${e})`}}S.fixedSizeUint8Array=Me;S.uint8Array={toFixedFromData(e,r){const t=U.u32.read(e,r);return(0,gt.logTrace)(`${this.description}[${t}]`),Me(t,!0)},toFixedFromValue(e){const r=e.byteLength;return Me(r,!0)},description:"Uint8Array"};S.collectionsTypeMap={Array:{beet:"array",isFixable:!0,sourcePack:te.BEET_PACKAGE,ts:"Array",arg:ee.BEET_TYPE_ARG_LEN},FixedSizeArray:{beet:"fixedSizeArray",isFixable:!1,sourcePack:te.BEET_PACKAGE,ts:"Array",arg:ee.BEET_TYPE_ARG_LEN},UniformFixedSizeArray:{beet:"uniformFixedSizeArray",isFixable:!1,sourcePack:te.BEET_PACKAGE,ts:"Array",arg:ee.BEET_TYPE_ARG_LEN},Buffer:{beet:"fixedSizeBuffer",isFixable:!1,sourcePack:te.BEET_PACKAGE,ts:"Buffer",arg:ee.BEET_TYPE_ARG_LEN},FixedSizeUint8Array:{beet:"fixedSizeUint8Array",isFixable:!1,sourcePack:te.BEET_PACKAGE,ts:"Uint8Array",arg:ee.BEET_TYPE_ARG_LEN},Uint8Array:{beet:"uint8Array",isFixable:!0,sourcePack:te.BEET_PACKAGE,ts:"Uint8Array",arg:ee.BEET_TYPE_ARG_LEN}};var A={};Object.defineProperty(A,"__esModule",{value:!0});A.compositesTypeMap=A.coption=A.coptionSome=A.coptionNone=A.isNoneBuffer=A.isSomeBuffer=void 0;const ue=x.exports,Oe=h,He=h,mt=E,et=I,pt=0,ht=1;function qe(e,r){return e[r]===ht}A.isSomeBuffer=qe;function Ye(e,r){return e[r]===pt}A.isNoneBuffer=Ye;function Ie(e){return(0,mt.logTrace)(`coptionNone(${e})`),{write:function(r,t,i){(0,ue.strict)(i==null,"coptionNone can only handle `null` values"),r[t]=pt},read:function(r,t){return(0,ue.strict)(Ye(r,t),"coptionNone can only handle `NONE` data"),null},byteSize:1,description:`COption<None(${e})>`}}A.coptionNone=Ie;function ke(e){const r=1+e.byteSize,t={write:function(i,n,a){(0,Oe.assertFixedSizeBeet)(e,`coption inner type ${e.description} needs to be fixed before calling write`),(0,ue.strict)(a!=null,"coptionSome cannot handle `null` values"),i[n]=ht,e.write(i,n+1,a)},read:function(i,n){return(0,Oe.assertFixedSizeBeet)(e,`coption inner type ${e.description} needs to be fixed before calling read`),(0,ue.strict)(qe(i,n),"coptionSome can only handle `SOME` data"),e.read(i,n+1)},description:`COption<${e.description}>[1 + ${e.byteSize}]`,byteSize:r,inner:e};return(0,mt.logTrace)(t.description),t}A.coptionSome=ke;function Yt(e){return{toFixedFromData(r,t){if(qe(r,t)){const i=(0,et.fixBeetFromData)(e,r,t+1);return ke(i)}else return(0,ue.strict)(Ye(r,t),`Expected ${r} to hold a COption`),Ie(e.description)},toFixedFromValue(r){return r==null?Ie(e.description):ke((0,et.fixBeetFromValue)(e,r))},description:`COption<${e.description}>`}}A.coption=Yt;A.compositesTypeMap={option:{beet:"coption",isFixable:!0,sourcePack:He.BEET_PACKAGE,ts:"COption<Inner>",arg:Oe.BEET_TYPE_ARG_INNER,pack:He.BEET_PACKAGE}};var Le={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.stringTypeMap=e.utf8String=e.fixedSizeUtf8String=void 0;const r=h,t=x.exports,i=K,n=E,a=o=>({write:function(s,c,d){const u=j.Buffer.from(d,"utf8");t.strict.equal(u.byteLength,o,`${d} has invalid byte size`),i.u32.write(s,c,o),u.copy(s,c+4,0,o)},read:function(s,c){const d=i.u32.read(s,c);return t.strict.equal(d,o,"invalid byte size"),s.slice(c+4,c+4+o).toString("utf8")},elementByteSize:1,length:o,lenPrefixByteSize:4,byteSize:4+o,description:`Utf8String(4 + ${o})`});e.fixedSizeUtf8String=a,e.utf8String={toFixedFromData(o,s){const c=i.u32.read(o,s);return(0,n.logTrace)(`${this.description}[${c}]`),(0,e.fixedSizeUtf8String)(c)},toFixedFromValue(o){const s=j.Buffer.from(o).byteLength;return(0,e.fixedSizeUtf8String)(s)},description:"Utf8String"},e.stringTypeMap={fixedSizeString:{beet:"fixedSizeUtf8String",isFixable:!1,sourcePack:r.BEET_PACKAGE,ts:"string",arg:r.BEET_TYPE_ARG_LEN},string:{beet:"utf8String",isFixable:!0,sourcePack:r.BEET_PACKAGE,ts:"string"}}})(Le);var T={},O={},Z={};Object.defineProperty(Z,"__esModule",{value:!0});Z.BeetReader=Z.BeetWriter=void 0;const Wt=x.exports;class Zt{constructor(r){this.buf=j.Buffer.alloc(r),this._offset=0}get buffer(){return this.buf}get offset(){return this._offset}maybeResize(r){this._offset+r>this.buf.length&&Wt.strict.fail(`We shouldn't ever need to resize, but ${this._offset+r} > ${this.buf.length}`)}write(r,t){this.maybeResize(r.byteSize),r.write(this.buf,this._offset,t),this._offset+=r.byteSize}writeStruct(r,t){for(const[i,n]of t){const a=r[i];this.write(n,a)}}}Z.BeetWriter=Zt;class Jt{constructor(r,t=0){this.buffer=r,this._offset=t}get offset(){return this._offset}read(r){const t=r.read(this.buffer,this._offset);return this._offset+=r.byteSize,t}readStruct(r){const t={};for(const[i,n]of r)t[i]=this.read(n);return t}}Z.BeetReader=Jt;Object.defineProperty(O,"__esModule",{value:!0});O.BeetArgsStruct=O.isBeetStruct=O.BeetStruct=void 0;const tt=Z,L=E;class R{constructor(r,t,i=R.description){if(this.fields=r,this.construct=t,this.description=i,this.byteSize=this.getByteSize(),L.logDebug.enabled){const n=r.map(([a,o])=>`${String(a)}: ${o.description} ${(0,L.beetBytes)(o)}`).join(`
  `);(0,L.logDebug)(`struct ${i} {
  ${n}
} ${(0,L.beetBytes)(this)}`)}}read(r,t){const[i]=this.deserialize(r,t);return i}write(r,t,i){const[n,a]=this.serialize(i);n.copy(r,t,0,a)}deserialize(r,t=0){L.logTrace.enabled&&((0,L.logTrace)("deserializing [%s] from %d bytes buffer",this.description,r.byteLength),(0,L.logTrace)(r),(0,L.logTrace)(r.toJSON().data));const i=new tt.BeetReader(r,t),n=i.readStruct(this.fields);return[this.construct(n),i.offset]}serialize(r,t=this.byteSize){(0,L.logTrace)("serializing [%s] %o to %d bytes buffer",this.description,r,t);const i=new tt.BeetWriter(t);return i.writeStruct(r,this.fields),[i.buffer,i.offset]}getByteSize(){return this.fields.reduce((r,[t,i])=>r+i.byteSize,0)}get type(){return R.TYPE}}O.BeetStruct=R;R.description="BeetStruct";R.TYPE="BeetStruct";function Xt(e){return e.type===R.TYPE}O.isBeetStruct=Xt;class Ee extends R{constructor(r,t=Ee.description){super(r,i=>i,t)}}O.BeetArgsStruct=Ee;Ee.description="BeetArgsStruct";var D={},Qt=_&&_.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(D,"__esModule",{value:!0});D.FixableBeetArgsStruct=D.isFixableBeetStruct=D.FixableBeetStruct=void 0;const rt=I,be=O,Ht=h,er=x.exports,ze=E,tr=Qt(dt),{brightBlack:rr}=tr.default;class ${constructor(r,t,i=$.description){this.fields=r,this.construct=t,this.description=i;let n=0;if(ze.logDebug.enabled){const a=r.map(([s,c])=>((0,Ht.isFixedSizeBeet)(c)&&(n+=c.byteSize),`${s}: ${c.description} ${(0,ze.beetBytes)(c)}`)).join(`
  `),o=`> ${n} B`;(0,ze.logDebug)(`struct ${i} {
  ${a}
} ${rr(o)}`)}}deserialize(r,t=0){return this.toFixedFromData(r,t).deserialize(r,t)}serialize(r,t){return this.toFixedFromValue(r).serialize(r,t)}toFixedFromData(r,t){let i=t;const n=new Array(this.fields.length);for(let a=0;a<this.fields.length;a++){const[o,s]=this.fields[a],c=(0,rt.fixBeetFromData)(s,r,i);n[a]=[o,c],i+=c.byteSize}return this.description!==$.description?new be.BeetStruct(n,this.construct,this.description):new be.BeetStruct(n,this.construct)}toFixedFromValue(r){const t=Object.keys(r),i=new Array(this.fields.length);for(let n=0;n<this.fields.length;n++){const[a,o]=this.fields[n];(0,er.strict)(t.includes(a),`Value with keys [ ${t} ] should include struct key '${a}' but doesn't.`);const s=r[a],c=(0,rt.fixBeetFromValue)(o,s);i[n]=[a,c]}return this.description!==$.description?new be.BeetStruct(i,this.construct,this.description):new be.BeetStruct(i,this.construct)}get type(){return $.TYPE}}D.FixableBeetStruct=$;$.description="FixableBeetStruct";$.TYPE="FixableBeetStruct";function ir(e){return e.type===$.TYPE}D.isFixableBeetStruct=ir;class Ce extends ${constructor(r,t=Ce.description){super(r,i=>i,t)}}D.FixableBeetArgsStruct=Ce;Ce.description="FixableBeetArgsStruct";var V={};Object.defineProperty(V,"__esModule",{value:!0});V.unitTypeMap=V.unit=void 0;const nr=h;V.unit={write:function(e,r,t){},read:function(e,r){},byteSize:0,description:"unit"};V.unitTypeMap={unit:{beet:"unit",isFixable:!1,sourcePack:nr.BEET_PACKAGE,ts:"void"}};Object.defineProperty(T,"__esModule",{value:!0});T.enumsTypeMap=T.dataEnum=T.uniformDataEnum=T.fixedScalarEnum=void 0;const G=h,P=K,re=x.exports,or=O,ar=D,sr=V;function it(e,r){return r?`${e}`:e}function cr(e){const r=Object.keys(e);return{write(t,i,n){const a=typeof n=="number",o=it(n,a);if(r.includes(o)||re.strict.fail(`${n} should be a variant of the provided enum type, i.e. [ ${Object.values(e).join(", ")} ], but isn't`),a)P.u8.write(t,i,n);else{const s=e[o];P.u8.write(t,i,s)}},read(t,i){const n=P.u8.read(t,i),a=typeof n=="number",o=it(n,a);return r.includes(o)||re.strict.fail(`${n} should be a of a variant of the provided enum type, i.e. [ ${Object.values(e).join(", ")} ], but isn't`),a?n:e[o]},byteSize:P.u8.byteSize,description:"Enum"}}T.fixedScalarEnum=cr;function ur(e){return{write:function(r,t,i){P.u8.write(r,t,i.kind),e.write(r,t+1,i.data)},read:function(r,t){const i=P.u8.read(r,t),n=e.read(r,t+1);return{kind:i,data:n}},byteSize:1+e.byteSize,description:`UniformDataEnum<${e.description}>`}}T.uniformDataEnum=ur;function nt(e,r,t){return{write(i,n,a){P.u8.write(i,n,r),e.write(i,n+P.u8.byteSize,a)},read(i,n){const a=e.read(i,n+P.u8.byteSize);return{__kind:t,...a}},byteSize:e.byteSize+P.u8.byteSize,description:`EnumData<${e.description}>`}}function dr(e){for(const[r,t]of e)(0,re.strict)((0,or.isBeetStruct)(t)||(0,ar.isFixableBeetStruct)(t)||t===sr.unit,"dataEnum: variants must be a data beet struct or a scalar unit");return{toFixedFromData(r,t){const i=P.u8.read(r,t),n=e[i];(0,re.strict)(n!=null,`Discriminant ${i} out of range for ${e.length} variants`);const[a,o]=n,s=(0,G.isFixedSizeBeet)(o)?o:o.toFixedFromData(r,t+1);return nt(s,i,a)},toFixedFromValue(r){if(r.__kind==null){const d=Object.keys(r).join(", "),u=e.map(([l])=>l).join(", ");re.strict.fail(`Value with fields [ ${d} ] is missing __kind, which needs to be set to one of [ ${u} ]`)}const t=e.findIndex(([d])=>d===r.__kind);if(t<0){const d=e.map(([u])=>u).join(", ");re.strict.fail(`${r.__kind} is not a valid kind, needs to be one of [ ${d} ]`)}const i=e[t],{__kind:n,...a}=r,[o,s]=i,c=(0,G.isFixedSizeBeet)(s)?s:s.toFixedFromValue(a);return nt(c,t,o)},description:`DataEnum<${e.length} variants>`}}T.dataEnum=dr;T.enumsTypeMap={fixedScalarEnum:{beet:"fixedScalarEnum",isFixable:!1,sourcePack:G.BEET_PACKAGE,ts:"<TypeName>",arg:G.BEET_TYPE_ARG_INNER,pack:G.BEET_PACKAGE},dataEnum:{beet:"dataEnum",isFixable:!1,sourcePack:G.BEET_PACKAGE,ts:"DataEnum<Kind, Inner>",arg:G.BEET_TYPE_ARG_INNER,pack:G.BEET_PACKAGE}};var J={};Object.defineProperty(J,"__esModule",{value:!0});J.aliasesTypeMap=J.bytes=void 0;const _t=S;J.bytes=_t.uint8Array;J.aliasesTypeMap={bytes:_t.collectionsTypeMap.Uint8Array};var N={};Object.defineProperty(N,"__esModule",{value:!0});N.tuplesTypeMap=N.tuple=N.fixedSizeTuple=void 0;const ot=h,De=x.exports,at=I;function Ne(e){const r=e.length,t=e.map(a=>a.description),i=e.map(a=>a.byteSize),n=i.reduce((a,o)=>a+o,0);return{write:function(a,o,s){De.strict.equal(s.length,r,`tuple value element size ${s.length} should match len ${r}`);let c=o;for(let d=0;d<r;d++){const u=s[d],l=e[d];l.write(a,c,u),c+=l.byteSize}},read:function(a,o){const s=[];let c=o;for(let d=0;d<r;d++){const u=e[d];s[d]=u.read(a,c),c+=u.byteSize}return s},byteSize:n,length:r,description:`FixedSizeTuple<${t.join(",")}>[ ${i.join(", ")} ]`}}N.fixedSizeTuple=Ne;function lr(e){const r=e.length,t=e.map(i=>i.description);return{toFixedFromData(i,n){let a=n;const o=new Array(r);for(let s=0;s<r;s++){const c=(0,at.fixBeetFromData)(e[s],i,a);o[s]=c,a+=c.byteSize}return Ne(o)},toFixedFromValue(i){(0,De.strict)(Array.isArray(i),`${i} should be an array of tuple values`),De.strict.equal(i.length,r,`There should be ${r} tuple values, but there are ${i.length}`);const n=new Array(r);for(let a=0;a<i.length;a++){const o=(0,at.fixBeetFromValue)(e[a],i[a]);n[a]=o}return Ne(n)},description:`Tuple<${t.join(",")}>`}}N.tuple=lr;N.tuplesTypeMap={Tuple:{beet:"tuple",isFixable:!0,sourcePack:ot.BEET_PACKAGE,ts:"[__tuple_elements__]"},FixedSizeTuple:{beet:"fixedSizeTuple",isFixable:!1,sourcePack:ot.BEET_PACKAGE,ts:"[__tuple_elements__]"}};var X={};Object.defineProperty(X,"__esModule",{value:!0});X.mapsTypeMap=X.map=void 0;const de=h,je=K,fr=E,Be=x.exports;function ge(e,r,t,i){const n=(0,de.isFixedSizeBeet)(e),a=(0,de.isFixedSizeBeet)(r);function o(){if(n&&a){const d=e.byteSize+r.byteSize;return{elementByteSize:d,byteSize:4+i*d}}else if(n){let d=0;for(const[l,b]of t.values())d+=b.byteSize;return{elementByteSize:e.byteSize+Math.ceil(d/i),byteSize:4+e.byteSize*i+d}}else if(a){let d=0;for(const[l,b]of t.values())d+=l.byteSize;return{elementByteSize:Math.ceil(d/i)+r.byteSize,byteSize:4+d+r.byteSize*i}}else{let d=0,u=0;for(const[b,f]of t.values())d+=b.byteSize,u+=f.byteSize;return{elementByteSize:Math.ceil(d/i+u/i),byteSize:4+d+u}}}const{elementByteSize:s,byteSize:c}=o();return{write:function(d,u,l){let b=u+4,f=0;for(const[y,p]of l.entries()){let g=n?e:null,m=a?r:null;if(g==null||m==null){const C=t.get(y);(0,Be.strict)(C!=null,`Should be able to find beet els for ${(0,fr.stringify)(y)}, but could not`),g??(g=C[0]),m??(m=C[1])}g.write(d,b,y),b+=g.byteSize,m.write(d,b,p),b+=m.byteSize,f++}je.u32.write(d,u,f),Be.strict.equal(f,i,`Expected map to have size ${i}, but has ${f}.`)},read:function(d,u){const l=je.u32.read(d,u);Be.strict.equal(l,i,`Expected map to have size ${i}, but has ${l}.`);let b=u+4;const f=new Map;for(let y=0;y<l;y++){const p=n?e:e.toFixedFromData(d,b),g=p.read(d,b);b+=p.byteSize;const m=a?r:r.toFixedFromData(d,b),C=m.read(d,b);b+=m.byteSize,f.set(g,C)}return f},elementByteSize:s,byteSize:c,length:i,lenPrefixByteSize:4,description:`Map<${e.description}, ${r.description}>`}}function br(e,r){const t=(0,de.isFixedSizeBeet)(e),i=(0,de.isFixedSizeBeet)(r);return{toFixedFromData(n,a){const o=je.u32.read(n,a);let s=a+4;if(t&&i)return ge(e,r,new Map,o);const c=new Map;for(let d=0;d<o;d++){const u=t?e:e.toFixedFromData(n,s),l=u.read(n,s);s+=u.byteSize;const b=i?r:r.toFixedFromData(n,s);s+=b.byteSize,c.set(l,[u,b])}return ge(e,r,c,o)},toFixedFromValue(n){const a=n.size;if(t&&i)return ge(e,r,new Map,a);const o=new Map;for(const[s,c]of n){const d=t?e:e.toFixedFromValue(s),u=i?r:r.toFixedFromValue(c);o.set(s,[d,u])}return ge(e,r,o,a)},description:`FixableMap<${e.description}, ${r.description}>`}}X.map=br;X.mapsTypeMap={Map:{beet:"map",isFixable:!0,sourcePack:de.BEET_PACKAGE,ts:"Map"}};var Q={};Object.defineProperty(Q,"__esModule",{value:!0});Q.setsTypeMap=Q.set=void 0;const We=h,Ge=K,gr=E,Te=x.exports;function ye(e,r,t){const i=(0,We.isFixedSizeBeet)(e);function n(){if(i){const s=e.byteSize;return{elementByteSize:s,byteSize:4+t*s}}else{let s=0;for(const d of r.values())s+=d.byteSize;return{elementByteSize:Math.ceil(s/t),byteSize:4+s}}}const{elementByteSize:a,byteSize:o}=n();return{write:function(s,c,d){let u=c+4,l=0;for(const b of d.keys()){let f=i?e:null;if(f==null){const y=r.get(b);(0,Te.strict)(y!=null,`Should be able to find beet el for ${(0,gr.stringify)(b)}, but could not`),f??(f=y)}f.write(s,u,b),u+=f.byteSize,l++}Ge.u32.write(s,c,l),Te.strict.equal(l,t,`Expected set to have size ${t}, but has ${l}.`)},read:function(s,c){const d=Ge.u32.read(s,c);Te.strict.equal(d,t,`Expected set to have size ${t}, but has ${d}.`);let u=c+4;const l=new Set;for(let b=0;b<d;b++){const f=i?e:e.toFixedFromData(s,u),y=f.read(s,u);u+=f.byteSize,l.add(y)}return l},elementByteSize:a,byteSize:o,length:t,lenPrefixByteSize:4,description:`Set<${e.description}>`}}function yr(e){const r=(0,We.isFixedSizeBeet)(e);return{toFixedFromData(t,i){const n=Ge.u32.read(t,i);let a=i+4;if(r)return ye(e,new Map,n);const o=new Map;for(let s=0;s<n;s++){const c=r?e:e.toFixedFromData(t,a),d=c.read(t,a);a+=c.byteSize,o.set(d,c)}return ye(e,o,n)},toFixedFromValue(t){const i=t.size;if(r)return ye(e,new Map,i);const n=new Map;for(const a of t){const o=r?e:e.toFixedFromValue(a);n.set(a,o)}return ye(e,n,i)},description:`FixableSet<${e.description}>`}}Q.set=yr;Q.setsTypeMap={Set:{beet:"set",isFixable:!0,sourcePack:We.BEET_PACKAGE,ts:"Set"}};(function(e){var r=_&&_.__createBinding||(Object.create?function(f,y,p,g){g===void 0&&(g=p);var m=Object.getOwnPropertyDescriptor(y,p);(!m||("get"in m?!y.__esModule:m.writable||m.configurable))&&(m={enumerable:!0,get:function(){return y[p]}}),Object.defineProperty(f,g,m)}:function(f,y,p,g){g===void 0&&(g=p),f[g]=y[p]}),t=_&&_.__exportStar||function(f,y){for(var p in f)p!=="default"&&!Object.prototype.hasOwnProperty.call(y,p)&&r(y,f,p)};Object.defineProperty(e,"__esModule",{value:!0}),e.supportedTypeMap=void 0;const i=S,n=A,a=K,o=Le,s=T,c=J,d=N,u=X,l=V,b=Q;t(J,e),t(S,e),t(A,e),t(T,e),t(X,e),t(K,e),t(Q,e),t(Le,e),t(N,e),t(V,e),t(I,e),t(Z,e),t(O,e),t(D,e),t(h,e),e.supportedTypeMap={...i.collectionsTypeMap,...o.stringTypeMap,...n.compositesTypeMap,...s.enumsTypeMap,...a.numbersTypeMap,...c.aliasesTypeMap,...d.tuplesTypeMap,...u.mapsTypeMap,...b.setsTypeMap,...l.unitTypeMap}})(Ue);var mr={},H={};Object.defineProperty(H,"__esModule",{value:!0});H.keysTypeMap=H.publicKey=void 0;const pr=At,hr=Ue,_r="@metaplex-foundation/beet-solana",Er="@solana/web3.js",Pe=(0,hr.fixedSizeUint8Array)(32);H.publicKey={write:function(e,r,t){const i=t.toBytes();Pe.write(e,r,i)},read:function(e,r){const t=Pe.read(e,r);return new pr.PublicKey(t)},byteSize:Pe.byteSize,description:"PublicKey"};H.keysTypeMap={publicKey:{beet:"publicKey",isFixable:!1,sourcePack:_r,ts:"PublicKey",pack:Er}};var Se={},M={},Cr=_&&_.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(M,"__esModule",{value:!0});M.logTrace=M.logDebug=M.logInfo=M.logError=void 0;const Fe=Cr(me.exports);M.logError=(0,Fe.default)("beet:error");M.logInfo=(0,Fe.default)("beet:info");M.logDebug=(0,Fe.default)("beet:debug");M.logTrace=(0,Fe.default)("beet:trace");var ve={};function Sr(e){if(e.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),t=0;t<r.length;t++)r[t]=255;for(var i=0;i<e.length;i++){var n=e.charAt(i),a=n.charCodeAt(0);if(r[a]!==255)throw new TypeError(n+" is ambiguous");r[a]=i}var o=e.length,s=e.charAt(0),c=Math.log(o)/Math.log(256),d=Math.log(256)/Math.log(o);function u(f){if(f instanceof Uint8Array||(ArrayBuffer.isView(f)?f=new Uint8Array(f.buffer,f.byteOffset,f.byteLength):Array.isArray(f)&&(f=Uint8Array.from(f))),!(f instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(f.length===0)return"";for(var y=0,p=0,g=0,m=f.length;g!==m&&f[g]===0;)g++,y++;for(var C=(m-g)*d+1>>>0,w=new Uint8Array(C);g!==m;){for(var F=f[g],k=0,v=C-1;(F!==0||k<p)&&v!==-1;v--,k++)F+=256*w[v]>>>0,w[v]=F%o>>>0,F=F/o>>>0;if(F!==0)throw new Error("Non-zero carry");p=k,g++}for(var B=C-p;B!==C&&w[B]===0;)B++;for(var q=s.repeat(y);B<C;++B)q+=e.charAt(w[B]);return q}function l(f){if(typeof f!="string")throw new TypeError("Expected String");if(f.length===0)return new Uint8Array;for(var y=0,p=0,g=0;f[y]===s;)p++,y++;for(var m=(f.length-y)*c+1>>>0,C=new Uint8Array(m);f[y];){var w=r[f.charCodeAt(y)];if(w===255)return;for(var F=0,k=m-1;(w!==0||F<g)&&k!==-1;k--,F++)w+=o*C[k]>>>0,C[k]=w%256>>>0,w=w/256>>>0;if(w!==0)throw new Error("Non-zero carry");g=F,y++}for(var v=m-g;v!==m&&C[v]===0;)v++;for(var B=new Uint8Array(p+(m-v)),q=p;v!==m;)B[q++]=C[v++];return B}function b(f){var y=l(f);if(y)return y;throw new Error("Non-base"+o+" character")}return{encode:u,decodeUnsafe:l,decode:b}}var Fr=Sr;const vr=Fr,Ar="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";var wr=vr(Ar),zr=_&&_.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(ve,"__esModule",{value:!0});ve.encodeFixedBeet=void 0;const Br=zr(wr);function Tr(e,r){const t=j.Buffer.alloc(e.byteSize);return e.write(t,0,r),Br.default.encode(t)}ve.encodeFixedBeet=Tr;Object.defineProperty(Se,"__esModule",{value:!0});Se.GpaBuilder=void 0;const xe=Ue,ce=x.exports,Pr=M,st=ve;class he{constructor(r,t,i){this.programId=r,this.beets=t,this.accountSize=i,this.config={}}_addFilter(r){return this.config.filters==null&&(this.config.filters=[]),this.config.filters.push(r),this}_addInnerFilter(r,t,i){(0,Pr.logTrace)(`gpa.addInnerFilter: ${r}.${t}`);const n=this.beets.get(r);(0,ce.strict)(n!=null,"Outer filter key needs to be an existing field name");const a=n.beet;let o=n.offset;const s=(0,xe.isFixedSizeBeet)(a)?a:a.toFixedFromValue(i);let c;for(const[u,l]of s.fields){if(u===t){c=l;break}o+=l.byteSize}(0,ce.strict)(c!=null,`${t} is not a field of the ${r} struct`);const d=(0,st.encodeFixedBeet)(c,i);return this._addFilter({memcmp:{offset:o,bytes:d}}),this}addInnerFilter(r,t){const i=r.split(".");ce.strict.equal(i.length,2,"inner filters can go only one level deep, i.e. 'outer.inner' is ok, but 'outer.inner.deep' is not");const[n,a]=i;return this._addInnerFilter(n,a,t)}addFilter(r,t){const i=this.beets.get(r);(0,ce.strict)(i!=null,"Filter key needs to be an existing field name");const n=(0,xe.isFixedSizeBeet)(i.beet)?i.beet:i.beet.toFixedFromValue(t),a=(0,st.encodeFixedBeet)(n,t);return this._addFilter({memcmp:{offset:i.offset,bytes:a}}),this}dataSize(r){return r=r??this.accountSize,(0,ce.strict)(r!=null,"for accounts of dynamic size the dataSize arg needs to be provided"),this._addFilter({dataSize:r})}run(r){return r.getProgramAccounts(this.programId,this.config)}static fromBeetFields(r,t){const i=new Map;let n=0,a=!1;for(const[s,c]of t){if(i.set(s,{beet:c,offset:n}),!(0,xe.isFixedSizeBeet)(c)){a=!0;break}n+=c.byteSize}const o=a?void 0:n;return new he(r,i,o)}static fromStruct(r,t){return he.fromBeetFields(r,t.fields)}}Se.GpaBuilder=he;(function(e){var r=_&&_.__createBinding||(Object.create?function(n,a,o,s){s===void 0&&(s=o);var c=Object.getOwnPropertyDescriptor(a,o);(!c||("get"in c?!a.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return a[o]}}),Object.defineProperty(n,s,c)}:function(n,a,o,s){s===void 0&&(s=o),n[s]=a[o]}),t=_&&_.__exportStar||function(n,a){for(var o in n)o!=="default"&&!Object.prototype.hasOwnProperty.call(a,o)&&r(a,n,o)};Object.defineProperty(e,"__esModule",{value:!0}),e.supportedTypeMap=void 0;const i=H;t(H,e),t(Se,e),e.supportedTypeMap=i.keysTypeMap})(mr);var xr={},z={},Ae={};Object.defineProperty(Ae,"__esModule",{value:!0});Ae.errorCodeFromLogs=void 0;const $r=/Custom program error: (0x[a-f0-9]+)/i;function Mr(e){for(const r of e){const t=r.match($r);if(t==null)continue;const i=t[1];try{return parseInt(i)}catch{}}return null}Ae.errorCodeFromLogs=Mr;var Et={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.LangErrorMessage=e.LangErrorCode=void 0,e.LangErrorCode={InstructionMissing:100,InstructionFallbackNotFound:101,InstructionDidNotDeserialize:102,InstructionDidNotSerialize:103,IdlInstructionStub:1e3,IdlInstructionInvalidProgram:1001,ConstraintMut:2e3,ConstraintHasOne:2001,ConstraintSigner:2002,ConstraintRaw:2003,ConstraintOwner:2004,ConstraintRentExempt:2005,ConstraintSeeds:2006,ConstraintExecutable:2007,ConstraintState:2008,ConstraintAssociated:2009,ConstraintAssociatedInit:2010,ConstraintClose:2011,ConstraintAddress:2012,ConstraintZero:2013,ConstraintTokenMint:2014,ConstraintTokenOwner:2015,ConstraintMintMintAuthority:2016,ConstraintMintFreezeAuthority:2017,ConstraintMintDecimals:2018,ConstraintSpace:2019,AccountDiscriminatorAlreadySet:3e3,AccountDiscriminatorNotFound:3001,AccountDiscriminatorMismatch:3002,AccountDidNotDeserialize:3003,AccountDidNotSerialize:3004,AccountNotEnoughKeys:3005,AccountNotMutable:3006,AccountOwnedByWrongProgram:3007,InvalidProgramId:3008,InvalidProgramExecutable:3009,AccountNotSigner:3010,AccountNotSystemOwned:3011,AccountNotInitialized:3012,AccountNotProgramData:3013,StateInvalidAddress:4e3,Deprecated:5e3},e.LangErrorMessage=new Map([[e.LangErrorCode.InstructionMissing,"8 byte instruction identifier not provided"],[e.LangErrorCode.InstructionFallbackNotFound,"Fallback functions are not supported"],[e.LangErrorCode.InstructionDidNotDeserialize,"The program could not deserialize the given instruction"],[e.LangErrorCode.InstructionDidNotSerialize,"The program could not serialize the given instruction"],[e.LangErrorCode.IdlInstructionStub,"The program was compiled without idl instructions"],[e.LangErrorCode.IdlInstructionInvalidProgram,"The transaction was given an invalid program for the IDL instruction"],[e.LangErrorCode.ConstraintMut,"A mut constraint was violated"],[e.LangErrorCode.ConstraintHasOne,"A has_one constraint was violated"],[e.LangErrorCode.ConstraintSigner,"A signer constraint was violated"],[e.LangErrorCode.ConstraintRaw,"A raw constraint was violated"],[e.LangErrorCode.ConstraintOwner,"An owner constraint was violated"],[e.LangErrorCode.ConstraintRentExempt,"A rent exempt constraint was violated"],[e.LangErrorCode.ConstraintSeeds,"A seeds constraint was violated"],[e.LangErrorCode.ConstraintExecutable,"An executable constraint was violated"],[e.LangErrorCode.ConstraintState,"A state constraint was violated"],[e.LangErrorCode.ConstraintAssociated,"An associated constraint was violated"],[e.LangErrorCode.ConstraintAssociatedInit,"An associated init constraint was violated"],[e.LangErrorCode.ConstraintClose,"A close constraint was violated"],[e.LangErrorCode.ConstraintAddress,"An address constraint was violated"],[e.LangErrorCode.ConstraintZero,"Expected zero account discriminant"],[e.LangErrorCode.ConstraintTokenMint,"A token mint constraint was violated"],[e.LangErrorCode.ConstraintTokenOwner,"A token owner constraint was violated"],[e.LangErrorCode.ConstraintMintMintAuthority,"A mint mint authority constraint was violated"],[e.LangErrorCode.ConstraintMintFreezeAuthority,"A mint freeze authority constraint was violated"],[e.LangErrorCode.ConstraintMintDecimals,"A mint decimals constraint was violated"],[e.LangErrorCode.ConstraintSpace,"A space constraint was violated"],[e.LangErrorCode.AccountDiscriminatorAlreadySet,"The account discriminator was already set on this account"],[e.LangErrorCode.AccountDiscriminatorNotFound,"No 8 byte discriminator was found on the account"],[e.LangErrorCode.AccountDiscriminatorMismatch,"8 byte discriminator did not match what was expected"],[e.LangErrorCode.AccountDidNotDeserialize,"Failed to deserialize the account"],[e.LangErrorCode.AccountDidNotSerialize,"Failed to serialize the account"],[e.LangErrorCode.AccountNotEnoughKeys,"Not enough account keys given to the instruction"],[e.LangErrorCode.AccountNotMutable,"The given account is not mutable"],[e.LangErrorCode.AccountOwnedByWrongProgram,"The given account is owned by a different program than expected"],[e.LangErrorCode.InvalidProgramId,"Program ID was not as expected"],[e.LangErrorCode.InvalidProgramExecutable,"Program account is not executable"],[e.LangErrorCode.AccountNotSigner,"The given account did not sign"],[e.LangErrorCode.AccountNotSystemOwned,"The given account is not owned by the system program"],[e.LangErrorCode.AccountNotInitialized,"The program expected this account to be already initialized"],[e.LangErrorCode.AccountNotProgramData,"The given account is not a program data account"],[e.LangErrorCode.StateInvalidAddress,"The given state account does not have the correct address"],[e.LangErrorCode.Deprecated,"The API being used is deprecated and should no longer be used"]])})(Et);var we={};Object.defineProperty(we,"__esModule",{value:!0});we.tokenLendingErrors=void 0;we.tokenLendingErrors=new Map([[0,{code:0,message:'Failed to unpack instruction data"',name:"InstructionUnpackError"}],[1,{code:1,message:'Account is already initialized"',name:"AlreadyInitialized"}],[2,{code:2,message:'Lamport balance below rent-exempt threshold"',name:"NotRentExempt"}],[3,{code:3,message:'Market authority is invalid"',name:"InvalidMarketAuthority"}],[4,{code:4,message:'Market owner is invalid"',name:"InvalidMarketOwner"}],[5,{code:5,message:'Input account owner is not the program address"',name:"InvalidAccountOwner"}],[6,{code:6,message:'Input token account is not owned by the correct token program id"',name:"InvalidTokenOwner"}],[7,{code:7,message:'Input token account is not valid"',name:"InvalidTokenAccount"}],[8,{code:8,message:'Input token mint account is not valid"',name:"InvalidTokenMint"}],[9,{code:9,message:'Input token program account is not valid"',name:"InvalidTokenProgram"}],[10,{code:10,message:'Input amount is invalid"',name:"InvalidAmount"}],[11,{code:11,message:'Input config value is invalid"',name:"InvalidConfig"}],[12,{code:12,message:'Input account must be a signer"',name:"InvalidSigner"}],[13,{code:13,message:'Invalid account input"',name:"InvalidAccountInput"}],[14,{code:14,message:'Math operation overflow"',name:"MathOverflow"}],[15,{code:15,message:'Token initialize mint failed"',name:"TokenInitializeMintFailed"}],[16,{code:16,message:'Token initialize account failed"',name:"TokenInitializeAccountFailed"}],[17,{code:17,message:'Token transfer failed"',name:"TokenTransferFailed"}],[18,{code:18,message:'Token mint to failed"',name:"TokenMintToFailed"}],[19,{code:19,message:'Token burn failed"',name:"TokenBurnFailed"}],[20,{code:20,message:'Insufficient liquidity available"',name:"InsufficientLiquidity"}],[21,{code:21,message:'Input reserve has collateral disabled"',name:"ReserveCollateralDisabled"}],[22,{code:22,message:'Reserve state needs to be refreshed"',name:"ReserveStale"}],[23,{code:23,message:'Withdraw amount too small"',name:"WithdrawTooSmall"}],[24,{code:24,message:'Withdraw amount too large"',name:"WithdrawTooLarge"}],[25,{code:25,message:'Borrow amount too small to receive liquidity after fees"',name:"BorrowTooSmall"}],[26,{code:26,message:'Borrow amount too large for deposited collateral"',name:"BorrowTooLarge"}],[27,{code:27,message:'Repay amount too small to transfer liquidity"',name:"RepayTooSmall"}],[28,{code:28,message:'Liquidation amount too small to receive collateral"',name:"LiquidationTooSmall"}],[29,{code:29,message:'Cannot liquidate healthy obligations"',name:"ObligationHealthy"}],[30,{code:30,message:'Obligation state needs to be refreshed"',name:"ObligationStale"}],[31,{code:31,message:'Obligation reserve limit exceeded"',name:"ObligationReserveLimit"}],[32,{code:32,message:'Obligation owner is invalid"',name:"InvalidObligationOwner"}],[33,{code:33,message:'Obligation deposits are empty"',name:"ObligationDepositsEmpty"}],[34,{code:34,message:'Obligation borrows are empty"',name:"ObligationBorrowsEmpty"}],[35,{code:35,message:'Obligation deposits have zero value"',name:"ObligationDepositsZero"}],[36,{code:36,message:'Obligation borrows have zero value"',name:"ObligationBorrowsZero"}],[37,{code:37,message:'Invalid obligation collateral"',name:"InvalidObligationCollateral"}],[38,{code:38,message:'Invalid obligation liquidity"',name:"InvalidObligationLiquidity"}],[39,{code:39,message:'Obligation collateral is empty"',name:"ObligationCollateralEmpty"}],[40,{code:40,message:'Obligation liquidity is empty"',name:"ObligationLiquidityEmpty"}],[41,{code:41,message:'Interest rate is negative"',name:"NegativeInterestRate"}],[42,{code:42,message:'Input oracle config is invalid"',name:"InvalidOracleConfig"}],[43,{code:43,message:'Input flash loan receiver program account is not valid"',name:"InvalidFlashLoanReceiverProgram"}],[44,{code:44,message:'Not enough liquidity after flash loan"',name:"NotEnoughLiquidityAfterFlashLoan"}]]);var Or=_&&_.__createBinding||(Object.create?function(e,r,t,i){i===void 0&&(i=t),Object.defineProperty(e,i,{enumerable:!0,get:function(){return r[t]}})}:function(e,r,t,i){i===void 0&&(i=t),e[i]=r[t]}),Ir=_&&_.__setModuleDefault||(Object.create?function(e,r){Object.defineProperty(e,"default",{enumerable:!0,value:r})}:function(e,r){e.default=r}),kr=_&&_.__importStar||function(e){if(e&&e.__esModule)return e;var r={};if(e!=null)for(var t in e)t!=="default"&&Object.prototype.hasOwnProperty.call(e,t)&&Or(r,e,t);return Ir(r,e),r};Object.defineProperty(z,"__esModule",{value:!0});z.TokenLendingError=z.AnchorError=z.CustomProgramError=z.CusperUnknownError=z.initCusper=z.ErrorResolver=void 0;const Lr=Ae,ct=kr(Et),Dr=we;class Ct{constructor(r){this.resolveErrorFromCode=r}errorFromCode(r,t,i=!0){let n=this.resolveErrorFromCode!=null?this.resolveErrorFromCode(r):null;if(n!=null)return this.passPreparedError(n,t??this.errorFromCode);if(n=ae.fromCode(r),n!=null)return this.passPreparedError(n,t??this.errorFromCode);if(n=se.fromCode(r),n!=null)return this.passPreparedError(n,t??this.errorFromCode);if(i)return n=new Ke(r,"CusperUnknownError","cusper does not know this error"),this.passPreparedError(n,t??this.errorFromCode)}errorFromProgramLogs(r,t=!0){const i=(0,Lr.errorCodeFromLogs)(r);return i==null?null:this.errorFromCode(i,this.errorFromProgramLogs,t)}throwError(r){const t=r.logs!=null&&this.errorFromProgramLogs(r.logs,!0)||new Ke(-1,"Error created without logs and thus without error code");throw this.passPreparedError(t,this.throwError)}passPreparedError(r,t){return r==null?null:(typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(r,t),r)}}z.ErrorResolver=Ct;function Nr(e){return new Ct(e)}z.initCusper=Nr;class Ke extends Error{constructor(r,...t){super(...t),this.code=r,this.name="CusperUnknownError"}}z.CusperUnknownError=Ke;class jr extends Error{constructor(r,t,...i){super(...i),this.code=r,this.name=`CustomProgramError#${t}`}}z.CustomProgramError=jr;class ae extends Error{constructor(r,t,...i){super(...i),this.code=r,this.name=`AnchorError#${t}`}static fromCode(r){const t=ae.errorMap.get(r);return t!=null?new ae(t.code,t.name,t.message):null}toString(){return`${this.name}: ${this.message}`}}z.AnchorError=ae;ae.errorMap=Object.entries(ct.LangErrorCode).reduce((e,[r,t])=>(e.set(t,{code:t,name:r,message:ct.LangErrorMessage.get(t)}),e),new Map);class se extends Error{constructor(r,t,...i){super(...i),this.code=r,this.name=`TokenLendingError#${t}`}static fromCode(r){const t=se.errorMap.get(r);return t!=null?new se(t.code,t.name,t.message):null}toString(){return`${this.name}: ${this.message}`}}z.TokenLendingError=se;se.errorMap=Dr.tokenLendingErrors;var St={};Object.defineProperty(St,"__esModule",{value:!0});(function(e){var r=_&&_.__createBinding||(Object.create?function(i,n,a,o){o===void 0&&(o=a),Object.defineProperty(i,o,{enumerable:!0,get:function(){return n[a]}})}:function(i,n,a,o){o===void 0&&(o=a),i[o]=n[a]}),t=_&&_.__exportStar||function(i,n){for(var a in i)a!=="default"&&!Object.prototype.hasOwnProperty.call(n,a)&&r(n,i,a)};Object.defineProperty(e,"__esModule",{value:!0}),t(z,e),t(St,e)})(xr);export{mr as a,Ue as b,xr as c,me as d,dt as e};
